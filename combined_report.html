
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>SAST & Dependency Vulnerability Report</title>
            <style>
                body { font-family: Arial, sans-serif; margin: 20px; }
                h1, h3 { color: #333; }
                .summary-table { width: 100%; border-collapse: collapse; margin-bottom: 20px; }
                .summary-table th, .summary-table td { padding: 10px; border: 1px solid #ddd; text-align: center; }
                .summary-table th { background-color: #f2f2f2; }
                .issue-summary { margin: 10px 0; padding: 10px; border: 1px solid #ddd; cursor: pointer; border-radius: 5px; display: flex; }
                .issue-summary:hover { background-color: #f0f0f0; }
                .issue-number { width: 40px; text-align: center; font-weight: bold; }
                .severity-high { background-color: #f8d7da; }
                .severity-medium { background-color: #fff3cd; }
                .severity-low { background-color: #d4edda; }
                .severity-critical { background-color: #ff0000; color: white; }
                .issue-detail { display: none; padding: 10px; border: 1px solid #ddd; background-color: #f9f9f9; margin-top: 10px; border-radius: 5px; }
                .issue-detail h4 { margin: 0; }
            </style>
            <script>
                function toggleDetail(id) {
                    var detail = document.getElementById(id);
                    detail.style.display = detail.style.display === 'block' ? 'none' : 'block';
                }
            </script>
        </head>
        <body>
            <h1>SAST & Dependency Vulnerability Report</h1>

            <!-- SAST 漏洞汇总 -->
            <h2>SAST 漏洞汇总：</h2>
            <table class="summary-table">
                <thead>
                    <tr>
                        <th>严重级别</th>
                        <th>漏洞数量</th>
                    </tr>
                </thead>
                <tbody>
                    
                    <tr>
                        <td>Critical</td>
                        <td>10</td>
                    </tr>
                    
                    <tr>
                        <td>High</td>
                        <td>1</td>
                    </tr>
                    
                    <tr>
                        <td>Medium</td>
                        <td>24</td>
                    </tr>
                    
                    <tr>
                        <td>Low</td>
                        <td>0</td>
                    </tr>
                    
                </tbody>
            </table>

            <h2>SAST 漏洞信息：</h2>
            
                
                    <h3>Critical 风险漏洞（共10个）：</h3>
                    <ul>
                        
                            <li>
                                <div class="issue-summary severity-critical"
                                     onclick="toggleDetail('cb48a8b8a2cb5b69cd0d689afe08f2447178862c1e0c88793fcae77f8748b507')">
                                    <div class="issue-number">1</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> Improper neutralization of special elements used in an OS command ('OS Command Injection')
                                        <br>
                                        <strong>文件位置：</strong> vulnerabilities/view_help.php:20
                                    </div>
                                </div>
                                <div class="issue-detail" id="cb48a8b8a2cb5b69cd0d689afe08f2447178862c1e0c88793fcae77f8748b507">
                                    <h4>Improper neutralization of special elements used in an OS command ('OS Command Injection') - 详细信息</h4>
                                    <p><strong>Severity:</strong> Critical</p>
                                    <p><strong>File:</strong> vulnerabilities/view_help.php</p>
                                    <p><strong>Line:</strong> 20</p>
                                    <p><strong>Description:</strong> Evaluating non-constant commands. This can lead to command injection.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-critical"
                                     onclick="toggleDetail('bc5196dd6926bda11c424a5211d8ea07c4eff2cc74e2404b14af4cfad9d61980')">
                                    <div class="issue-number">2</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> Improper neutralization of special elements used in an OS command ('OS Command Injection')
                                        <br>
                                        <strong>文件位置：</strong> vulnerabilities/view_help.php:22
                                    </div>
                                </div>
                                <div class="issue-detail" id="bc5196dd6926bda11c424a5211d8ea07c4eff2cc74e2404b14af4cfad9d61980">
                                    <h4>Improper neutralization of special elements used in an OS command ('OS Command Injection') - 详细信息</h4>
                                    <p><strong>Severity:</strong> Critical</p>
                                    <p><strong>File:</strong> vulnerabilities/view_help.php</p>
                                    <p><strong>Line:</strong> 22</p>
                                    <p><strong>Description:</strong> Evaluating non-constant commands. This can lead to command injection.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-critical"
                                     onclick="toggleDetail('ca3bde4afa66fe32c34402ed6c4037c075c1a4d447d00724bd56a76be76f33ba')">
                                    <div class="issue-number">3</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> Improper control of generation of code ('Code Injection')
                                        <br>
                                        <strong>文件位置：</strong> vulnerabilities/exec/source/low.php:10
                                    </div>
                                </div>
                                <div class="issue-detail" id="ca3bde4afa66fe32c34402ed6c4037c075c1a4d447d00724bd56a76be76f33ba">
                                    <h4>Improper control of generation of code ('Code Injection') - 详细信息</h4>
                                    <p><strong>Severity:</strong> Critical</p>
                                    <p><strong>File:</strong> vulnerabilities/exec/source/low.php</p>
                                    <p><strong>Line:</strong> 10</p>
                                    <p><strong>Description:</strong> Executing non-constant commands. This can lead to command injection.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-critical"
                                     onclick="toggleDetail('966bfbb7a6caedb8655c0cc8731c24cd26b56ac3edfa0078345ba6dea6b90cec')">
                                    <div class="issue-number">4</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> Improper control of generation of code ('Code Injection')
                                        <br>
                                        <strong>文件位置：</strong> vulnerabilities/exec/source/low.php:14
                                    </div>
                                </div>
                                <div class="issue-detail" id="966bfbb7a6caedb8655c0cc8731c24cd26b56ac3edfa0078345ba6dea6b90cec">
                                    <h4>Improper control of generation of code ('Code Injection') - 详细信息</h4>
                                    <p><strong>Severity:</strong> Critical</p>
                                    <p><strong>File:</strong> vulnerabilities/exec/source/low.php</p>
                                    <p><strong>Line:</strong> 14</p>
                                    <p><strong>Description:</strong> Executing non-constant commands. This can lead to command injection.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-critical"
                                     onclick="toggleDetail('f838fedb847b617ef2769417aae119bada547acc18fd770675f191dd2fdeaf35')">
                                    <div class="issue-number">5</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> Improper control of generation of code ('Code Injection')
                                        <br>
                                        <strong>文件位置：</strong> vulnerabilities/exec/source/medium.php:19
                                    </div>
                                </div>
                                <div class="issue-detail" id="f838fedb847b617ef2769417aae119bada547acc18fd770675f191dd2fdeaf35">
                                    <h4>Improper control of generation of code ('Code Injection') - 详细信息</h4>
                                    <p><strong>Severity:</strong> Critical</p>
                                    <p><strong>File:</strong> vulnerabilities/exec/source/medium.php</p>
                                    <p><strong>Line:</strong> 19</p>
                                    <p><strong>Description:</strong> Executing non-constant commands. This can lead to command injection.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-critical"
                                     onclick="toggleDetail('05bff37f11b787d35128ed02a16c7db2af71f73318c29583c58ec758b7bc33da')">
                                    <div class="issue-number">6</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> Improper control of generation of code ('Code Injection')
                                        <br>
                                        <strong>文件位置：</strong> vulnerabilities/exec/source/impossible.php:22
                                    </div>
                                </div>
                                <div class="issue-detail" id="05bff37f11b787d35128ed02a16c7db2af71f73318c29583c58ec758b7bc33da">
                                    <h4>Improper control of generation of code ('Code Injection') - 详细信息</h4>
                                    <p><strong>Severity:</strong> Critical</p>
                                    <p><strong>File:</strong> vulnerabilities/exec/source/impossible.php</p>
                                    <p><strong>Line:</strong> 22</p>
                                    <p><strong>Description:</strong> Executing non-constant commands. This can lead to command injection.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-critical"
                                     onclick="toggleDetail('ecd1b3c38b0e1fb2f3f1969007edb81274dad8f4737e7b38918001b82ca41aef')">
                                    <div class="issue-number">7</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> Improper control of generation of code ('Code Injection')
                                        <br>
                                        <strong>文件位置：</strong> vulnerabilities/exec/source/medium.php:23
                                    </div>
                                </div>
                                <div class="issue-detail" id="ecd1b3c38b0e1fb2f3f1969007edb81274dad8f4737e7b38918001b82ca41aef">
                                    <h4>Improper control of generation of code ('Code Injection') - 详细信息</h4>
                                    <p><strong>Severity:</strong> Critical</p>
                                    <p><strong>File:</strong> vulnerabilities/exec/source/medium.php</p>
                                    <p><strong>Line:</strong> 23</p>
                                    <p><strong>Description:</strong> Executing non-constant commands. This can lead to command injection.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-critical"
                                     onclick="toggleDetail('c3c0378e9318a24d6dbad25c9954a36bc41ed60e29f53c1cafc97886125ee551')">
                                    <div class="issue-number">8</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> Improper control of generation of code ('Code Injection')
                                        <br>
                                        <strong>文件位置：</strong> vulnerabilities/exec/source/high.php:26
                                    </div>
                                </div>
                                <div class="issue-detail" id="c3c0378e9318a24d6dbad25c9954a36bc41ed60e29f53c1cafc97886125ee551">
                                    <h4>Improper control of generation of code ('Code Injection') - 详细信息</h4>
                                    <p><strong>Severity:</strong> Critical</p>
                                    <p><strong>File:</strong> vulnerabilities/exec/source/high.php</p>
                                    <p><strong>Line:</strong> 26</p>
                                    <p><strong>Description:</strong> Executing non-constant commands. This can lead to command injection.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-critical"
                                     onclick="toggleDetail('f3aa38ab5f398bcb0803813dfbd37c5654f5a9b342853b9feef38c97333119b6')">
                                    <div class="issue-number">9</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> Improper control of generation of code ('Code Injection')
                                        <br>
                                        <strong>文件位置：</strong> vulnerabilities/exec/source/impossible.php:26
                                    </div>
                                </div>
                                <div class="issue-detail" id="f3aa38ab5f398bcb0803813dfbd37c5654f5a9b342853b9feef38c97333119b6">
                                    <h4>Improper control of generation of code ('Code Injection') - 详细信息</h4>
                                    <p><strong>Severity:</strong> Critical</p>
                                    <p><strong>File:</strong> vulnerabilities/exec/source/impossible.php</p>
                                    <p><strong>Line:</strong> 26</p>
                                    <p><strong>Description:</strong> Executing non-constant commands. This can lead to command injection.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-critical"
                                     onclick="toggleDetail('00e88895866945b5568e6a2853d1702a21f056a8a95dec78afd87734978d17f7')">
                                    <div class="issue-number">10</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> Improper control of generation of code ('Code Injection')
                                        <br>
                                        <strong>文件位置：</strong> vulnerabilities/exec/source/high.php:30
                                    </div>
                                </div>
                                <div class="issue-detail" id="00e88895866945b5568e6a2853d1702a21f056a8a95dec78afd87734978d17f7">
                                    <h4>Improper control of generation of code ('Code Injection') - 详细信息</h4>
                                    <p><strong>Severity:</strong> Critical</p>
                                    <p><strong>File:</strong> vulnerabilities/exec/source/high.php</p>
                                    <p><strong>Line:</strong> 30</p>
                                    <p><strong>Description:</strong> Executing non-constant commands. This can lead to command injection.</p>
                                </div>
                            </li>
                        
                    </ul>
                
            
                
                    <h3>High 风险漏洞（共1个）：</h3>
                    <ul>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('93bc68acd5ce5b5cc55456edf64db1c5a240f569c7e28bcd175dc8f68389d388')">
                                    <div class="issue-number">1</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> Improper neutralization of directives in dynamically evaluated code ('Eval Injection')
                                        <br>
                                        <strong>文件位置：</strong> vulnerabilities/javascript/source/high.js:1
                                    </div>
                                </div>
                                <div class="issue-detail" id="93bc68acd5ce5b5cc55456edf64db1c5a240f569c7e28bcd175dc8f68389d388">
                                    <h4>Improper neutralization of directives in dynamically evaluated code ('Eval Injection') - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>File:</strong> vulnerabilities/javascript/source/high.js</p>
                                    <p><strong>Line:</strong> 1</p>
                                    <p><strong>Description:</strong> The application was found calling the `eval` function OR Function()
  constructor OR setTimeout() OR setInterval() methods. If the

  variables or strings or functions passed to these methods contains user-supplied input, an adversary could attempt to execute arbitrary

  JavaScript

  code. This could lead to a full system compromise in Node applications or Cross-site Scripting

  (XSS) in web applications.


  To remediate this issue, remove all calls to above methods and consider alternative methods for

  executing

  the necessary business logic. There is almost no safe method of calling `eval` or other above stated sinks with

  user-supplied input.

  Instead, consider alternative methods such as using property accessors to dynamically access

  values.


  Example using property accessors to dynamically access an object's property:

  ```

  // Define an object

  const obj = {key1: 'value1', key2: 'value2'};

  // Get key dynamically from user input

  const key = getUserInput();

  // Check if the key exists in our object and return it, or a default empty string

  const value = (obj.hasOwnProperty(key)) ? obj[key] : '';

  // Work with the value

  ```


  For more information on why not to use `eval`, and alternatives see:

  - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval#never_use_eval!

  Other References:

  - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/Function

  - https://developer.mozilla.org/en-US/docs/Web/API/setTimeout

  - https://developer.mozilla.org/en-US/docs/Web/API/setInterval
</p>
                                </div>
                            </li>
                        
                    </ul>
                
            
                
                    <h3>Medium 风险漏洞（共24个）：</h3>
                    <ul>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('59c82ceb95ef0f9e281de5339f6644de43d7afc5da42e747cbea028a28a0821b')">
                                    <div class="issue-number">1</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> Use of weak hash
                                        <br>
                                        <strong>文件位置：</strong> vulnerabilities/weak_id/source/high.php:10
                                    </div>
                                </div>
                                <div class="issue-detail" id="59c82ceb95ef0f9e281de5339f6644de43d7afc5da42e747cbea028a28a0821b">
                                    <h4>Use of weak hash - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>File:</strong> vulnerabilities/weak_id/source/high.php</p>
                                    <p><strong>Line:</strong> 10</p>
                                    <p><strong>Description:</strong> Detected usage of weak crypto function. Consider using stronger alternatives.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('7bcc4eff03747451914bbed65ce771507527cf937efcc5d31e1b17e02e183939')">
                                    <div class="issue-number">2</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> Use of weak hash
                                        <br>
                                        <strong>文件位置：</strong> vulnerabilities/brute/source/medium.php:11
                                    </div>
                                </div>
                                <div class="issue-detail" id="7bcc4eff03747451914bbed65ce771507527cf937efcc5d31e1b17e02e183939">
                                    <h4>Use of weak hash - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>File:</strong> vulnerabilities/brute/source/medium.php</p>
                                    <p><strong>Line:</strong> 11</p>
                                    <p><strong>Description:</strong> Detected usage of weak crypto function. Consider using stronger alternatives.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('09bcf8f7884a14c11acf046a941cfd801f2ff7bc9d568805927f47e903b02dae')">
                                    <div class="issue-number">3</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> Use of weak hash
                                        <br>
                                        <strong>文件位置：</strong> vulnerabilities/csrf/source/low.php:12
                                    </div>
                                </div>
                                <div class="issue-detail" id="09bcf8f7884a14c11acf046a941cfd801f2ff7bc9d568805927f47e903b02dae">
                                    <h4>Use of weak hash - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>File:</strong> vulnerabilities/csrf/source/low.php</p>
                                    <p><strong>Line:</strong> 12</p>
                                    <p><strong>Description:</strong> Detected usage of weak crypto function. Consider using stronger alternatives.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('99983ed8bcd755ceb7df71c5d59d109b8d928cf50e215a04a4dda7d4d7237789')">
                                    <div class="issue-number">4</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> Use of weak hash
                                        <br>
                                        <strong>文件位置：</strong> vulnerabilities/captcha/source/impossible.php:14
                                    </div>
                                </div>
                                <div class="issue-detail" id="99983ed8bcd755ceb7df71c5d59d109b8d928cf50e215a04a4dda7d4d7237789">
                                    <h4>Use of weak hash - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>File:</strong> vulnerabilities/captcha/source/impossible.php</p>
                                    <p><strong>Line:</strong> 14</p>
                                    <p><strong>Description:</strong> Detected usage of weak crypto function. Consider using stronger alternatives.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('971ee271b96d16010d29eed48ff59e60160eac06901fbfbc84567e263abbe0b8')">
                                    <div class="issue-number">5</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> Use of weak hash
                                        <br>
                                        <strong>文件位置：</strong> vulnerabilities/csrf/source/medium.php:14
                                    </div>
                                </div>
                                <div class="issue-detail" id="971ee271b96d16010d29eed48ff59e60160eac06901fbfbc84567e263abbe0b8">
                                    <h4>Use of weak hash - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>File:</strong> vulnerabilities/csrf/source/medium.php</p>
                                    <p><strong>Line:</strong> 14</p>
                                    <p><strong>Description:</strong> Detected usage of weak crypto function. Consider using stronger alternatives.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('7132b11a5ce6a008711219b9c0d17fb3a590ef9c44d5c56b8ad7a279a2bfc2b9')">
                                    <div class="issue-number">6</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> Use of weak hash
                                        <br>
                                        <strong>文件位置：</strong> vulnerabilities/csrf/source/impossible.php:15
                                    </div>
                                </div>
                                <div class="issue-detail" id="7132b11a5ce6a008711219b9c0d17fb3a590ef9c44d5c56b8ad7a279a2bfc2b9">
                                    <h4>Use of weak hash - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>File:</strong> vulnerabilities/csrf/source/impossible.php</p>
                                    <p><strong>Line:</strong> 15</p>
                                    <p><strong>Description:</strong> Detected usage of weak crypto function. Consider using stronger alternatives.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('3a59c36b05a0ad362c181cc1e6d7dbbaa899e4c49feda49ac82146e0460503e4')">
                                    <div class="issue-number">7</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> Use of weak hash
                                        <br>
                                        <strong>文件位置：</strong> vulnerabilities/brute/source/high.php:16
                                    </div>
                                </div>
                                <div class="issue-detail" id="3a59c36b05a0ad362c181cc1e6d7dbbaa899e4c49feda49ac82146e0460503e4">
                                    <h4>Use of weak hash - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>File:</strong> vulnerabilities/brute/source/high.php</p>
                                    <p><strong>Line:</strong> 16</p>
                                    <p><strong>Description:</strong> Detected usage of weak crypto function. Consider using stronger alternatives.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('06f286b6b6d8675020b203d539c16eab729f00d9497144b9af803bcca1adf849')">
                                    <div class="issue-number">8</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> Use of weak hash
                                        <br>
                                        <strong>文件位置：</strong> vulnerabilities/brute/source/impossible.php:16
                                    </div>
                                </div>
                                <div class="issue-detail" id="06f286b6b6d8675020b203d539c16eab729f00d9497144b9af803bcca1adf849">
                                    <h4>Use of weak hash - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>File:</strong> vulnerabilities/brute/source/impossible.php</p>
                                    <p><strong>Line:</strong> 16</p>
                                    <p><strong>Description:</strong> Detected usage of weak crypto function. Consider using stronger alternatives.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('adf91f5cfc95ed38d39d84b80163a6bcfa0b91fadb327b378cbed107a02706a7')">
                                    <div class="issue-number">9</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> Use of weak hash
                                        <br>
                                        <strong>文件位置：</strong> vulnerabilities/upload/source/impossible.php:18
                                    </div>
                                </div>
                                <div class="issue-detail" id="adf91f5cfc95ed38d39d84b80163a6bcfa0b91fadb327b378cbed107a02706a7">
                                    <h4>Use of weak hash - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>File:</strong> vulnerabilities/upload/source/impossible.php</p>
                                    <p><strong>Line:</strong> 18</p>
                                    <p><strong>Description:</strong> Detected usage of weak crypto function. Consider using stronger alternatives.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('e239186c708e0027a1ff0884710e633f9b2f320f048822ac859c4610dd3ebf83')">
                                    <div class="issue-number">10</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> Use of weak hash
                                        <br>
                                        <strong>文件位置：</strong> vulnerabilities/captcha/source/impossible.php:19
                                    </div>
                                </div>
                                <div class="issue-detail" id="e239186c708e0027a1ff0884710e633f9b2f320f048822ac859c4610dd3ebf83">
                                    <h4>Use of weak hash - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>File:</strong> vulnerabilities/captcha/source/impossible.php</p>
                                    <p><strong>Line:</strong> 19</p>
                                    <p><strong>Description:</strong> Detected usage of weak crypto function. Consider using stronger alternatives.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('fb2dfa0fc56b9d1ba99d2d4ecad4ddddf644f8100f069f847a2fee7718d4d246')">
                                    <div class="issue-number">11</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> Use of weak hash
                                        <br>
                                        <strong>文件位置：</strong> vulnerabilities/csrf/test_credentials.php:19
                                    </div>
                                </div>
                                <div class="issue-detail" id="fb2dfa0fc56b9d1ba99d2d4ecad4ddddf644f8100f069f847a2fee7718d4d246">
                                    <h4>Use of weak hash - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>File:</strong> vulnerabilities/csrf/test_credentials.php</p>
                                    <p><strong>Line:</strong> 19</p>
                                    <p><strong>Description:</strong> Detected usage of weak crypto function. Consider using stronger alternatives.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('305c76d0904e024902e3350e3cc92bd98947333607a713357fe981c4c50d78cc')">
                                    <div class="issue-number">12</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> Use of weak hash
                                        <br>
                                        <strong>文件位置：</strong> vulnerabilities/upload/source/impossible.php:20
                                    </div>
                                </div>
                                <div class="issue-detail" id="305c76d0904e024902e3350e3cc92bd98947333607a713357fe981c4c50d78cc">
                                    <h4>Use of weak hash - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>File:</strong> vulnerabilities/upload/source/impossible.php</p>
                                    <p><strong>Line:</strong> 20</p>
                                    <p><strong>Description:</strong> Detected usage of weak crypto function. Consider using stronger alternatives.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('f3dfbf5bc3e3744dd3a25bd4b757606de66aaf62b418150a1da8a500e90dcfa3')">
                                    <div class="issue-number">13</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> Use of weak hash
                                        <br>
                                        <strong>文件位置：</strong> vulnerabilities/captcha/source/impossible.php:24
                                    </div>
                                </div>
                                <div class="issue-detail" id="f3dfbf5bc3e3744dd3a25bd4b757606de66aaf62b418150a1da8a500e90dcfa3">
                                    <h4>Use of weak hash - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>File:</strong> vulnerabilities/captcha/source/impossible.php</p>
                                    <p><strong>Line:</strong> 24</p>
                                    <p><strong>Description:</strong> Detected usage of weak crypto function. Consider using stronger alternatives.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('8f70ba395f0a687a925c7ef01f88e3274e7605d975226a543231aac5ca7aede3')">
                                    <div class="issue-number">14</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> Use of weak hash
                                        <br>
                                        <strong>文件位置：</strong> vulnerabilities/captcha/source/high.php:27
                                    </div>
                                </div>
                                <div class="issue-detail" id="8f70ba395f0a687a925c7ef01f88e3274e7605d975226a543231aac5ca7aede3">
                                    <h4>Use of weak hash - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>File:</strong> vulnerabilities/captcha/source/high.php</p>
                                    <p><strong>Line:</strong> 27</p>
                                    <p><strong>Description:</strong> Detected usage of weak crypto function. Consider using stronger alternatives.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('dd8165173e31e135fdc312aa1a401172ba777cbea0231ba081dc49bf3c21e95f')">
                                    <div class="issue-number">15</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> Use of weak hash
                                        <br>
                                        <strong>文件位置：</strong> login.php:27
                                    </div>
                                </div>
                                <div class="issue-detail" id="dd8165173e31e135fdc312aa1a401172ba777cbea0231ba081dc49bf3c21e95f">
                                    <h4>Use of weak hash - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>File:</strong> login.php</p>
                                    <p><strong>Line:</strong> 27</p>
                                    <p><strong>Description:</strong> Detected usage of weak crypto function. Consider using stronger alternatives.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('63fc2f56676c013c595a866f2c23195676ee5acb88313ec61781fd9156b55498')">
                                    <div class="issue-number">16</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> Use of weak hash
                                        <br>
                                        <strong>文件位置：</strong> vulnerabilities/csrf/source/impossible.php:29
                                    </div>
                                </div>
                                <div class="issue-detail" id="63fc2f56676c013c595a866f2c23195676ee5acb88313ec61781fd9156b55498">
                                    <h4>Use of weak hash - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>File:</strong> vulnerabilities/csrf/source/impossible.php</p>
                                    <p><strong>Line:</strong> 29</p>
                                    <p><strong>Description:</strong> Detected usage of weak crypto function. Consider using stronger alternatives.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('0ca4e9f7edeccb2d0d9f6a4b8e86be018540a57d2ef1afa76117e665b973918f')">
                                    <div class="issue-number">17</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> Use of weak hash
                                        <br>
                                        <strong>文件位置：</strong> vulnerabilities/csrf/source/high.php:39
                                    </div>
                                </div>
                                <div class="issue-detail" id="0ca4e9f7edeccb2d0d9f6a4b8e86be018540a57d2ef1afa76117e665b973918f">
                                    <h4>Use of weak hash - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>File:</strong> vulnerabilities/csrf/source/high.php</p>
                                    <p><strong>Line:</strong> 39</p>
                                    <p><strong>Description:</strong> Detected usage of weak crypto function. Consider using stronger alternatives.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('b202e17a77c6210f8be75d3ffeda5330ff27619b92cf0de75bcb761dfb218ef0')">
                                    <div class="issue-number">18</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> Use of weak hash
                                        <br>
                                        <strong>文件位置：</strong> vulnerabilities/captcha/source/low.php:57
                                    </div>
                                </div>
                                <div class="issue-detail" id="b202e17a77c6210f8be75d3ffeda5330ff27619b92cf0de75bcb761dfb218ef0">
                                    <h4>Use of weak hash - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>File:</strong> vulnerabilities/captcha/source/low.php</p>
                                    <p><strong>Line:</strong> 57</p>
                                    <p><strong>Description:</strong> Detected usage of weak crypto function. Consider using stronger alternatives.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('11ec112ce4104b87af62e3f76b6ad217c6cb39196be8267afdcb17882018e5a6')">
                                    <div class="issue-number">19</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> Use of weak hash
                                        <br>
                                        <strong>文件位置：</strong> dvwa/includes/dvwaPage.inc.php:639
                                    </div>
                                </div>
                                <div class="issue-detail" id="11ec112ce4104b87af62e3f76b6ad217c6cb39196be8267afdcb17882018e5a6">
                                    <h4>Use of weak hash - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>File:</strong> dvwa/includes/dvwaPage.inc.php</p>
                                    <p><strong>Line:</strong> 639</p>
                                    <p><strong>Description:</strong> Detected usage of weak crypto function. Consider using stronger alternatives.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('9288c6ca386f18b69382ad1219b1fbc9ce00d823ff1c5b06687c8ef34d66dcc2')">
                                    <div class="issue-number">20</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> Use of weak hash
                                        <br>
                                        <strong>文件位置：</strong> vulnerabilities/captcha/source/medium.php:65
                                    </div>
                                </div>
                                <div class="issue-detail" id="9288c6ca386f18b69382ad1219b1fbc9ce00d823ff1c5b06687c8ef34d66dcc2">
                                    <h4>Use of weak hash - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>File:</strong> vulnerabilities/captcha/source/medium.php</p>
                                    <p><strong>Line:</strong> 65</p>
                                    <p><strong>Description:</strong> Detected usage of weak crypto function. Consider using stronger alternatives.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('ee4770e810ef53458f747983fa04c7ae8d9e471a301699f6485d69577f76e2cd')">
                                    <div class="issue-number">21</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> Use of weak hash
                                        <br>
                                        <strong>文件位置：</strong> vulnerabilities/weak_id/source/impossible.php:6
                                    </div>
                                </div>
                                <div class="issue-detail" id="ee4770e810ef53458f747983fa04c7ae8d9e471a301699f6485d69577f76e2cd">
                                    <h4>Use of weak hash - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>File:</strong> vulnerabilities/weak_id/source/impossible.php</p>
                                    <p><strong>Line:</strong> 6</p>
                                    <p><strong>Description:</strong> Detected usage of weak crypto function. Consider using stronger alternatives.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('95849e39d214be4a821208d2ecbac5eef1613e6a799f18514217aae5368533fc')">
                                    <div class="issue-number">22</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> Use of weak hash
                                        <br>
                                        <strong>文件位置：</strong> vulnerabilities/brute/source/low.php:9
                                    </div>
                                </div>
                                <div class="issue-detail" id="95849e39d214be4a821208d2ecbac5eef1613e6a799f18514217aae5368533fc">
                                    <h4>Use of weak hash - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>File:</strong> vulnerabilities/brute/source/low.php</p>
                                    <p><strong>Line:</strong> 9</p>
                                    <p><strong>Description:</strong> Detected usage of weak crypto function. Consider using stronger alternatives.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('f7b7d0828f226f0fbd8cc6a77a212a7918316c95cd9eb507bf5f324f3a783c27')">
                                    <div class="issue-number">23</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> Exposure of sensitive system information to an unauthorized control sphere
                                        <br>
                                        <strong>文件位置：</strong> phpinfo.php:8
                                    </div>
                                </div>
                                <div class="issue-detail" id="f7b7d0828f226f0fbd8cc6a77a212a7918316c95cd9eb507bf5f324f3a783c27">
                                    <h4>Exposure of sensitive system information to an unauthorized control sphere - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>File:</strong> phpinfo.php</p>
                                    <p><strong>Line:</strong> 8</p>
                                    <p><strong>Description:</strong> The 'phpinfo' function may reveal sensitive information about your environment.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('91a9f1ecc635c8b72893550a06105d350941b1208c8dc6b23112ed42333d0cb2')">
                                    <div class="issue-number">24</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> Regular expression with non-literal value
                                        <br>
                                        <strong>文件位置：</strong> vulnerabilities/javascript/source/high.js:1
                                    </div>
                                </div>
                                <div class="issue-detail" id="91a9f1ecc635c8b72893550a06105d350941b1208c8dc6b23112ed42333d0cb2">
                                    <h4>Regular expression with non-literal value - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>File:</strong> vulnerabilities/javascript/source/high.js</p>
                                    <p><strong>Line:</strong> 1</p>
                                    <p><strong>Description:</strong> The `RegExp` constructor was called with a non-literal value. If an adversary were able to
supply a malicious regex, they could cause a Regular Expression Denial of Service (ReDoS)
against the application. In Node applications, this could cause the entire application to no
longer be responsive to other users' requests.

To remediate this issue, never allow user-supplied regular expressions. Instead, the regular 
expression should be  hardcoded. If this is not possible, consider using an alternative regular
expression engine such as [node-re2](https://www.npmjs.com/package/re2). RE2 is a safe alternative 
that does not support backtracking, which is what leads to ReDoS.

Example using re2 which does not support backtracking (Note: it is still recommended to
never use user-supplied input):
```
// Import the re2 module
const RE2 = require('re2');

function match(userSuppliedRegex, userInput) {
    // Create a RE2 object with the user supplied regex, this is relatively safe
    // due to RE2 not supporting backtracking which can be abused to cause long running
    // queries
    var re = new RE2(userSuppliedRegex);
    // Execute the regular expression against some userInput
    var result = re.exec(userInput);
    // Work with the result
}
```

For more information on Regular Expression DoS see:
- https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS
</p>
                                </div>
                            </li>
                        
                    </ul>
                
            
                
            

            <!-- 依赖项漏洞汇总 -->
            <h2>依赖项漏洞汇总：</h2>
            <table class="summary-table">
                <thead>
                    <tr>
                        <th>严重级别</th>
                        <th>漏洞数量</th>
                    </tr>
                </thead>
                <tbody>
                    
                    <tr>
                        <td>Critical</td>
                        <td>6</td>
                    </tr>
                    
                    <tr>
                        <td>High</td>
                        <td>102</td>
                    </tr>
                    
                    <tr>
                        <td>Medium</td>
                        <td>449</td>
                    </tr>
                    
                    <tr>
                        <td>Low</td>
                        <td>558</td>
                    </tr>
                    
                </tbody>
            </table>

            <h2>依赖项漏洞信息：</h2>
            
                
                    <h3>Critical 风险漏洞（共6个）：</h3>
                    <ul>
                        
                            <li>
                                <div class="issue-summary severity-critical"
                                     onclick="toggleDetail('ec3a3572949b7fb7753905512694ad457c4fd3b9')">
                                    <div class="issue-number">1</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="ec3a3572949b7fb7753905512694ad457c4fd3b9">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Critical</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Increasing the resolution of video frames, while performing a multi-threaded encode, can result in a heap overflow in av1_loop_restoration_dealloc().

</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-critical"
                                     onclick="toggleDetail('f38401bac90635b9e045c9c9adf2c97d6ddf5b82')">
                                    <div class="issue-number">2</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="f38401bac90635b9e045c9c9adf2c97d6ddf5b82">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Critical</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Due to a failure in validating the number of scanline samples of a OpenEXR file containing deep scanline data, Academy Software Foundation OpenEX image parsing library version 3.2.1 and prior is susceptible to a heap-based buffer overflow vulnerability. This issue was resolved as of versions v3.2.2 and v3.1.12 of the affected library.
</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-critical"
                                     onclick="toggleDetail('35b9c85cb09d3f98372768a13d9c9baf34893532')">
                                    <div class="issue-number">3</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="35b9c85cb09d3f98372768a13d9c9baf34893532">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Critical</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Due to a failure in validating the number of scanline samples of a OpenEXR file containing deep scanline data, Academy Software Foundation OpenEX image parsing library version 3.2.1 and prior is susceptible to a heap-based buffer overflow vulnerability. This issue was resolved as of versions v3.2.2 and v3.1.12 of the affected library.
</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-critical"
                                     onclick="toggleDetail('638b6d51519d42a06000297dc484112cfe3bd798')">
                                    <div class="issue-number">4</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="638b6d51519d42a06000297dc484112cfe3bd798">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Critical</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> url.c in GNU Wget through 1.24.5 mishandles semicolons in the userinfo subcomponent of a URI, and thus there may be insecure behavior in which data that was supposed to be in the userinfo subcomponent is misinterpreted to be part of the host subcomponent.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-critical"
                                     onclick="toggleDetail('ec3474e06de26debbf00a6c3e2f6d2870dfb9ffe')">
                                    <div class="issue-number">5</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="ec3474e06de26debbf00a6c3e2f6d2870dfb9ffe">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Critical</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> MiniZip in zlib through 1.3 has an integer overflow and resultant heap-based buffer overflow in zipOpenNewFileInZip4_64 via a long filename, comment, or extra field. NOTE: MiniZip is not a supported part of the zlib product. NOTE: pyminizip through 0.2.6 is also vulnerable because it bundles an affected zlib version, and exposes the applicable MiniZip code through its compress API.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-critical"
                                     onclick="toggleDetail('6678aac6d9a4efa56fbacf512a90c7d51cef11c1')">
                                    <div class="issue-number">6</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="6678aac6d9a4efa56fbacf512a90c7d51cef11c1">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Critical</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> MiniZip in zlib through 1.3 has an integer overflow and resultant heap-based buffer overflow in zipOpenNewFileInZip4_64 via a long filename, comment, or extra field. NOTE: MiniZip is not a supported part of the zlib product. NOTE: pyminizip through 0.2.6 is also vulnerable because it bundles an affected zlib version, and exposes the applicable MiniZip code through its compress API.</p>
                                </div>
                            </li>
                        
                    </ul>
                
            
                
                    <h3>High 风险漏洞（共102个）：</h3>
                    <ul>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('c449993187d9fd767e3d2b9491c2326d424ae262')">
                                    <div class="issue-number">1</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="c449993187d9fd767e3d2b9491c2326d424ae262">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Kerberos 5 (aka krb5) 1.21.2 contains a memory leak vulnerability in /krb5/src/kdc/ndr.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('59158b9eec3dca38e1573410fd193e62f4c0bc73')">
                                    <div class="issue-number">2</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="59158b9eec3dca38e1573410fd193e62f4c0bc73">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> AOMedia v3.0.0 to v3.5.0 was discovered to contain an invalid read memory access via the component assign_frame_buffer_p in av1/common/av1_common_int.h.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('19cd3cf1f031540b9a0071728bad46c14c4c82a1')">
                                    <div class="issue-number">3</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="19cd3cf1f031540b9a0071728bad46c14c4c82a1">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> BlueZ Audio Profile AVRCP Stack-based Buffer Overflow Remote Code Execution Vulnerability. This vulnerability allows network-adjacent attackers to execute arbitrary code via Bluetooth on affected installations of BlueZ. User interaction is required to exploit this vulnerability in that the target must connect to a malicious device.

The specific flaw exists within the handling of the AVRCP protocol. The issue results from the lack of proper validation of the length of user-supplied data prior to copying it to a fixed-length stack-based buffer. An attacker can leverage this vulnerability to execute code in the context of root. Was ZDI-CAN-19909.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('6fb623b3de5b65125571f9a93badd12f5402ca1e')">
                                    <div class="issue-number">4</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="6fb623b3de5b65125571f9a93badd12f5402ca1e">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> BlueZ Phone Book Access Profile Heap-based Buffer Overflow Remote Code Execution Vulnerability. This vulnerability allows network-adjacent attackers to execute arbitrary code on affected installations of BlueZ. User interaction is required to exploit this vulnerability in that the target must connect to a malicious Bluetooth device.

The specific flaw exists within the handling of the Phone Book Access profile. The issue results from the lack of proper validation of the length of user-supplied data prior to copying it to a fixed-length heap-based buffer. An attacker can leverage this vulnerability to execute code in the context of root. Was ZDI-CAN-20939.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('2b075e87efdbe4a3cad3a0164415775f2ae117dc')">
                                    <div class="issue-number">5</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="2b075e87efdbe4a3cad3a0164415775f2ae117dc">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> BlueZ Audio Profile AVRCP Stack-based Buffer Overflow Remote Code Execution Vulnerability. This vulnerability allows network-adjacent attackers to execute arbitrary code via Bluetooth on affected installations of BlueZ. User interaction is required to exploit this vulnerability in that the target must connect to a malicious device.

The specific flaw exists within the handling of the AVRCP protocol. The issue results from the lack of proper validation of the length of user-supplied data prior to copying it to a fixed-length stack-based buffer. An attacker can leverage this vulnerability to execute code in the context of root. Was ZDI-CAN-19909.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('52c6a6e41eb45a07aa73f4478816cbd624b2b476')">
                                    <div class="issue-number">6</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="52c6a6e41eb45a07aa73f4478816cbd624b2b476">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> BlueZ Phone Book Access Profile Heap-based Buffer Overflow Remote Code Execution Vulnerability. This vulnerability allows network-adjacent attackers to execute arbitrary code on affected installations of BlueZ. User interaction is required to exploit this vulnerability in that the target must connect to a malicious Bluetooth device.

The specific flaw exists within the handling of the Phone Book Access profile. The issue results from the lack of proper validation of the length of user-supplied data prior to copying it to a fixed-length heap-based buffer. An attacker can leverage this vulnerability to execute code in the context of root. Was ZDI-CAN-20939.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('5b6caa85d7ba79eb5ec18eebd3c6bbcfe515cb8e')">
                                    <div class="issue-number">7</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="5b6caa85d7ba79eb5ec18eebd3c6bbcfe515cb8e">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> libexpat through 2.5.0 allows a denial of service (resource consumption) because many full reparsings are required in the case of a large token for which multiple buffer fills are needed.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('a0a01a2c5b9e4fb64158848f4fc0fe3c9e94f984')">
                                    <div class="issue-number">8</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="a0a01a2c5b9e4fb64158848f4fc0fe3c9e94f984">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> libexpat through 2.5.0 allows a denial of service (resource consumption) because many full reparsings are required in the case of a large token for which multiple buffer fills are needed.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('a95f086854a69e6267f098d1a8392140b1fb86aa')">
                                    <div class="issue-number">9</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="a95f086854a69e6267f098d1a8392140b1fb86aa">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> gio/gsocks4aproxy.c in GNOME GLib before 2.82.1 has an off-by-one error and resultant buffer overflow because SOCKS4_CONN_MSG_LEN is not sufficient for a trailing '\0' character.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('12924598216d5b9c8da8a654ee5f6ed8dae0aaf7')">
                                    <div class="issue-number">10</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="12924598216d5b9c8da8a654ee5f6ed8dae0aaf7">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> gio/gsocks4aproxy.c in GNOME GLib before 2.82.1 has an off-by-one error and resultant buffer overflow because SOCKS4_CONN_MSG_LEN is not sufficient for a trailing '\0' character.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('fcdd17376b899fb3117e3990a9b5edfdd41f6920')">
                                    <div class="issue-number">11</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="fcdd17376b899fb3117e3990a9b5edfdd41f6920">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> gio/gsocks4aproxy.c in GNOME GLib before 2.82.1 has an off-by-one error and resultant buffer overflow because SOCKS4_CONN_MSG_LEN is not sufficient for a trailing '\0' character.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('d2d58147b2b9d66154bdd2e1ae9e0fce63e07f6d')">
                                    <div class="issue-number">12</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="d2d58147b2b9d66154bdd2e1ae9e0fce63e07f6d">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> gio/gsocks4aproxy.c in GNOME GLib before 2.82.1 has an off-by-one error and resultant buffer overflow because SOCKS4_CONN_MSG_LEN is not sufficient for a trailing '\0' character.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('aa10c3810793aab52479e4f4ea712390874b9979')">
                                    <div class="issue-number">13</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="aa10c3810793aab52479e4f4ea712390874b9979">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> gio/gsocks4aproxy.c in GNOME GLib before 2.82.1 has an off-by-one error and resultant buffer overflow because SOCKS4_CONN_MSG_LEN is not sufficient for a trailing '\0' character.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('0edf676ed3aba4e8cfe2dfe8270e78e81532af7e')">
                                    <div class="issue-number">14</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="0edf676ed3aba4e8cfe2dfe8270e78e81532af7e">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Kerberos 5 (aka krb5) 1.21.2 contains a memory leak vulnerability in /krb5/src/kdc/ndr.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('55af82a254263f2d8ad37f859df40844c3215a96')">
                                    <div class="issue-number">15</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="55af82a254263f2d8ad37f859df40844c3215a96">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Kerberos 5 (aka krb5) 1.21.2 contains a memory leak vulnerability in /krb5/src/kdc/ndr.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('b6f03b3a15a3c1e6fd9646e3d252205fdb41b7b7')">
                                    <div class="issue-number">16</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="b6f03b3a15a3c1e6fd9646e3d252205fdb41b7b7">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> hb-ot-layout-gsubgpos.hh in HarfBuzz through 6.0.0 allows attackers to trigger O(n^2) growth via consecutive marks during the process of looking back for base glyphs when attaching marks.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('c980e4581dd06f82b60adc744cb650af0ee1d21d')">
                                    <div class="issue-number">17</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="c980e4581dd06f82b60adc744cb650af0ee1d21d">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Kerberos 5 (aka krb5) 1.21.2 contains a memory leak vulnerability in /krb5/src/kdc/ndr.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('9fbab46ff5ddbf7770eb3b7e918fc096f45f8a3e')">
                                    <div class="issue-number">18</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="9fbab46ff5ddbf7770eb3b7e918fc096f45f8a3e">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Kerberos 5 (aka krb5) 1.21.2 contains a memory leak vulnerability in /krb5/src/kdc/ndr.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('101fa9d4688c4ae793a3004896538a60039a43b2')">
                                    <div class="issue-number">19</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="101fa9d4688c4ae793a3004896538a60039a43b2">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Kerberos 5 (aka krb5) 1.21.2 contains a memory leak vulnerability in /krb5/src/kdc/ndr.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('24e63ece61f0825d0d4448fa4b5fa1b4f99dedad')">
                                    <div class="issue-number">20</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="24e63ece61f0825d0d4448fa4b5fa1b4f99dedad">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Kerberos 5 (aka krb5) 1.21.2 contains a memory leak vulnerability in /krb5/src/kdc/ndr.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('a7cea373effbff9900b5b53dcd3449320b45232d')">
                                    <div class="issue-number">21</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="a7cea373effbff9900b5b53dcd3449320b45232d">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Kerberos 5 (aka krb5) 1.21.2 contains a memory leak vulnerability in /krb5/src/kdc/ndr.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('c6ddb72937232b2ac0554ab5bffb0d8f3886c838')">
                                    <div class="issue-number">22</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="c6ddb72937232b2ac0554ab5bffb0d8f3886c838">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Kerberos 5 (aka krb5) 1.21.2 contains a memory leak vulnerability in /krb5/src/kdc/ndr.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('77378b38140b6e750e93d113543853db3e9159ef')">
                                    <div class="issue-number">23</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="77378b38140b6e750e93d113543853db3e9159ef">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Kerberos 5 (aka krb5) 1.21.2 contains a memory leak vulnerability in /krb5/src/kdc/ndr.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('3d260d4358618a66cc8ebb8838f1c2ceab7eeda7')">
                                    <div class="issue-number">24</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="3d260d4358618a66cc8ebb8838f1c2ceab7eeda7">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A vulnerability was found in openldap. This security flaw causes a null pointer dereference in ber_memalloc_x() function.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('2379a965931c8d317a3c0514c944f92f1a1b11a7')">
                                    <div class="issue-number">25</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="2379a965931c8d317a3c0514c944f92f1a1b11a7">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A heap-based buffer overflow was found in openjpeg in color.c:379:42 in sycc420_to_rgb when decompressing a crafted .j2k file. An attacker could use this to execute arbitrary code with the permissions of the application compiled against openjpeg.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('b5a3ee3deaaea76e659e1b3d53c6b2e28e2add1f')">
                                    <div class="issue-number">26</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="b5a3ee3deaaea76e659e1b3d53c6b2e28e2add1f">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A heap-based buffer overflow was found in openjpeg in color.c:379:42 in sycc420_to_rgb when decompressing a crafted .j2k file. An attacker could use this to execute arbitrary code with the permissions of the application compiled against openjpeg.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('301a4f8e2c381d47f7cda2bea6eaaac36e0dbc6e')">
                                    <div class="issue-number">27</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="301a4f8e2c381d47f7cda2bea6eaaac36e0dbc6e">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A flaw was found in pam_access, where certain rules in its configuration file are mistakenly treated as hostnames. This vulnerability allows attackers to trick the system by pretending to be a trusted hostname, gaining unauthorized access. This issue poses a risk for systems that rely on this feature to control who can access certain services or terminals.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('387ad8087e7dc628435d591672388ca39ce3630a')">
                                    <div class="issue-number">28</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="387ad8087e7dc628435d591672388ca39ce3630a">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A flaw was found in pam_access, where certain rules in its configuration file are mistakenly treated as hostnames. This vulnerability allows attackers to trick the system by pretending to be a trusted hostname, gaining unauthorized access. This issue poses a risk for systems that rely on this feature to control who can access certain services or terminals.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('bf41ed3bfcc5c9d3c3943bab39f3b120ee5170ce')">
                                    <div class="issue-number">29</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="bf41ed3bfcc5c9d3c3943bab39f3b120ee5170ce">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A flaw was found in pam_access, where certain rules in its configuration file are mistakenly treated as hostnames. This vulnerability allows attackers to trick the system by pretending to be a trusted hostname, gaining unauthorized access. This issue poses a risk for systems that rely on this feature to control who can access certain services or terminals.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('4678cf0fb2890e898dd54e4e19937d2195aef307')">
                                    <div class="issue-number">30</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="4678cf0fb2890e898dd54e4e19937d2195aef307">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A flaw was found in pam_access, where certain rules in its configuration file are mistakenly treated as hostnames. This vulnerability allows attackers to trick the system by pretending to be a trusted hostname, gaining unauthorized access. This issue poses a risk for systems that rely on this feature to control who can access certain services or terminals.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('40c306a785bfa395d709be737ab63d3b411dc983')">
                                    <div class="issue-number">31</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="40c306a785bfa395d709be737ab63d3b411dc983">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> CPAN.pm before 2.35 does not verify TLS certificates when downloading distributions over HTTPS.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('7c083ab45d831357b597afc338c4d883793a8d20')">
                                    <div class="issue-number">32</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="7c083ab45d831357b597afc338c4d883793a8d20">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> There is a LOW severity vulnerability affecting CPython, specifically the
'http.cookies' standard library module.


When parsing cookies that contained backslashes for quoted characters in
the cookie value, the parser would use an algorithm with quadratic
complexity, resulting in excess CPU resources being used while parsing the
value.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('ec4e9161dff1e1ca519842a9c3e9f9f3d5559353')">
                                    <div class="issue-number">33</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="ec4e9161dff1e1ca519842a9c3e9f9f3d5559353">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> There is a LOW severity vulnerability affecting CPython, specifically the
'http.cookies' standard library module.


When parsing cookies that contained backslashes for quoted characters in
the cookie value, the parser would use an algorithm with quadratic
complexity, resulting in excess CPU resources being used while parsing the
value.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('842d75247c7af1871a5d8883deb4ade743b63a8d')">
                                    <div class="issue-number">34</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="842d75247c7af1871a5d8883deb4ade743b63a8d">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> There is a LOW severity vulnerability affecting CPython, specifically the
'http.cookies' standard library module.


When parsing cookies that contained backslashes for quoted characters in
the cookie value, the parser would use an algorithm with quadratic
complexity, resulting in excess CPU resources being used while parsing the
value.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('c7b511f61b021e9fbe51770558b9f2f9f4e4fa43')">
                                    <div class="issue-number">35</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="c7b511f61b021e9fbe51770558b9f2f9f4e4fa43">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An out-of-memory flaw was found in libtiff that could be triggered by passing a crafted tiff file to the TIFFRasterScanlineSize64() API. This flaw allows a remote attacker to cause a denial of service via a crafted input with a size smaller than 379 KB.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('266657f6fcbab37f10fa5ef7800e91267a9ea002')">
                                    <div class="issue-number">36</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="266657f6fcbab37f10fa5ef7800e91267a9ea002">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A segment fault (SEGV) flaw was found in libtiff that could be triggered by passing a crafted tiff file to the TIFFReadRGBATileExt() API. This flaw allows a remote attacker to cause a heap-buffer overflow, leading to a denial of service.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('9637da336d7e5edd1b493c38c781d4b2175b400d')">
                                    <div class="issue-number">37</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="9637da336d7e5edd1b493c38c781d4b2175b400d">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A null pointer dereference flaw was found in Libtiff via `tif_dirinfo.c`. This issue may allow an attacker to trigger memory allocation failures through certain means, such as restricting the heap space size or injecting faults, causing a segmentation fault. This can cause an application crash, eventually leading to a denial of service.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('77c152e4da775824e9bf537529598d8d355aeae3')">
                                    <div class="issue-number">38</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="77c152e4da775824e9bf537529598d8d355aeae3">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An out-of-memory flaw was found in libtiff that could be triggered by passing a crafted tiff file to the TIFFRasterScanlineSize64() API. This flaw allows a remote attacker to cause a denial of service via a crafted input with a size smaller than 379 KB.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('3b5eb67b1924ba369cab252d76d980dd1fe2d3d0')">
                                    <div class="issue-number">39</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="3b5eb67b1924ba369cab252d76d980dd1fe2d3d0">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A segment fault (SEGV) flaw was found in libtiff that could be triggered by passing a crafted tiff file to the TIFFReadRGBATileExt() API. This flaw allows a remote attacker to cause a heap-buffer overflow, leading to a denial of service.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('a4a471585efd0018debd4a958c9bf64076f9d399')">
                                    <div class="issue-number">40</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="a4a471585efd0018debd4a958c9bf64076f9d399">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A null pointer dereference flaw was found in Libtiff via `tif_dirinfo.c`. This issue may allow an attacker to trigger memory allocation failures through certain means, such as restricting the heap space size or injecting faults, causing a segmentation fault. This can cause an application crash, eventually leading to a denial of service.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('602925b2ef34cae43f2c4e3977cb5a84c1ec4bf5')">
                                    <div class="issue-number">41</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="602925b2ef34cae43f2c4e3977cb5a84c1ec4bf5">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An out-of-memory flaw was found in libtiff that could be triggered by passing a crafted tiff file to the TIFFRasterScanlineSize64() API. This flaw allows a remote attacker to cause a denial of service via a crafted input with a size smaller than 379 KB.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('18f4585d54e58372a7c7d1ed3198243f919aa712')">
                                    <div class="issue-number">42</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="18f4585d54e58372a7c7d1ed3198243f919aa712">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A segment fault (SEGV) flaw was found in libtiff that could be triggered by passing a crafted tiff file to the TIFFReadRGBATileExt() API. This flaw allows a remote attacker to cause a heap-buffer overflow, leading to a denial of service.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('0e4d28f2afffda59d3a31372b8735f18e69fa495')">
                                    <div class="issue-number">43</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="0e4d28f2afffda59d3a31372b8735f18e69fa495">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A null pointer dereference flaw was found in Libtiff via `tif_dirinfo.c`. This issue may allow an attacker to trigger memory allocation failures through certain means, such as restricting the heap space size or injecting faults, causing a segmentation fault. This can cause an application crash, eventually leading to a denial of service.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('24d9df3c6187a2d5be57903f47b15c09f5b576aa')">
                                    <div class="issue-number">44</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="24d9df3c6187a2d5be57903f47b15c09f5b576aa">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in libxml2 before 2.11.7 and 2.12.x before 2.12.5. When using the XML Reader interface with DTD validation and XInclude expansion enabled, processing crafted XML documents can lead to an xmlValidatePopElement use-after-free.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('731f6ce0e03abe80a850ea37467d1a7477072cbd')">
                                    <div class="issue-number">45</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="731f6ce0e03abe80a850ea37467d1a7477072cbd">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in libxml2 before 2.11.7 and 2.12.x before 2.12.5. When using the XML Reader interface with DTD validation and XInclude expansion enabled, processing crafted XML documents can lead to an xmlValidatePopElement use-after-free.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('50f796e530d26c30a56d81242a412d193596d951')">
                                    <div class="issue-number">46</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="50f796e530d26c30a56d81242a412d193596d951">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The Direct Rendering Manager (DRM) subsystem in the Linux kernel through 4.x mishandles requests for Graphics Execution Manager (GEM) objects, which allows context-dependent attackers to cause a denial of service (memory consumption) via an application that processes graphics data, as demonstrated by JavaScript code that creates many CANVAS elements for rendering by Chrome or Firefox.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('f33cbf3acf554e3a969ee8e860e5613a97fe6454')">
                                    <div class="issue-number">47</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="f33cbf3acf554e3a969ee8e860e5613a97fe6454">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel 5.0.21, mounting a crafted f2fs filesystem image can lead to slab-out-of-bounds read access in f2fs_build_segment_manager in fs/f2fs/segment.c, related to init_min_max_mtime in fs/f2fs/segment.c (because the second argument to get_seg_entry is not validated).</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('0a09742dfc82546d662140ec0aacf9aab1d29811')">
                                    <div class="issue-number">48</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="0a09742dfc82546d662140ec0aacf9aab1d29811">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel 5.0.21, mounting a crafted f2fs filesystem image can cause __remove_dirty_segment slab-out-of-bounds write access because an array is bounded by the number of dirty types (8) but the array index can exceed this.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('83f5a60b1a3cf0f5f1a95bc9eb42cb945d8669b0')">
                                    <div class="issue-number">49</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="83f5a60b1a3cf0f5f1a95bc9eb42cb945d8669b0">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An unauthorized access to the execution of the setuid file with capabilities flaw in the Linux kernel OverlayFS subsystem was found in the way user copying a capable file from a nosuid mount into another mount. A local user could use this flaw to escalate their privileges on the system.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('f5bddf1cb5a88b20a77c15499b33e714d89458b2')">
                                    <div class="issue-number">50</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="f5bddf1cb5a88b20a77c15499b33e714d89458b2">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A flaw was found in the way the dumpable flag setting was handled when certain SUID binaries executed its descendants. The prerequisite is a SUID binary that sets real UID equal to effective UID, and real GID equal to effective GID. The descendant will then have a dumpable value set to 1. As a result, if the descendant process crashes and core_pattern is set to a relative value, its core dump is stored in the current directory with uid:gid permissions. An unprivileged local user with eligible root SUID binary could use this flaw to place core dumps into root-owned directories, potentially resulting in escalation of privileges.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('91939477e6124695722fe6b96fc9d8fa62dec377')">
                                    <div class="issue-number">51</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="91939477e6124695722fe6b96fc9d8fa62dec377">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

bpf: Fix accesses to uninit stack slots

Privileged programs are supposed to be able to read uninitialized stack
memory (ever since 6715df8d5) but, before this patch, these accesses
were permitted inconsistently. In particular, accesses were permitted
above state->allocated_stack, but not below it. In other words, if the
stack was already "large enough", the access was permitted, but
otherwise the access was rejected instead of being allowed to "grow the
stack". This undesired rejection was happening in two places:
- in check_stack_slot_within_bounds()
- in check_stack_range_initialized()
This patch arranges for these accesses to be permitted. A bunch of tests
that were relying on the old rejection had to change; all of them were
changed to add also run unprivileged, in which case the old behavior
persists. One tests couldn't be updated - global_func16 - because it
can't run unprivileged for other reasons.

This patch also fixes the tracking of the stack size for variable-offset
reads. This second fix is bundled in the same commit as the first one
because they're inter-related. Before this patch, writes to the stack
using registers containing a variable offset (as opposed to registers
with fixed, known values) were not properly contributing to the
function's needed stack size. As a result, it was possible for a program
to verify, but then to attempt to read out-of-bounds data at runtime
because a too small stack had been allocated for it.

Each function tracks the size of the stack it needs in
bpf_subprog_info.stack_depth, which is maintained by
update_stack_depth(). For regular memory accesses, check_mem_access()
was calling update_state_depth() but it was passing in only the fixed
part of the offset register, ignoring the variable offset. This was
incorrect; the minimum possible value of that register should be used
instead.

This tracking is now fixed by centralizing the tracking of stack size in
grow_stack_state(), and by lifting the calls to grow_stack_state() to
check_stack_access_within_bounds() as suggested by Andrii. The code is
now simpler and more convincingly tracks the correct maximum stack size.
check_stack_range_initialized() can now rely on enough stack having been
allocated for the access; this helps with the fix for the first issue.

A few tests were changed to also check the stack depth computation. The
one that fails without this patch is verifier_var_off:stack_write_priv_vs_unpriv.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('f47bdedffc22311fbf7807a3788acedf6c10b607')">
                                    <div class="issue-number">52</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="f47bdedffc22311fbf7807a3788acedf6c10b607">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

ocfs2: Avoid touching renamed directory if parent does not change

The VFS will not be locking moved directory if its parent does not
change. Change ocfs2 rename code to avoid touching renamed directory if
its parent does not change as without locking that can corrupt the
filesystem.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('c9c732d1d2444f19f88f8d71bfb13a2c05c4fb21')">
                                    <div class="issue-number">53</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="c9c732d1d2444f19f88f8d71bfb13a2c05c4fb21">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

smb: client: fix use-after-free in smb2_query_info_compound()

The following UAF was triggered when running fstests generic/072 with
KASAN enabled against Windows Server 2022 and mount options
'multichannel,max_channels=2,vers=3.1.1,mfsymlinks,noperm'

  BUG: KASAN: slab-use-after-free in smb2_query_info_compound+0x423/0x6d0 [cifs]
  Read of size 8 at addr ffff888014941048 by task xfs_io/27534

  CPU: 0 PID: 27534 Comm: xfs_io Not tainted 6.6.0-rc7 #1
  Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS
  rel-1.16.2-3-gd478f380-rebuilt.opensuse.org 04/01/2014
  Call Trace:
   dump_stack_lvl+0x4a/0x80
   print_report+0xcf/0x650
   ? srso_alias_return_thunk+0x5/0x7f
   ? srso_alias_return_thunk+0x5/0x7f
   ? __phys_addr+0x46/0x90
   kasan_report+0xda/0x110
   ? smb2_query_info_compound+0x423/0x6d0 [cifs]
   ? smb2_query_info_compound+0x423/0x6d0 [cifs]
   smb2_query_info_compound+0x423/0x6d0 [cifs]
   ? __pfx_smb2_query_info_compound+0x10/0x10 [cifs]
   ? srso_alias_return_thunk+0x5/0x7f
   ? __stack_depot_save+0x39/0x480
   ? kasan_save_stack+0x33/0x60
   ? kasan_set_track+0x25/0x30
   ? ____kasan_slab_free+0x126/0x170
   smb2_queryfs+0xc2/0x2c0 [cifs]
   ? __pfx_smb2_queryfs+0x10/0x10 [cifs]
   ? __pfx___lock_acquire+0x10/0x10
   smb311_queryfs+0x210/0x220 [cifs]
   ? __pfx_smb311_queryfs+0x10/0x10 [cifs]
   ? srso_alias_return_thunk+0x5/0x7f
   ? __lock_acquire+0x480/0x26c0
   ? lock_release+0x1ed/0x640
   ? srso_alias_return_thunk+0x5/0x7f
   ? do_raw_spin_unlock+0x9b/0x100
   cifs_statfs+0x18c/0x4b0 [cifs]
   statfs_by_dentry+0x9b/0xf0
   fd_statfs+0x4e/0xb0
   __do_sys_fstatfs+0x7f/0xe0
   ? __pfx___do_sys_fstatfs+0x10/0x10
   ? srso_alias_return_thunk+0x5/0x7f
   ? lockdep_hardirqs_on_prepare+0x136/0x200
   ? srso_alias_return_thunk+0x5/0x7f
   do_syscall_64+0x3f/0x90
   entry_SYSCALL_64_after_hwframe+0x6e/0xd8

  Allocated by task 27534:
   kasan_save_stack+0x33/0x60
   kasan_set_track+0x25/0x30
   __kasan_kmalloc+0x8f/0xa0
   open_cached_dir+0x71b/0x1240 [cifs]
   smb2_query_info_compound+0x5c3/0x6d0 [cifs]
   smb2_queryfs+0xc2/0x2c0 [cifs]
   smb311_queryfs+0x210/0x220 [cifs]
   cifs_statfs+0x18c/0x4b0 [cifs]
   statfs_by_dentry+0x9b/0xf0
   fd_statfs+0x4e/0xb0
   __do_sys_fstatfs+0x7f/0xe0
   do_syscall_64+0x3f/0x90
   entry_SYSCALL_64_after_hwframe+0x6e/0xd8

  Freed by task 27534:
   kasan_save_stack+0x33/0x60
   kasan_set_track+0x25/0x30
   kasan_save_free_info+0x2b/0x50
   ____kasan_slab_free+0x126/0x170
   slab_free_freelist_hook+0xd0/0x1e0
   __kmem_cache_free+0x9d/0x1b0
   open_cached_dir+0xff5/0x1240 [cifs]
   smb2_query_info_compound+0x5c3/0x6d0 [cifs]
   smb2_queryfs+0xc2/0x2c0 [cifs]

This is a race between open_cached_dir() and cached_dir_lease_break()
where the cache entry for the open directory handle receives a lease
break while creating it.  And before returning from open_cached_dir(),
we put the last reference of the new @cfid because of
!@cfid->has_lease.

Besides the UAF, while running xfstests a lot of missed lease breaks
have been noticed in tests that run several concurrent statfs(2) calls
on those cached fids

  CIFS: VFS: \\w22-root1.gandalf.test No task to wake, unknown frame...
  CIFS: VFS: \\w22-root1.gandalf.test Cmd: 18 Err: 0x0 Flags: 0x1...
  CIFS: VFS: \\w22-root1.gandalf.test smb buf 00000000715bfe83 len 108
  CIFS: VFS: Dump pending requests:
  CIFS: VFS: \\w22-root1.gandalf.test No task to wake, unknown frame...
  CIFS: VFS: \\w22-root1.gandalf.test Cmd: 18 Err: 0x0 Flags: 0x1...
  CIFS: VFS: \\w22-root1.gandalf.test smb buf 000000005aa7316e len 108
  ...

To fix both, in open_cached_dir() ensure that @cfid->has_lease is set
right before sending out compounded request so that any potential
lease break will be get processed by demultiplex thread while we're
still caching @cfid.  And, if open failed for some reason, re-check
@cfid->has_lease to decide whether or not put lease reference.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('e7b420910ef194e2ee54f30409b81ad78c471e74')">
                                    <div class="issue-number">54</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="e7b420910ef194e2ee54f30409b81ad78c471e74">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Use After Free vulnerability in Linux Linux kernel kernel on Linux, x86, ARM (bluetooth modules) allows Local Execution of Code. This vulnerability is associated with program files https://gitee.Com/anolis/cloud-kernel/blob/devel-5.10/net/bluetooth/af_bluetooth.C.

This issue affects Linux kernel: from v2.6.12-rc2 before v6.8-rc1.

</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('860c743e89997297663cc2f6de93ef7f7e630d80')">
                                    <div class="issue-number">55</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="860c743e89997297663cc2f6de93ef7f7e630d80">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel before 6.9, an untrusted hypervisor can inject virtual interrupt 29 (#VC) at any point in time and can trigger its handler. This affects AMD SEV-SNP and AMD SEV-ES.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('e55ca233fc5abe055b86661fb10f896ef3c53c31')">
                                    <div class="issue-number">56</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="e55ca233fc5abe055b86661fb10f896ef3c53c31">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel through 6.9, an untrusted hypervisor can inject virtual interrupts 0 and 14 at any point in time and can trigger the SIGFPE signal handler in userspace applications. This affects AMD SEV-SNP and AMD SEV-ES.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('7e317577ea2758f0d4242be67d2fdcd595ce0fb2')">
                                    <div class="issue-number">57</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="7e317577ea2758f0d4242be67d2fdcd595ce0fb2">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

net/sched: flower: Fix chain template offload

When a qdisc is deleted from a net device the stack instructs the
underlying driver to remove its flow offload callback from the
associated filter block using the 'FLOW_BLOCK_UNBIND' command. The stack
then continues to replay the removal of the filters in the block for
this driver by iterating over the chains in the block and invoking the
'reoffload' operation of the classifier being used. In turn, the
classifier in its 'reoffload' operation prepares and emits a
'FLOW_CLS_DESTROY' command for each filter.

However, the stack does not do the same for chain templates and the
underlying driver never receives a 'FLOW_CLS_TMPLT_DESTROY' command when
a qdisc is deleted. This results in a memory leak [1] which can be
reproduced using [2].

Fix by introducing a 'tmplt_reoffload' operation and have the stack
invoke it with the appropriate arguments as part of the replay.
Implement the operation in the sole classifier that supports chain
templates (flower) by emitting the 'FLOW_CLS_TMPLT_{CREATE,DESTROY}'
command based on whether a flow offload callback is being bound to a
filter block or being unbound from one.

As far as I can tell, the issue happens since cited commit which
reordered tcf_block_offload_unbind() before tcf_block_flush_all_chains()
in __tcf_block_put(). The order cannot be reversed as the filter block
is expected to be freed after flushing all the chains.

[1]
unreferenced object 0xffff888107e28800 (size 2048):
  comm "tc", pid 1079, jiffies 4294958525 (age 3074.287s)
  hex dump (first 32 bytes):
    b1 a6 7c 11 81 88 ff ff e0 5b b3 10 81 88 ff ff  ..|......[......
    01 00 00 00 00 00 00 00 e0 aa b0 84 ff ff ff ff  ................
  backtrace:
    [<ffffffff81c06a68>] __kmem_cache_alloc_node+0x1e8/0x320
    [<ffffffff81ab374e>] __kmalloc+0x4e/0x90
    [<ffffffff832aec6d>] mlxsw_sp_acl_ruleset_get+0x34d/0x7a0
    [<ffffffff832bc195>] mlxsw_sp_flower_tmplt_create+0x145/0x180
    [<ffffffff832b2e1a>] mlxsw_sp_flow_block_cb+0x1ea/0x280
    [<ffffffff83a10613>] tc_setup_cb_call+0x183/0x340
    [<ffffffff83a9f85a>] fl_tmplt_create+0x3da/0x4c0
    [<ffffffff83a22435>] tc_ctl_chain+0xa15/0x1170
    [<ffffffff838a863c>] rtnetlink_rcv_msg+0x3cc/0xed0
    [<ffffffff83ac87f0>] netlink_rcv_skb+0x170/0x440
    [<ffffffff83ac6270>] netlink_unicast+0x540/0x820
    [<ffffffff83ac6e28>] netlink_sendmsg+0x8d8/0xda0
    [<ffffffff83793def>] ____sys_sendmsg+0x30f/0xa80
    [<ffffffff8379d29a>] ___sys_sendmsg+0x13a/0x1e0
    [<ffffffff8379d50c>] __sys_sendmsg+0x11c/0x1f0
    [<ffffffff843b9ce0>] do_syscall_64+0x40/0xe0
unreferenced object 0xffff88816d2c0400 (size 1024):
  comm "tc", pid 1079, jiffies 4294958525 (age 3074.287s)
  hex dump (first 32 bytes):
    40 00 00 00 00 00 00 00 57 f6 38 be 00 00 00 00  @.......W.8.....
    10 04 2c 6d 81 88 ff ff 10 04 2c 6d 81 88 ff ff  ..,m......,m....
  backtrace:
    [<ffffffff81c06a68>] __kmem_cache_alloc_node+0x1e8/0x320
    [<ffffffff81ab36c1>] __kmalloc_node+0x51/0x90
    [<ffffffff81a8ed96>] kvmalloc_node+0xa6/0x1f0
    [<ffffffff82827d03>] bucket_table_alloc.isra.0+0x83/0x460
    [<ffffffff82828d2b>] rhashtable_init+0x43b/0x7c0
    [<ffffffff832aed48>] mlxsw_sp_acl_ruleset_get+0x428/0x7a0
    [<ffffffff832bc195>] mlxsw_sp_flower_tmplt_create+0x145/0x180
    [<ffffffff832b2e1a>] mlxsw_sp_flow_block_cb+0x1ea/0x280
    [<ffffffff83a10613>] tc_setup_cb_call+0x183/0x340
    [<ffffffff83a9f85a>] fl_tmplt_create+0x3da/0x4c0
    [<ffffffff83a22435>] tc_ctl_chain+0xa15/0x1170
    [<ffffffff838a863c>] rtnetlink_rcv_msg+0x3cc/0xed0
    [<ffffffff83ac87f0>] netlink_rcv_skb+0x170/0x440
    [<ffffffff83ac6270>] netlink_unicast+0x540/0x820
    [<ffffffff83ac6e28>] netlink_sendmsg+0x8d8/0xda0
    [<ffffffff83793def>] ____sys_sendmsg+0x30f/0xa80

[2]
 # tc qdisc add dev swp1 clsact
 # tc chain add dev swp1 ingress proto ip chain 1 flower dst_ip 0.0.0.0/32
 # tc qdisc del dev
---truncated---</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('d2871b9606ed5857a09e07342a183e55cd31a587')">
                                    <div class="issue-number">58</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="d2871b9606ed5857a09e07342a183e55cd31a587">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Fix dcn35 8k30 Underflow/Corruption Issue

[why]
odm calculation is missing for pipe split policy determination
and cause Underflow/Corruption issue.

[how]
Add the odm calculation.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('11225d2697d60e256b9c5a48f651ad3eaddf0375')">
                                    <div class="issue-number">59</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="11225d2697d60e256b9c5a48f651ad3eaddf0375">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

scsi: qla2xxx: Fix double free of the ha->vp_map pointer

Coverity scan reported potential risk of double free of the pointer
ha->vp_map.  ha->vp_map was freed in qla2x00_mem_alloc(), and again freed
in function qla2x00_mem_free(ha).

Assign NULL to vp_map and kfree take care of NULL.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('0bc5f1ab8f4814efbc2d927484fac3e5073f1d2b')">
                                    <div class="issue-number">60</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="0bc5f1ab8f4814efbc2d927484fac3e5073f1d2b">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

Bluetooth: L2CAP: Fix slab-use-after-free in l2cap_connect()

Extend a critical section to prevent chan from early freeing.
Also make the l2cap_connect() return type void. Nothing is using the
returned value but it is ugly to return a potentially freed pointer.
Making it void will help with backports because earlier kernels did use
the return value. Now the compile will break for kernels where this
patch is not a complete fix.

Call stack summary:

[use]
l2cap_bredr_sig_cmd
  l2cap_connect
  ┌ mutex_lock(&conn->chan_lock);
  │ chan = pchan->ops->new_connection(pchan); <- alloc chan
  │ __l2cap_chan_add(conn, chan);
  │   l2cap_chan_hold(chan);
  │   list_add(&chan->list, &conn->chan_l);   ... (1)
  └ mutex_unlock(&conn->chan_lock);
    chan->conf_state              ... (4) <- use after free

[free]
l2cap_conn_del
┌ mutex_lock(&conn->chan_lock);
│ foreach chan in conn->chan_l:            ... (2)
│   l2cap_chan_put(chan);
│     l2cap_chan_destroy
│       kfree(chan)               ... (3) <- chan freed
└ mutex_unlock(&conn->chan_lock);

==================================================================
BUG: KASAN: slab-use-after-free in instrument_atomic_read
include/linux/instrumented.h:68 [inline]
BUG: KASAN: slab-use-after-free in _test_bit
include/asm-generic/bitops/instrumented-non-atomic.h:141 [inline]
BUG: KASAN: slab-use-after-free in l2cap_connect+0xa67/0x11a0
net/bluetooth/l2cap_core.c:4260
Read of size 8 at addr ffff88810bf040a0 by task kworker/u3:1/311</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('98b96d91a1d869275d735000e5ca288f4f25d330')">
                                    <div class="issue-number">61</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="98b96d91a1d869275d735000e5ca288f4f25d330">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

gfs2: Fix potential glock use-after-free on unmount

When a DLM lockspace is released and there ares still locks in that
lockspace, DLM will unlock those locks automatically.  Commit
fb6791d100d1b started exploiting this behavior to speed up filesystem
unmount: gfs2 would simply free glocks it didn't want to unlock and then
release the lockspace.  This didn't take the bast callbacks for
asynchronous lock contention notifications into account, which remain
active until until a lock is unlocked or its lockspace is released.

To prevent those callbacks from accessing deallocated objects, put the
glocks that should not be unlocked on the sd_dead_glocks list, release
the lockspace, and only then free those glocks.

As an additional measure, ignore unexpected ast and bast callbacks if
the receiving glock is dead.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('8a6e2004307f7b8728a1d801ea3ca8cb585ef44f')">
                                    <div class="issue-number">62</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="8a6e2004307f7b8728a1d801ea3ca8cb585ef44f">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

watchdog: cpu5wdt.c: Fix use-after-free bug caused by cpu5wdt_trigger

When the cpu5wdt module is removing, the origin code uses del_timer() to
de-activate the timer. If the timer handler is running, del_timer() could
not stop it and will return directly. If the port region is released by
release_region() and then the timer handler cpu5wdt_trigger() calls outb()
to write into the region that is released, the use-after-free bug will
happen.

Change del_timer() to timer_shutdown_sync() in order that the timer handler
could be finished before the port region is released.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('ec04a768d90e2697a2e0647ed6239194f14855f0')">
                                    <div class="issue-number">63</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="ec04a768d90e2697a2e0647ed6239194f14855f0">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/i915/hwmon: Get rid of devm

When both hwmon and hwmon drvdata (on which hwmon depends) are device
managed resources, the expectation, on device unbind, is that hwmon will be
released before drvdata. However, in i915 there are two separate code
paths, which both release either drvdata or hwmon and either can be
released before the other. These code paths (for device unbind) are as
follows (see also the bug referenced below):

Call Trace:
release_nodes+0x11/0x70
devres_release_group+0xb2/0x110
component_unbind_all+0x8d/0xa0
component_del+0xa5/0x140
intel_pxp_tee_component_fini+0x29/0x40 [i915]
intel_pxp_fini+0x33/0x80 [i915]
i915_driver_remove+0x4c/0x120 [i915]
i915_pci_remove+0x19/0x30 [i915]
pci_device_remove+0x32/0xa0
device_release_driver_internal+0x19c/0x200
unbind_store+0x9c/0xb0

and

Call Trace:
release_nodes+0x11/0x70
devres_release_all+0x8a/0xc0
device_unbind_cleanup+0x9/0x70
device_release_driver_internal+0x1c1/0x200
unbind_store+0x9c/0xb0

This means that in i915, if use devm, we cannot gurantee that hwmon will
always be released before drvdata. Which means that we have a uaf if hwmon
sysfs is accessed when drvdata has been released but hwmon hasn't.

The only way out of this seems to be do get rid of devm_ and release/free
everything explicitly during device unbind.

v2: Change commit message and other minor code changes
v3: Cleanup from i915_hwmon_register on error (Armin Wolf)
v4: Eliminate potential static analyzer warning (Rodrigo)
    Eliminate fetch_and_zero (Jani)
v5: Restore previous logic for ddat_gt->hwmon_dev error return (Andi)</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('7edab173054ff4ddc01c6bbb479bf261239ae723')">
                                    <div class="issue-number">64</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="7edab173054ff4ddc01c6bbb479bf261239ae723">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

io_uring/io-wq: Use set_bit() and test_bit() at worker->flags

Utilize set_bit() and test_bit() on worker->flags within io_uring/io-wq
to address potential data races.

The structure io_worker->flags may be accessed through various data
paths, leading to concurrency issues. When KCSAN is enabled, it reveals
data races occurring in io_worker_handle_work and
io_wq_activate_free_worker functions.

	 BUG: KCSAN: data-race in io_worker_handle_work / io_wq_activate_free_worker
	 write to 0xffff8885c4246404 of 4 bytes by task 49071 on cpu 28:
	 io_worker_handle_work (io_uring/io-wq.c:434 io_uring/io-wq.c:569)
	 io_wq_worker (io_uring/io-wq.c:?)
<snip>

	 read to 0xffff8885c4246404 of 4 bytes by task 49024 on cpu 5:
	 io_wq_activate_free_worker (io_uring/io-wq.c:? io_uring/io-wq.c:285)
	 io_wq_enqueue (io_uring/io-wq.c:947)
	 io_queue_iowq (io_uring/io_uring.c:524)
	 io_req_task_submit (io_uring/io_uring.c:1511)
	 io_handle_tw_list (io_uring/io_uring.c:1198)
<snip>

Line numbers against commit 18daea77cca6 ("Merge tag 'for-linus' of
git://git.kernel.org/pub/scm/virt/kvm/kvm").

These races involve writes and reads to the same memory location by
different tasks running on different CPUs. To mitigate this, refactor
the code to use atomic operations such as set_bit(), test_bit(), and
clear_bit() instead of basic "and" and "or" operations. This ensures
thread-safe manipulation of worker flags.

Also, move `create_index` to avoid holes in the structure.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('88f997c7a21327dd675de63294a1d6ea27af8142')">
                                    <div class="issue-number">65</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="88f997c7a21327dd675de63294a1d6ea27af8142">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

xfs: don't walk off the end of a directory data block

This adds sanity checks for xfs_dir2_data_unused and xfs_dir2_data_entry
to make sure don't stray beyond valid memory region. Before patching, the
loop simply checks that the start offset of the dup and dep is within the
range. So in a crafted image, if last entry is xfs_dir2_data_unused, we
can change dup->length to dup->length-1 and leave 1 byte of space. In the
next traversal, this space will be considered as dup or dep. We may
encounter an out of bound read when accessing the fixed members.

In the patch, we make sure that the remaining bytes large enough to hold
an unused entry before accessing xfs_dir2_data_unused and
xfs_dir2_data_unused is XFS_DIR2_DATA_ALIGN byte aligned. We also make
sure that the remaining bytes large enough to hold a dirent with a
single-byte name before accessing xfs_dir2_data_entry.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('7feb72e41827a8aa51d22ff038ce183bcd70903c')">
                                    <div class="issue-number">66</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="7feb72e41827a8aa51d22ff038ce183bcd70903c">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Fix array-index-out-of-bounds in dml2/FCLKChangeSupport

[Why]
Potential out of bounds access in dml2_calculate_rq_and_dlg_params()
because the value of out_lowest_state_idx used as an index for FCLKChangeSupport
array can be greater than 1.

[How]
Currently dml2 core specifies identical values for all FCLKChangeSupport
elements. Always use index 0 in the condition to avoid out of bounds access.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('5be59efc3d03aa4c9bc068d9f6067db513be38f4')">
                                    <div class="issue-number">67</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="5be59efc3d03aa4c9bc068d9f6067db513be38f4">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

gve: Account for stopped queues when reading NIC stats

We now account for the fact that the NIC might send us stats for a
subset of queues. Without this change, gve_get_ethtool_stats might make
an invalid access on the priv->stats_report->stats array.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('b3f3d58f9dce083952563052b042b390c6bef545')">
                                    <div class="issue-number">68</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="b3f3d58f9dce083952563052b042b390c6bef545">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

f2fs: fix to cover read extent cache access with lock

syzbot reports a f2fs bug as below:

BUG: KASAN: slab-use-after-free in sanity_check_extent_cache+0x370/0x410 fs/f2fs/extent_cache.c:46
Read of size 4 at addr ffff8880739ab220 by task syz-executor200/5097

CPU: 0 PID: 5097 Comm: syz-executor200 Not tainted 6.9.0-rc6-syzkaller #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 03/27/2024
Call Trace:
 <TASK>
 __dump_stack lib/dump_stack.c:88 [inline]
 dump_stack_lvl+0x241/0x360 lib/dump_stack.c:114
 print_address_description mm/kasan/report.c:377 [inline]
 print_report+0x169/0x550 mm/kasan/report.c:488
 kasan_report+0x143/0x180 mm/kasan/report.c:601
 sanity_check_extent_cache+0x370/0x410 fs/f2fs/extent_cache.c:46
 do_read_inode fs/f2fs/inode.c:509 [inline]
 f2fs_iget+0x33e1/0x46e0 fs/f2fs/inode.c:560
 f2fs_nfs_get_inode+0x74/0x100 fs/f2fs/super.c:3237
 generic_fh_to_dentry+0x9f/0xf0 fs/libfs.c:1413
 exportfs_decode_fh_raw+0x152/0x5f0 fs/exportfs/expfs.c:444
 exportfs_decode_fh+0x3c/0x80 fs/exportfs/expfs.c:584
 do_handle_to_path fs/fhandle.c:155 [inline]
 handle_to_path fs/fhandle.c:210 [inline]
 do_handle_open+0x495/0x650 fs/fhandle.c:226
 do_syscall_x64 arch/x86/entry/common.c:52 [inline]
 do_syscall_64+0xf5/0x240 arch/x86/entry/common.c:83
 entry_SYSCALL_64_after_hwframe+0x77/0x7f

We missed to cover sanity_check_extent_cache() w/ extent cache lock,
so, below race case may happen, result in use after free issue.

- f2fs_iget
 - do_read_inode
  - f2fs_init_read_extent_tree
  : add largest extent entry in to cache
					- shrink
					 - f2fs_shrink_read_extent_tree
					  - __shrink_extent_tree
					   - __detach_extent_node
					   : drop largest extent entry
  - sanity_check_extent_cache
  : access et->largest w/o lock

let's refactor sanity_check_extent_cache() to avoid extent cache access
and call it before f2fs_init_read_extent_tree() to fix this issue.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('6ae076b1b6aaddf3dd9e2c5d4ab14955850a7aee')">
                                    <div class="issue-number">69</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="6ae076b1b6aaddf3dd9e2c5d4ab14955850a7aee">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

f2fs: fix to do sanity check on F2FS_INLINE_DATA flag in inode during GC

syzbot reports a f2fs bug as below:

------------[ cut here ]------------
kernel BUG at fs/f2fs/inline.c:258!
CPU: 1 PID: 34 Comm: kworker/u8:2 Not tainted 6.9.0-rc6-syzkaller-00012-g9e4bc4bcae01 #0
RIP: 0010:f2fs_write_inline_data+0x781/0x790 fs/f2fs/inline.c:258
Call Trace:
 f2fs_write_single_data_page+0xb65/0x1d60 fs/f2fs/data.c:2834
 f2fs_write_cache_pages fs/f2fs/data.c:3133 [inline]
 __f2fs_write_data_pages fs/f2fs/data.c:3288 [inline]
 f2fs_write_data_pages+0x1efe/0x3a90 fs/f2fs/data.c:3315
 do_writepages+0x35b/0x870 mm/page-writeback.c:2612
 __writeback_single_inode+0x165/0x10b0 fs/fs-writeback.c:1650
 writeback_sb_inodes+0x905/0x1260 fs/fs-writeback.c:1941
 wb_writeback+0x457/0xce0 fs/fs-writeback.c:2117
 wb_do_writeback fs/fs-writeback.c:2264 [inline]
 wb_workfn+0x410/0x1090 fs/fs-writeback.c:2304
 process_one_work kernel/workqueue.c:3254 [inline]
 process_scheduled_works+0xa12/0x17c0 kernel/workqueue.c:3335
 worker_thread+0x86d/0xd70 kernel/workqueue.c:3416
 kthread+0x2f2/0x390 kernel/kthread.c:388
 ret_from_fork+0x4d/0x80 arch/x86/kernel/process.c:147
 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244

The root cause is: inline_data inode can be fuzzed, so that there may
be valid blkaddr in its direct node, once f2fs triggers background GC
to migrate the block, it will hit f2fs_bug_on() during dirty page
writeback.

Let's add sanity check on F2FS_INLINE_DATA flag in inode during GC,
so that, it can forbid migrating inline_data inode's data block for
fixing.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('4f9d254204f7aa0933d9f864a9999aacb4a57479')">
                                    <div class="issue-number">70</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="4f9d254204f7aa0933d9f864a9999aacb4a57479">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

serial: sc16is7xx: fix TX fifo corruption

Sometimes, when a packet is received on channel A at almost the same time
as a packet is about to be transmitted on channel B, we observe with a
logic analyzer that the received packet on channel A is transmitted on
channel B. In other words, the Tx buffer data on channel B is corrupted
with data from channel A.

The problem appeared since commit 4409df5866b7 ("serial: sc16is7xx: change
EFR lock to operate on each channels"), which changed the EFR locking to
operate on each channel instead of chip-wise.

This commit has introduced a regression, because the EFR lock is used not
only to protect the EFR registers access, but also, in a very obscure and
undocumented way, to protect access to the data buffer, which is shared by
the Tx and Rx handlers, but also by each channel of the IC.

Fix this regression first by switching to kfifo_out_linear_ptr() in
sc16is7xx_handle_tx() to eliminate the need for a shared Rx/Tx buffer.

Secondly, replace the chip-wise Rx buffer with a separate Rx buffer for
each channel.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('adc052787a257a927e046f5e5e60e1be83b4af3a')">
                                    <div class="issue-number">71</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="adc052787a257a927e046f5e5e60e1be83b4af3a">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

powerpc/rtas: Prevent Spectre v1 gadget construction in sys_rtas()

Smatch warns:

  arch/powerpc/kernel/rtas.c:1932 __do_sys_rtas() warn: potential
  spectre issue 'args.args' [r] (local cap)

The 'nargs' and 'nret' locals come directly from a user-supplied
buffer and are used as indexes into a small stack-based array and as
inputs to copy_to_user() after they are subject to bounds checks.

Use array_index_nospec() after the bounds checks to clamp these values
for speculative execution.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('7efbef31d738f7cfc35548edfcb93fdea36bddb4')">
                                    <div class="issue-number">72</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="7efbef31d738f7cfc35548edfcb93fdea36bddb4">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

fscache: delete fscache_cookie_lru_timer when fscache exits to avoid UAF

The fscache_cookie_lru_timer is initialized when the fscache module
is inserted, but is not deleted when the fscache module is removed.
If timer_reduce() is called before removing the fscache module,
the fscache_cookie_lru_timer will be added to the timer list of
the current cpu. Afterwards, a use-after-free will be triggered
in the softIRQ after removing the fscache module, as follows:

==================================================================
BUG: unable to handle page fault for address: fffffbfff803c9e9
 PF: supervisor read access in kernel mode
 PF: error_code(0x0000) - not-present page
PGD 21ffea067 P4D 21ffea067 PUD 21ffe6067 PMD 110a7c067 PTE 0
Oops: Oops: 0000 [#1] PREEMPT SMP KASAN PTI
CPU: 1 UID: 0 PID: 0 Comm: swapper/1 Tainted: G W 6.11.0-rc3 #855
Tainted: [W]=WARN
RIP: 0010:__run_timer_base.part.0+0x254/0x8a0
Call Trace:
 <IRQ>
 tmigr_handle_remote_up+0x627/0x810
 __walk_groups.isra.0+0x47/0x140
 tmigr_handle_remote+0x1fa/0x2f0
 handle_softirqs+0x180/0x590
 irq_exit_rcu+0x84/0xb0
 sysvec_apic_timer_interrupt+0x6e/0x90
 </IRQ>
 <TASK>
 asm_sysvec_apic_timer_interrupt+0x1a/0x20
RIP: 0010:default_idle+0xf/0x20
 default_idle_call+0x38/0x60
 do_idle+0x2b5/0x300
 cpu_startup_entry+0x54/0x60
 start_secondary+0x20d/0x280
 common_startup_64+0x13e/0x148
 </TASK>
Modules linked in: [last unloaded: netfs]
==================================================================

Therefore delete fscache_cookie_lru_timer when removing the fscahe module.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('b033172d0d8055d69c68cc987df9cb2ec4c898d2')">
                                    <div class="issue-number">73</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="b033172d0d8055d69c68cc987df9cb2ec4c898d2">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Fix index may exceed array range within fpu_update_bw_bounding_box

[Why]
Coverity reports OVERRUN warning. soc.num_states could
be 40. But array range of bw_params->clk_table.entries is 8.

[How]
Assert if soc.num_states greater than 8.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('a09263568bf2c609bf5d7e069388e28c974a5bfd')">
                                    <div class="issue-number">74</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="a09263568bf2c609bf5d7e069388e28c974a5bfd">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Check link_index before accessing dc->links[]

[WHY & HOW]
dc->links[] has max size of MAX_LINKS and NULL is return when trying to
access with out-of-bound index.

This fixes 3 OVERRUN and 1 RESOURCE_LEAK issues reported by Coverity.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('230160bb777f0a9d0e3104f1c2f5fc471c4e8771')">
                                    <div class="issue-number">75</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="230160bb777f0a9d0e3104f1c2f5fc471c4e8771">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amdgpu/vcn: remove irq disabling in vcn 5 suspend

We do not directly enable/disable VCN IRQ in vcn 5.0.0.
And we do not handle the IRQ state as well. So the calls to
disable IRQ and set state are removed. This effectively gets
rid of the warining of
      "WARN_ON(!amdgpu_irq_enabled(adev, src, type))"
in amdgpu_irq_put().</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('5f291b0f3492a3774662cb4ce7f10d3051eecfb0')">
                                    <div class="issue-number">76</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="5f291b0f3492a3774662cb4ce7f10d3051eecfb0">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

net: hns3: void array out of bound when loop tnl_num

When query reg inf of SSU, it loops tnl_num times. However, tnl_num comes
from hardware and the length of array is a fixed value. To void array out
of bound, make sure the loop time is not greater than the length of array</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('445af0e382bb59de31d304166a7ea452679337c8')">
                                    <div class="issue-number">77</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="445af0e382bb59de31d304166a7ea452679337c8">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

f2fs: fix to avoid use-after-free in f2fs_stop_gc_thread()

syzbot reports a f2fs bug as below:

 __dump_stack lib/dump_stack.c:88 [inline]
 dump_stack_lvl+0x241/0x360 lib/dump_stack.c:114
 print_report+0xe8/0x550 mm/kasan/report.c:491
 kasan_report+0x143/0x180 mm/kasan/report.c:601
 kasan_check_range+0x282/0x290 mm/kasan/generic.c:189
 instrument_atomic_read_write include/linux/instrumented.h:96 [inline]
 atomic_fetch_add_relaxed include/linux/atomic/atomic-instrumented.h:252 [inline]
 __refcount_add include/linux/refcount.h:184 [inline]
 __refcount_inc include/linux/refcount.h:241 [inline]
 refcount_inc include/linux/refcount.h:258 [inline]
 get_task_struct include/linux/sched/task.h:118 [inline]
 kthread_stop+0xca/0x630 kernel/kthread.c:704
 f2fs_stop_gc_thread+0x65/0xb0 fs/f2fs/gc.c:210
 f2fs_do_shutdown+0x192/0x540 fs/f2fs/file.c:2283
 f2fs_ioc_shutdown fs/f2fs/file.c:2325 [inline]
 __f2fs_ioctl+0x443a/0xbe60 fs/f2fs/file.c:4325
 vfs_ioctl fs/ioctl.c:51 [inline]
 __do_sys_ioctl fs/ioctl.c:907 [inline]
 __se_sys_ioctl+0xfc/0x170 fs/ioctl.c:893
 do_syscall_x64 arch/x86/entry/common.c:52 [inline]
 do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83
 entry_SYSCALL_64_after_hwframe+0x77/0x7f

The root cause is below race condition, it may cause use-after-free
issue in sbi->gc_th pointer.

- remount
 - f2fs_remount
  - f2fs_stop_gc_thread
   - kfree(gc_th)
				- f2fs_ioc_shutdown
				 - f2fs_do_shutdown
				  - f2fs_stop_gc_thread
				   - kthread_stop(gc_th->f2fs_gc_task)
   : sbi->gc_thread = NULL;

We will call f2fs_do_shutdown() in two paths:
- for f2fs_ioc_shutdown() path, we should grab sb->s_umount semaphore
for fixing.
- for f2fs_shutdown() path, it's safe since caller has already grabbed
sb->s_umount semaphore.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('a876050458a42076cc8cabb7b18874eb92056179')">
                                    <div class="issue-number">78</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="a876050458a42076cc8cabb7b18874eb92056179">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

mm: call the security_mmap_file() LSM hook in remap_file_pages()

The remap_file_pages syscall handler calls do_mmap() directly, which
doesn't contain the LSM security check. And if the process has called
personality(READ_IMPLIES_EXEC) before and remap_file_pages() is called for
RW pages, this will actually result in remapping the pages to RWX,
bypassing a W^X policy enforced by SELinux.

So we should check prot by security_mmap_file LSM hook in the
remap_file_pages syscall handler before do_mmap() is called. Otherwise, it
potentially permits an attacker to bypass a W^X policy enforced by
SELinux.

The bypass is similar to CVE-2016-10044, which bypass the same thing via
AIO and can be found in [1].

The PoC:

$ cat > test.c

int main(void) {
	size_t pagesz = sysconf(_SC_PAGE_SIZE);
	int mfd = syscall(SYS_memfd_create, "test", 0);
	const char *buf = mmap(NULL, 4 * pagesz, PROT_READ | PROT_WRITE,
		MAP_SHARED, mfd, 0);
	unsigned int old = syscall(SYS_personality, 0xffffffff);
	syscall(SYS_personality, READ_IMPLIES_EXEC | old);
	syscall(SYS_remap_file_pages, buf, pagesz, 0, 2, 0);
	syscall(SYS_personality, old);
	// show the RWX page exists even if W^X policy is enforced
	int fd = open("/proc/self/maps", O_RDONLY);
	unsigned char buf2[1024];
	while (1) {
		int ret = read(fd, buf2, 1024);
		if (ret <= 0) break;
		write(1, buf2, ret);
	}
	close(fd);
}

$ gcc test.c -o test
$ ./test | grep rwx
7f1836c34000-7f1836c35000 rwxs 00002000 00:01 2050 /memfd:test (deleted)

[PM: subject line tweaks]</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('a0bb34195c9887c386fd67658b9e45ae3d389e71')">
                                    <div class="issue-number">79</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="a0bb34195c9887c386fd67658b9e45ae3d389e71">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

bpf: Fix helper writes to read-only maps

Lonial found an issue that despite user- and BPF-side frozen BPF map
(like in case of .rodata), it was still possible to write into it from
a BPF program side through specific helpers having ARG_PTR_TO_{LONG,INT}
as arguments.

In check_func_arg() when the argument is as mentioned, the meta->raw_mode
is never set. Later, check_helper_mem_access(), under the case of
PTR_TO_MAP_VALUE as register base type, it assumes BPF_READ for the
subsequent call to check_map_access_type() and given the BPF map is
read-only it succeeds.

The helpers really need to be annotated as ARG_PTR_TO_{LONG,INT} | MEM_UNINIT
when results are written into them as opposed to read out of them. The
latter indicates that it's okay to pass a pointer to uninitialized memory
as the memory is written to anyway.

However, ARG_PTR_TO_{LONG,INT} is a special case of ARG_PTR_TO_FIXED_SIZE_MEM
just with additional alignment requirement. So it is better to just get
rid of the ARG_PTR_TO_{LONG,INT} special cases altogether and reuse the
fixed size memory types. For this, add MEM_ALIGNED to additionally ensure
alignment given these helpers write directly into the args via *<ptr> = val.
The .arg*_size has been initialized reflecting the actual sizeof(*<ptr>).

MEM_ALIGNED can only be used in combination with MEM_FIXED_SIZE annotated
argument types, since in !MEM_FIXED_SIZE cases the verifier does not know
the buffer size a priori and therefore cannot blindly write *<ptr> = val.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('e7f6f7bfe1d925deee6ec12b17c7af0c727026a5')">
                                    <div class="issue-number">80</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="e7f6f7bfe1d925deee6ec12b17c7af0c727026a5">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

wifi: rtw89: avoid reading out of bounds when loading TX power FW elements

Because the loop-expression will do one more time before getting false from
cond-expression, the original code copied one more entry size beyond valid
region.

Fix it by moving the entry copy to loop-body.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('3bc2907665d6b3b4dd6ce6d7c7f046eb416f1ef8')">
                                    <div class="issue-number">81</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="3bc2907665d6b3b4dd6ce6d7c7f046eb416f1ef8">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: fix double free issue during amdgpu module unload

Flexible endpoints use DIGs from available inflexible endpoints,
so only the encoders of inflexible links need to be freed.
Otherwise, a double free issue may occur when unloading the
amdgpu module.

[  279.190523] RIP: 0010:__slab_free+0x152/0x2f0
[  279.190577] Call Trace:
[  279.190580]  <TASK>
[  279.190582]  ? show_regs+0x69/0x80
[  279.190590]  ? die+0x3b/0x90
[  279.190595]  ? do_trap+0xc8/0xe0
[  279.190601]  ? do_error_trap+0x73/0xa0
[  279.190605]  ? __slab_free+0x152/0x2f0
[  279.190609]  ? exc_invalid_op+0x56/0x70
[  279.190616]  ? __slab_free+0x152/0x2f0
[  279.190642]  ? asm_exc_invalid_op+0x1f/0x30
[  279.190648]  ? dcn10_link_encoder_destroy+0x19/0x30 [amdgpu]
[  279.191096]  ? __slab_free+0x152/0x2f0
[  279.191102]  ? dcn10_link_encoder_destroy+0x19/0x30 [amdgpu]
[  279.191469]  kfree+0x260/0x2b0
[  279.191474]  dcn10_link_encoder_destroy+0x19/0x30 [amdgpu]
[  279.191821]  link_destroy+0xd7/0x130 [amdgpu]
[  279.192248]  dc_destruct+0x90/0x270 [amdgpu]
[  279.192666]  dc_destroy+0x19/0x40 [amdgpu]
[  279.193020]  amdgpu_dm_fini+0x16e/0x200 [amdgpu]
[  279.193432]  dm_hw_fini+0x26/0x40 [amdgpu]
[  279.193795]  amdgpu_device_fini_hw+0x24c/0x400 [amdgpu]
[  279.194108]  amdgpu_driver_unload_kms+0x4f/0x70 [amdgpu]
[  279.194436]  amdgpu_pci_remove+0x40/0x80 [amdgpu]
[  279.194632]  pci_device_remove+0x3a/0xa0
[  279.194638]  device_remove+0x40/0x70
[  279.194642]  device_release_driver_internal+0x1ad/0x210
[  279.194647]  driver_detach+0x4e/0xa0
[  279.194650]  bus_remove_driver+0x6f/0xf0
[  279.194653]  driver_unregister+0x33/0x60
[  279.194657]  pci_unregister_driver+0x44/0x90
[  279.194662]  amdgpu_exit+0x19/0x1f0 [amdgpu]
[  279.194939]  __do_sys_delete_module.isra.0+0x198/0x2f0
[  279.194946]  __x64_sys_delete_module+0x16/0x20
[  279.194950]  do_syscall_64+0x58/0x120
[  279.194954]  entry_SYSCALL_64_after_hwframe+0x6e/0x76
[  279.194980]  </TASK></p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('5cdfbfdcb11d11d79000ab7727b7d94b4663c6ba')">
                                    <div class="issue-number">82</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="5cdfbfdcb11d11d79000ab7727b7d94b4663c6ba">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

cifs: Fix buffer overflow when parsing NFS reparse points

ReparseDataLength is sum of the InodeType size and DataBuffer size.
So to get DataBuffer size it is needed to subtract InodeType's size from
ReparseDataLength.

Function cifs_strndup_from_utf16() is currentlly accessing buf->DataBuffer
at position after the end of the buffer because it does not subtract
InodeType size from the length. Fix this problem and correctly subtract
variable len.

Member InodeType is present only when reparse buffer is large enough. Check
for ReparseDataLength before accessing InodeType to prevent another invalid
memory access.

Major and minor rdev values are present also only when reparse buffer is
large enough. Check for reparse buffer size before calling reparse_mkdev().</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('bc435ddf2bc49c790d18a4b4f8ca8d1d181b25d1')">
                                    <div class="issue-number">83</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="bc435ddf2bc49c790d18a4b4f8ca8d1d181b25d1">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

Bluetooth: hci_conn: Fix UAF in hci_enhanced_setup_sync

This checks if the ACL connection remains valid as it could be destroyed
while hci_enhanced_setup_sync is pending on cmd_sync leading to the
following trace:

BUG: KASAN: slab-use-after-free in hci_enhanced_setup_sync+0x91b/0xa60
Read of size 1 at addr ffff888002328ffd by task kworker/u5:2/37

CPU: 0 UID: 0 PID: 37 Comm: kworker/u5:2 Not tainted 6.11.0-rc6-01300-g810be445d8d6 #7099
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-2.fc40 04/01/2014
Workqueue: hci0 hci_cmd_sync_work
Call Trace:
 <TASK>
 dump_stack_lvl+0x5d/0x80
 ? hci_enhanced_setup_sync+0x91b/0xa60
 print_report+0x152/0x4c0
 ? hci_enhanced_setup_sync+0x91b/0xa60
 ? __virt_addr_valid+0x1fa/0x420
 ? hci_enhanced_setup_sync+0x91b/0xa60
 kasan_report+0xda/0x1b0
 ? hci_enhanced_setup_sync+0x91b/0xa60
 hci_enhanced_setup_sync+0x91b/0xa60
 ? __pfx_hci_enhanced_setup_sync+0x10/0x10
 ? __pfx___mutex_lock+0x10/0x10
 hci_cmd_sync_work+0x1c2/0x330
 process_one_work+0x7d9/0x1360
 ? __pfx_lock_acquire+0x10/0x10
 ? __pfx_process_one_work+0x10/0x10
 ? assign_work+0x167/0x240
 worker_thread+0x5b7/0xf60
 ? __kthread_parkme+0xac/0x1c0
 ? __pfx_worker_thread+0x10/0x10
 ? __pfx_worker_thread+0x10/0x10
 kthread+0x293/0x360
 ? __pfx_kthread+0x10/0x10
 ret_from_fork+0x2f/0x70
 ? __pfx_kthread+0x10/0x10
 ret_from_fork_asm+0x1a/0x30
 </TASK>

Allocated by task 34:
 kasan_save_stack+0x30/0x50
 kasan_save_track+0x14/0x30
 __kasan_kmalloc+0x8f/0xa0
 __hci_conn_add+0x187/0x17d0
 hci_connect_sco+0x2e1/0xb90
 sco_sock_connect+0x2a2/0xb80
 __sys_connect+0x227/0x2a0
 __x64_sys_connect+0x6d/0xb0
 do_syscall_64+0x71/0x140
 entry_SYSCALL_64_after_hwframe+0x76/0x7e

Freed by task 37:
 kasan_save_stack+0x30/0x50
 kasan_save_track+0x14/0x30
 kasan_save_free_info+0x3b/0x60
 __kasan_slab_free+0x101/0x160
 kfree+0xd0/0x250
 device_release+0x9a/0x210
 kobject_put+0x151/0x280
 hci_conn_del+0x448/0xbf0
 hci_abort_conn_sync+0x46f/0x980
 hci_cmd_sync_work+0x1c2/0x330
 process_one_work+0x7d9/0x1360
 worker_thread+0x5b7/0xf60
 kthread+0x293/0x360
 ret_from_fork+0x2f/0x70
 ret_from_fork_asm+0x1a/0x30</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('d835cf8f776d2d5158753a4fd19b9a1e682348ad')">
                                    <div class="issue-number">84</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="d835cf8f776d2d5158753a4fd19b9a1e682348ad">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

smb: client: fix UAF in async decryption

Doing an async decryption (large read) crashes with a
slab-use-after-free way down in the crypto API.

Reproducer:
    # mount.cifs -o ...,seal,esize=1 //srv/share /mnt
    # dd if=/mnt/largefile of=/dev/null
    ...
    [  194.196391] ==================================================================
    [  194.196844] BUG: KASAN: slab-use-after-free in gf128mul_4k_lle+0xc1/0x110
    [  194.197269] Read of size 8 at addr ffff888112bd0448 by task kworker/u77:2/899
    [  194.197707]
    [  194.197818] CPU: 12 UID: 0 PID: 899 Comm: kworker/u77:2 Not tainted 6.11.0-lku-00028-gfca3ca14a17a-dirty #43
    [  194.198400] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.16.2-3-gd478f380-prebuilt.qemu.org 04/01/2014
    [  194.199046] Workqueue: smb3decryptd smb2_decrypt_offload [cifs]
    [  194.200032] Call Trace:
    [  194.200191]  <TASK>
    [  194.200327]  dump_stack_lvl+0x4e/0x70
    [  194.200558]  ? gf128mul_4k_lle+0xc1/0x110
    [  194.200809]  print_report+0x174/0x505
    [  194.201040]  ? __pfx__raw_spin_lock_irqsave+0x10/0x10
    [  194.201352]  ? srso_return_thunk+0x5/0x5f
    [  194.201604]  ? __virt_addr_valid+0xdf/0x1c0
    [  194.201868]  ? gf128mul_4k_lle+0xc1/0x110
    [  194.202128]  kasan_report+0xc8/0x150
    [  194.202361]  ? gf128mul_4k_lle+0xc1/0x110
    [  194.202616]  gf128mul_4k_lle+0xc1/0x110
    [  194.202863]  ghash_update+0x184/0x210
    [  194.203103]  shash_ahash_update+0x184/0x2a0
    [  194.203377]  ? __pfx_shash_ahash_update+0x10/0x10
    [  194.203651]  ? srso_return_thunk+0x5/0x5f
    [  194.203877]  ? crypto_gcm_init_common+0x1ba/0x340
    [  194.204142]  gcm_hash_assoc_remain_continue+0x10a/0x140
    [  194.204434]  crypt_message+0xec1/0x10a0 [cifs]
    [  194.206489]  ? __pfx_crypt_message+0x10/0x10 [cifs]
    [  194.208507]  ? srso_return_thunk+0x5/0x5f
    [  194.209205]  ? srso_return_thunk+0x5/0x5f
    [  194.209925]  ? srso_return_thunk+0x5/0x5f
    [  194.210443]  ? srso_return_thunk+0x5/0x5f
    [  194.211037]  decrypt_raw_data+0x15f/0x250 [cifs]
    [  194.212906]  ? __pfx_decrypt_raw_data+0x10/0x10 [cifs]
    [  194.214670]  ? srso_return_thunk+0x5/0x5f
    [  194.215193]  smb2_decrypt_offload+0x12a/0x6c0 [cifs]

This is because TFM is being used in parallel.

Fix this by allocating a new AEAD TFM for async decryption, but keep
the existing one for synchronous READ cases (similar to what is done
in smb3_calc_signature()).

Also remove the calls to aead_request_set_callback() and
crypto_wait_req() since it's always going to be a synchronous operation.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('4f0391954a541386f1ad7fc6243e7acc8d368801')">
                                    <div class="issue-number">85</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="4f0391954a541386f1ad7fc6243e7acc8d368801">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

driver core: bus: Fix double free in driver API bus_register()

For bus_register(), any error which happens after kset_register() will
cause that @priv are freed twice, fixed by setting @priv with NULL after
the first free.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('1d7ae8fa1bbac71de012e55b887e5c52c12aa534')">
                                    <div class="issue-number">86</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="1d7ae8fa1bbac71de012e55b887e5c52c12aa534">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

i3c: master: cdns: Fix use after free vulnerability in cdns_i3c_master Driver Due to Race Condition

In the cdns_i3c_master_probe function, &master->hj_work is bound with
cdns_i3c_master_hj. And cdns_i3c_master_interrupt can call
cnds_i3c_master_demux_ibis function to start the work.

If we remove the module which will call cdns_i3c_master_remove to
make cleanup, it will free master->base through i3c_master_unregister
while the work mentioned above will be used. The sequence of operations
that may lead to a UAF bug is as follows:

CPU0                                      CPU1

                                     | cdns_i3c_master_hj
cdns_i3c_master_remove               |
i3c_master_unregister(&master->base) |
device_unregister(&master->dev)      |
device_release                       |
//free master->base                  |
                                     | i3c_master_do_daa(&master->base)
                                     | //use master->base

Fix it by ensuring that the work is canceled before proceeding with
the cleanup in cdns_i3c_master_remove.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('ca05b42a8d99dcf6c19456ac83aad39639eba3a2')">
                                    <div class="issue-number">87</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="ca05b42a8d99dcf6c19456ac83aad39639eba3a2">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

bpf: Prevent tail call between progs attached to different hooks

bpf progs can be attached to kernel functions, and the attached functions
can take different parameters or return different return values. If
prog attached to one kernel function tail calls prog attached to another
kernel function, the ctx access or return value verification could be
bypassed.

For example, if prog1 is attached to func1 which takes only 1 parameter
and prog2 is attached to func2 which takes two parameters. Since verifier
assumes the bpf ctx passed to prog2 is constructed based on func2's
prototype, verifier allows prog2 to access the second parameter from
the bpf ctx passed to it. The problem is that verifier does not prevent
prog1 from passing its bpf ctx to prog2 via tail call. In this case,
the bpf ctx passed to prog2 is constructed from func1 instead of func2,
that is, the assumption for ctx access verification is bypassed.

Another example, if BPF LSM prog1 is attached to hook file_alloc_security,
and BPF LSM prog2 is attached to hook bpf_lsm_audit_rule_known. Verifier
knows the return value rules for these two hooks, e.g. it is legal for
bpf_lsm_audit_rule_known to return positive number 1, and it is illegal
for file_alloc_security to return positive number. So verifier allows
prog2 to return positive number 1, but does not allow prog1 to return
positive number. The problem is that verifier does not prevent prog1
from calling prog2 via tail call. In this case, prog2's return value 1
will be used as the return value for prog1's hook file_alloc_security.
That is, the return value rule is bypassed.

This patch adds restriction for tail call to prevent such bypasses.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('66b1d3fe9259c9478bd32f8032633f47fff7ed64')">
                                    <div class="issue-number">88</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="66b1d3fe9259c9478bd32f8032633f47fff7ed64">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

nfsd: fix race between laundromat and free_stateid

There is a race between laundromat handling of revoked delegations
and a client sending free_stateid operation. Laundromat thread
finds that delegation has expired and needs to be revoked so it
marks the delegation stid revoked and it puts it on a reaper list
but then it unlock the state lock and the actual delegation revocation
happens without the lock. Once the stid is marked revoked a racing
free_stateid processing thread does the following (1) it calls
list_del_init() which removes it from the reaper list and (2) frees
the delegation stid structure. The laundromat thread ends up not
calling the revoke_delegation() function for this particular delegation
but that means it will no release the lock lease that exists on
the file.

Now, a new open for this file comes in and ends up finding that
lease list isn't empty and calls nfsd_breaker_owns_lease() which ends
up trying to derefence a freed delegation stateid. Leading to the
followint use-after-free KASAN warning:

kernel: ==================================================================
kernel: BUG: KASAN: slab-use-after-free in nfsd_breaker_owns_lease+0x140/0x160 [nfsd]
kernel: Read of size 8 at addr ffff0000e73cd0c8 by task nfsd/6205
kernel:
kernel: CPU: 2 UID: 0 PID: 6205 Comm: nfsd Kdump: loaded Not tainted 6.11.0-rc7+ #9
kernel: Hardware name: Apple Inc. Apple Virtualization Generic Platform, BIOS 2069.0.0.0.0 08/03/2024
kernel: Call trace:
kernel: dump_backtrace+0x98/0x120
kernel: show_stack+0x1c/0x30
kernel: dump_stack_lvl+0x80/0xe8
kernel: print_address_description.constprop.0+0x84/0x390
kernel: print_report+0xa4/0x268
kernel: kasan_report+0xb4/0xf8
kernel: __asan_report_load8_noabort+0x1c/0x28
kernel: nfsd_breaker_owns_lease+0x140/0x160 [nfsd]
kernel: nfsd_file_do_acquire+0xb3c/0x11d0 [nfsd]
kernel: nfsd_file_acquire_opened+0x84/0x110 [nfsd]
kernel: nfs4_get_vfs_file+0x634/0x958 [nfsd]
kernel: nfsd4_process_open2+0xa40/0x1a40 [nfsd]
kernel: nfsd4_open+0xa08/0xe80 [nfsd]
kernel: nfsd4_proc_compound+0xb8c/0x2130 [nfsd]
kernel: nfsd_dispatch+0x22c/0x718 [nfsd]
kernel: svc_process_common+0x8e8/0x1960 [sunrpc]
kernel: svc_process+0x3d4/0x7e0 [sunrpc]
kernel: svc_handle_xprt+0x828/0xe10 [sunrpc]
kernel: svc_recv+0x2cc/0x6a8 [sunrpc]
kernel: nfsd+0x270/0x400 [nfsd]
kernel: kthread+0x288/0x310
kernel: ret_from_fork+0x10/0x20

This patch proposes a fixed that's based on adding 2 new additional
stid's sc_status values that help coordinate between the laundromat
and other operations (nfsd4_free_stateid() and nfsd4_delegreturn()).

First to make sure, that once the stid is marked revoked, it is not
removed by the nfsd4_free_stateid(), the laundromat take a reference
on the stateid. Then, coordinating whether the stid has been put
on the cl_revoked list or we are processing FREE_STATEID and need to
make sure to remove it from the list, each check that state and act
accordingly. If laundromat has added to the cl_revoke list before
the arrival of FREE_STATEID, then nfsd4_free_stateid() knows to remove
it from the list. If nfsd4_free_stateid() finds that operations arrived
before laundromat has placed it on cl_revoke list, it marks the state
freed and then laundromat will no longer add it to the list.

Also, for nfsd4_delegreturn() when looking for the specified stid,
we need to access stid that are marked removed or freeable, it means
the laundromat has started processing it but hasn't finished and this
delegreturn needs to return nfserr_deleg_revoked and not
nfserr_bad_stateid. The latter will not trigger a FREE_STATEID and the
lack of it will leave this stid on the cl_revoked list indefinitely.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('6b53a882181e2f7f08b568a15e7da4a6c94ffdaf')">
                                    <div class="issue-number">89</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="6b53a882181e2f7f08b568a15e7da4a6c94ffdaf">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

x86/lam: Disable ADDRESS_MASKING in most cases

Linear Address Masking (LAM) has a weakness related to transient
execution as described in the SLAM paper[1]. Unless Linear Address
Space Separation (LASS) is enabled this weakness may be exploitable.

Until kernel adds support for LASS[2], only allow LAM for COMPILE_TEST,
or when speculation mitigations have been disabled at compile time,
otherwise keep LAM disabled.

There are no processors in market that support LAM yet, so currently
nobody is affected by this issue.

[1] SLAM: https://download.vusec.net/papers/slam_sp24.pdf
[2] LASS: https://lore.kernel.org/lkml/20230609183632.48706-1-alexander.shishkin@linux.intel.com/

[ dhansen: update SPECULATION_MITIGATIONS -> CPU_MITIGATIONS ]</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('41272bad6c01ef7e2137ad17431a369c50c7b614')">
                                    <div class="issue-number">90</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="41272bad6c01ef7e2137ad17431a369c50c7b614">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

nfsd: cancel nfsd_shrinker_work using sync mode in nfs4_state_shutdown_net

In the normal case, when we excute `echo 0 > /proc/fs/nfsd/threads`, the
function `nfs4_state_destroy_net` in `nfs4_state_shutdown_net` will
release all resources related to the hashed `nfs4_client`. If the
`nfsd_client_shrinker` is running concurrently, the `expire_client`
function will first unhash this client and then destroy it. This can
lead to the following warning. Additionally, numerous use-after-free
errors may occur as well.

nfsd_client_shrinker         echo 0 > /proc/fs/nfsd/threads

expire_client                nfsd_shutdown_net
  unhash_client                ...
                               nfs4_state_shutdown_net
                                 /* won't wait shrinker exit */
  /*                             cancel_work(&nn->nfsd_shrinker_work)
   * nfsd_file for this          /* won't destroy unhashed client1 */
   * client1 still alive         nfs4_state_destroy_net
   */

                               nfsd_file_cache_shutdown
                                 /* trigger warning */
                                 kmem_cache_destroy(nfsd_file_slab)
                                 kmem_cache_destroy(nfsd_file_mark_slab)
  /* release nfsd_file and mark */
  __destroy_client

====================================================================
BUG nfsd_file (Not tainted): Objects remaining in nfsd_file on
__kmem_cache_shutdown()
--------------------------------------------------------------------
CPU: 4 UID: 0 PID: 764 Comm: sh Not tainted 6.12.0-rc3+ #1

 dump_stack_lvl+0x53/0x70
 slab_err+0xb0/0xf0
 __kmem_cache_shutdown+0x15c/0x310
 kmem_cache_destroy+0x66/0x160
 nfsd_file_cache_shutdown+0xac/0x210 [nfsd]
 nfsd_destroy_serv+0x251/0x2a0 [nfsd]
 nfsd_svc+0x125/0x1e0 [nfsd]
 write_threads+0x16a/0x2a0 [nfsd]
 nfsctl_transaction_write+0x74/0xa0 [nfsd]
 vfs_write+0x1a5/0x6d0
 ksys_write+0xc1/0x160
 do_syscall_64+0x5f/0x170
 entry_SYSCALL_64_after_hwframe+0x76/0x7e

====================================================================
BUG nfsd_file_mark (Tainted: G    B   W         ): Objects remaining
nfsd_file_mark on __kmem_cache_shutdown()
--------------------------------------------------------------------

 dump_stack_lvl+0x53/0x70
 slab_err+0xb0/0xf0
 __kmem_cache_shutdown+0x15c/0x310
 kmem_cache_destroy+0x66/0x160
 nfsd_file_cache_shutdown+0xc8/0x210 [nfsd]
 nfsd_destroy_serv+0x251/0x2a0 [nfsd]
 nfsd_svc+0x125/0x1e0 [nfsd]
 write_threads+0x16a/0x2a0 [nfsd]
 nfsctl_transaction_write+0x74/0xa0 [nfsd]
 vfs_write+0x1a5/0x6d0
 ksys_write+0xc1/0x160
 do_syscall_64+0x5f/0x170
 entry_SYSCALL_64_after_hwframe+0x76/0x7e

To resolve this issue, cancel `nfsd_shrinker_work` using synchronous
mode in nfs4_state_shutdown_net.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('80f547f8fcbccaf8c19cb3aa047dd578e7bc219e')">
                                    <div class="issue-number">91</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="80f547f8fcbccaf8c19cb3aa047dd578e7bc219e">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

bpf: Fix overloading of MEM_UNINIT's meaning

Lonial reported an issue in the BPF verifier where check_mem_size_reg()
has the following code:

    if (!tnum_is_const(reg->var_off))
        /* For unprivileged variable accesses, disable raw
         * mode so that the program is required to
         * initialize all the memory that the helper could
         * just partially fill up.
         */
         meta = NULL;

This means that writes are not checked when the register containing the
size of the passed buffer has not a fixed size. Through this bug, a BPF
program can write to a map which is marked as read-only, for example,
.rodata global maps.

The problem is that MEM_UNINIT's initial meaning that "the passed buffer
to the BPF helper does not need to be initialized" which was added back
in commit 435faee1aae9 ("bpf, verifier: add ARG_PTR_TO_RAW_STACK type")
got overloaded over time with "the passed buffer is being written to".

The problem however is that checks such as the above which were added later
via 06c1c049721a ("bpf: allow helpers access to variable memory") set meta
to NULL in order force the user to always initialize the passed buffer to
the helper. Due to the current double meaning of MEM_UNINIT, this bypasses
verifier write checks to the memory (not boundary checks though) and only
assumes the latter memory is read instead.

Fix this by reverting MEM_UNINIT back to its original meaning, and having
MEM_WRITE as an annotation to BPF helpers in order to then trigger the
BPF verifier checks for writing to memory.

Some notes: check_arg_pair_ok() ensures that for ARG_CONST_SIZE{,_OR_ZERO}
we can access fn->arg_type[arg - 1] since it must contain a preceding
ARG_PTR_TO_MEM. For check_mem_reg() the meta argument can be removed
altogether since we do check both BPF_READ and BPF_WRITE. Same for the
equivalent check_kfunc_mem_size_reg().</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('ebd026b5a0ef4ba174d7ffc2b39f2cfc4c05779e')">
                                    <div class="issue-number">92</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="ebd026b5a0ef4ba174d7ffc2b39f2cfc4c05779e">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

btrfs: fix use-after-free of block device file in __btrfs_free_extra_devids()

Mounting btrfs from two images (which have the same one fsid and two
different dev_uuids) in certain executing order may trigger an UAF for
variable 'device->bdev_file' in __btrfs_free_extra_devids(). And
following are the details:

1. Attach image_1 to loop0, attach image_2 to loop1, and scan btrfs
   devices by ioctl(BTRFS_IOC_SCAN_DEV):

             /  btrfs_device_1 → loop0
   fs_device
             \  btrfs_device_2 → loop1
2. mount /dev/loop0 /mnt
   btrfs_open_devices
    btrfs_device_1->bdev_file = btrfs_get_bdev_and_sb(loop0)
    btrfs_device_2->bdev_file = btrfs_get_bdev_and_sb(loop1)
   btrfs_fill_super
    open_ctree
     fail: btrfs_close_devices // -ENOMEM
	    btrfs_close_bdev(btrfs_device_1)
             fput(btrfs_device_1->bdev_file)
	      // btrfs_device_1->bdev_file is freed
	    btrfs_close_bdev(btrfs_device_2)
             fput(btrfs_device_2->bdev_file)

3. mount /dev/loop1 /mnt
   btrfs_open_devices
    btrfs_get_bdev_and_sb(&bdev_file)
     // EIO, btrfs_device_1->bdev_file is not assigned,
     // which points to a freed memory area
    btrfs_device_2->bdev_file = btrfs_get_bdev_and_sb(loop1)
   btrfs_fill_super
    open_ctree
     btrfs_free_extra_devids
      if (btrfs_device_1->bdev_file)
       fput(btrfs_device_1->bdev_file) // UAF !

Fix it by setting 'device->bdev_file' as 'NULL' after closing the
btrfs_device in btrfs_close_one_device().</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('1f288a0a84949bd4be50a392e3923b7cca286bbf')">
                                    <div class="issue-number">93</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="1f288a0a84949bd4be50a392e3923b7cca286bbf">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

cxl/port: Fix use-after-free, permit out-of-order decoder shutdown

In support of investigating an initialization failure report [1],
cxl_test was updated to register mock memory-devices after the mock
root-port/bus device had been registered. That led to cxl_test crashing
with a use-after-free bug with the following signature:

    cxl_port_attach_region: cxl region3: cxl_host_bridge.0:port3 decoder3.0 add: mem0:decoder7.0 @ 0 next: cxl_switch_uport.0 nr_eps: 1 nr_targets: 1
    cxl_port_attach_region: cxl region3: cxl_host_bridge.0:port3 decoder3.0 add: mem4:decoder14.0 @ 1 next: cxl_switch_uport.0 nr_eps: 2 nr_targets: 1
    cxl_port_setup_targets: cxl region3: cxl_switch_uport.0:port6 target[0] = cxl_switch_dport.0 for mem0:decoder7.0 @ 0
1)  cxl_port_setup_targets: cxl region3: cxl_switch_uport.0:port6 target[1] = cxl_switch_dport.4 for mem4:decoder14.0 @ 1
    [..]
    cxld_unregister: cxl decoder14.0:
    cxl_region_decode_reset: cxl_region region3:
    mock_decoder_reset: cxl_port port3: decoder3.0 reset
2)  mock_decoder_reset: cxl_port port3: decoder3.0: out of order reset, expected decoder3.1
    cxl_endpoint_decoder_release: cxl decoder14.0:
    [..]
    cxld_unregister: cxl decoder7.0:
3)  cxl_region_decode_reset: cxl_region region3:
    Oops: general protection fault, probably for non-canonical address 0x6b6b6b6b6b6b6bc3: 0000 [#1] PREEMPT SMP PTI
    [..]
    RIP: 0010:to_cxl_port+0x8/0x60 [cxl_core]
    [..]
    Call Trace:
     <TASK>
     cxl_region_decode_reset+0x69/0x190 [cxl_core]
     cxl_region_detach+0xe8/0x210 [cxl_core]
     cxl_decoder_kill_region+0x27/0x40 [cxl_core]
     cxld_unregister+0x5d/0x60 [cxl_core]

At 1) a region has been established with 2 endpoint decoders (7.0 and
14.0). Those endpoints share a common switch-decoder in the topology
(3.0). At teardown, 2), decoder14.0 is the first to be removed and hits
the "out of order reset case" in the switch decoder. The effect though
is that region3 cleanup is aborted leaving it in-tact and
referencing decoder14.0. At 3) the second attempt to teardown region3
trips over the stale decoder14.0 object which has long since been
deleted.

The fix here is to recognize that the CXL specification places no
mandate on in-order shutdown of switch-decoders, the driver enforces
in-order allocation, and hardware enforces in-order commit. So, rather
than fail and leave objects dangling, always remove them.

In support of making cxl_region_decode_reset() always succeed,
cxl_region_invalidate_memregion() failures are turned into warnings.
Crashing the kernel is ok there since system integrity is at risk if
caches cannot be managed around physical address mutation events like
CXL region destruction.

A new device_for_each_child_reverse_from() is added to cleanup
port->commit_end after all dependent decoders have been disabled. In
other words if decoders are allocated 0->1->2 and disabled 1->2->0 then
port->commit_end only decrements from 2 after 2 has been disabled, and
it decrements all the way to zero since 1 was disabled previously.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('d478467e50c7e764c72ac456805da05d0b71ea3f')">
                                    <div class="issue-number">94</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="d478467e50c7e764c72ac456805da05d0b71ea3f">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

fs/ntfs3: Add rough attr alloc_size check</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('9bd3315348a62698662ca8110ea538eecfd059ad')">
                                    <div class="issue-number">95</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="9bd3315348a62698662ca8110ea538eecfd059ad">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

arm64/sve: Discard stale CPU state when handling SVE traps

The logic for handling SVE traps manipulates saved FPSIMD/SVE state
incorrectly, and a race with preemption can result in a task having
TIF_SVE set and TIF_FOREIGN_FPSTATE clear even though the live CPU state
is stale (e.g. with SVE traps enabled). This has been observed to result
in warnings from do_sve_acc() where SVE traps are not expected while
TIF_SVE is set:

|         if (test_and_set_thread_flag(TIF_SVE))
|                 WARN_ON(1); /* SVE access shouldn't have trapped */

Warnings of this form have been reported intermittently, e.g.

  https://lore.kernel.org/linux-arm-kernel/CA+G9fYtEGe_DhY2Ms7+L7NKsLYUomGsgqpdBj+QwDLeSg=JhGg@mail.gmail.com/
  https://lore.kernel.org/linux-arm-kernel/000000000000511e9a060ce5a45c@google.com/

The race can occur when the SVE trap handler is preempted before and
after manipulating the saved FPSIMD/SVE state, starting and ending on
the same CPU, e.g.

| void do_sve_acc(unsigned long esr, struct pt_regs *regs)
| {
|         // Trap on CPU 0 with TIF_SVE clear, SVE traps enabled
|         // task->fpsimd_cpu is 0.
|         // per_cpu_ptr(&fpsimd_last_state, 0) is task.
|
|         ...
|
|         // Preempted; migrated from CPU 0 to CPU 1.
|         // TIF_FOREIGN_FPSTATE is set.
|
|         get_cpu_fpsimd_context();
|
|         if (test_and_set_thread_flag(TIF_SVE))
|                 WARN_ON(1); /* SVE access shouldn't have trapped */
|
|         sve_init_regs() {
|                 if (!test_thread_flag(TIF_FOREIGN_FPSTATE)) {
|                         ...
|                 } else {
|                         fpsimd_to_sve(current);
|                         current->thread.fp_type = FP_STATE_SVE;
|                 }
|         }
|
|         put_cpu_fpsimd_context();
|
|         // Preempted; migrated from CPU 1 to CPU 0.
|         // task->fpsimd_cpu is still 0
|         // If per_cpu_ptr(&fpsimd_last_state, 0) is still task then:
|         // - Stale HW state is reused (with SVE traps enabled)
|         // - TIF_FOREIGN_FPSTATE is cleared
|         // - A return to userspace skips HW state restore
| }

Fix the case where the state is not live and TIF_FOREIGN_FPSTATE is set
by calling fpsimd_flush_task_state() to detach from the saved CPU
state. This ensures that a subsequent context switch will not reuse the
stale CPU state, and will instead set TIF_FOREIGN_FPSTATE, forcing the
new state to be reloaded from memory prior to a return to userspace.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('9ff52a8f1d1570e48466adb6d01b30d762a0def9')">
                                    <div class="issue-number">96</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="9ff52a8f1d1570e48466adb6d01b30d762a0def9">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

firmware: arm_scmi: Fix slab-use-after-free in scmi_bus_notifier()

The scmi_dev->name is released prematurely in __scmi_device_destroy(),
which causes slab-use-after-free when accessing scmi_dev->name in
scmi_bus_notifier(). So move the release of scmi_dev->name to
scmi_device_release() to avoid slab-use-after-free.

  |  BUG: KASAN: slab-use-after-free in strncmp+0xe4/0xec
  |  Read of size 1 at addr ffffff80a482bcc0 by task swapper/0/1
  |
  |  CPU: 1 PID: 1 Comm: swapper/0 Not tainted 6.6.38-debug #1
  |  Hardware name: Qualcomm Technologies, Inc. SA8775P Ride (DT)
  |  Call trace:
  |   dump_backtrace+0x94/0x114
  |   show_stack+0x18/0x24
  |   dump_stack_lvl+0x48/0x60
  |   print_report+0xf4/0x5b0
  |   kasan_report+0xa4/0xec
  |   __asan_report_load1_noabort+0x20/0x2c
  |   strncmp+0xe4/0xec
  |   scmi_bus_notifier+0x5c/0x54c
  |   notifier_call_chain+0xb4/0x31c
  |   blocking_notifier_call_chain+0x68/0x9c
  |   bus_notify+0x54/0x78
  |   device_del+0x1bc/0x840
  |   device_unregister+0x20/0xb4
  |   __scmi_device_destroy+0xac/0x280
  |   scmi_device_destroy+0x94/0xd0
  |   scmi_chan_setup+0x524/0x750
  |   scmi_probe+0x7fc/0x1508
  |   platform_probe+0xc4/0x19c
  |   really_probe+0x32c/0x99c
  |   __driver_probe_device+0x15c/0x3c4
  |   driver_probe_device+0x5c/0x170
  |   __driver_attach+0x1c8/0x440
  |   bus_for_each_dev+0xf4/0x178
  |   driver_attach+0x3c/0x58
  |   bus_add_driver+0x234/0x4d4
  |   driver_register+0xf4/0x3c0
  |   __platform_driver_register+0x60/0x88
  |   scmi_driver_init+0xb0/0x104
  |   do_one_initcall+0xb4/0x664
  |   kernel_init_freeable+0x3c8/0x894
  |   kernel_init+0x24/0x1e8
  |   ret_from_fork+0x10/0x20
  |
  |  Allocated by task 1:
  |   kasan_save_stack+0x2c/0x54
  |   kasan_set_track+0x2c/0x40
  |   kasan_save_alloc_info+0x24/0x34
  |   __kasan_kmalloc+0xa0/0xb8
  |   __kmalloc_node_track_caller+0x6c/0x104
  |   kstrdup+0x48/0x84
  |   kstrdup_const+0x34/0x40
  |   __scmi_device_create.part.0+0x8c/0x408
  |   scmi_device_create+0x104/0x370
  |   scmi_chan_setup+0x2a0/0x750
  |   scmi_probe+0x7fc/0x1508
  |   platform_probe+0xc4/0x19c
  |   really_probe+0x32c/0x99c
  |   __driver_probe_device+0x15c/0x3c4
  |   driver_probe_device+0x5c/0x170
  |   __driver_attach+0x1c8/0x440
  |   bus_for_each_dev+0xf4/0x178
  |   driver_attach+0x3c/0x58
  |   bus_add_driver+0x234/0x4d4
  |   driver_register+0xf4/0x3c0
  |   __platform_driver_register+0x60/0x88
  |   scmi_driver_init+0xb0/0x104
  |   do_one_initcall+0xb4/0x664
  |   kernel_init_freeable+0x3c8/0x894
  |   kernel_init+0x24/0x1e8
  |   ret_from_fork+0x10/0x20
  |
  |  Freed by task 1:
  |   kasan_save_stack+0x2c/0x54
  |   kasan_set_track+0x2c/0x40
  |   kasan_save_free_info+0x38/0x5c
  |   __kasan_slab_free+0xe8/0x164
  |   __kmem_cache_free+0x11c/0x230
  |   kfree+0x70/0x130
  |   kfree_const+0x20/0x40
  |   __scmi_device_destroy+0x70/0x280
  |   scmi_device_destroy+0x94/0xd0
  |   scmi_chan_setup+0x524/0x750
  |   scmi_probe+0x7fc/0x1508
  |   platform_probe+0xc4/0x19c
  |   really_probe+0x32c/0x99c
  |   __driver_probe_device+0x15c/0x3c4
  |   driver_probe_device+0x5c/0x170
  |   __driver_attach+0x1c8/0x440
  |   bus_for_each_dev+0xf4/0x178
  |   driver_attach+0x3c/0x58
  |   bus_add_driver+0x234/0x4d4
  |   driver_register+0xf4/0x3c0
  |   __platform_driver_register+0x60/0x88
  |   scmi_driver_init+0xb0/0x104
  |   do_one_initcall+0xb4/0x664
  |   kernel_init_freeable+0x3c8/0x894
  |   kernel_init+0x24/0x1e8
  |   ret_from_fork+0x10/0x20</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('864192fff84f21b640303c197c504ff81ef7b696')">
                                    <div class="issue-number">97</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="864192fff84f21b640303c197c504ff81ef7b696">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

hv_sock: Initializing vsk->trans to NULL to prevent a dangling pointer

When hvs is released, there is a possibility that vsk->trans may not
be initialized to NULL, which could lead to a dangling pointer.
This issue is resolved by initializing vsk->trans to NULL.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('2163e130d2dacded6076bbb62920560e242cdccc')">
                                    <div class="issue-number">98</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="2163e130d2dacded6076bbb62920560e242cdccc">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> CPAN.pm before 2.35 does not verify TLS certificates when downloading distributions over HTTPS.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('8f6d744a65dd03e3ad90d28b8ada8c33a234a688')">
                                    <div class="issue-number">99</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="8f6d744a65dd03e3ad90d28b8ada8c33a234a688">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> CPAN.pm before 2.35 does not verify TLS certificates when downloading distributions over HTTPS.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('d33d3d5adb1f5b3f8765ef572e24e0d6fa8491cd')">
                                    <div class="issue-number">100</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="d33d3d5adb1f5b3f8765ef572e24e0d6fa8491cd">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> CPAN.pm before 2.35 does not verify TLS certificates when downloading distributions over HTTPS.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('1efbddc14b900dc8363384174c7b2c7d7701de69')">
                                    <div class="issue-number">101</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="1efbddc14b900dc8363384174c7b2c7d7701de69">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> There is a LOW severity vulnerability affecting CPython, specifically the
'http.cookies' standard library module.


When parsing cookies that contained backslashes for quoted characters in
the cookie value, the parser would use an algorithm with quadratic
complexity, resulting in excess CPU resources being used while parsing the
value.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-high"
                                     onclick="toggleDetail('96e783e81e6377ab432a76aecafc8692bc10e1d8')">
                                    <div class="issue-number">102</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="96e783e81e6377ab432a76aecafc8692bc10e1d8">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> High</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> There is a LOW severity vulnerability affecting CPython, specifically the
'http.cookies' standard library module.


When parsing cookies that contained backslashes for quoted characters in
the cookie value, the parser would use an algorithm with quadratic
complexity, resulting in excess CPU resources being used while parsing the
value.</p>
                                </div>
                            </li>
                        
                    </ul>
                
            
                
                    <h3>Medium 风险漏洞（共449个）：</h3>
                    <ul>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('1b8d72d336d9f010b55c14941b6ba8943384b813')">
                                    <div class="issue-number">1</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="1b8d72d336d9f010b55c14941b6ba8943384b813">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> When curl is asked to use HSTS, the expiry time for a subdomain might
overwrite a parent domain's cache entry, making it end sooner or later than
otherwise intended.

This affects curl using applications that enable HSTS and use URLs with the
insecure `HTTP://` scheme and perform transfers with hosts like
`x.example.com` as well as `example.com` where the first host is a subdomain
of the second host.

(The HSTS cache either needs to have been populated manually or there needs to
have been previous HTTPS accesses done as the cache needs to have entries for
the domains involved to trigger this problem.)

When `x.example.com` responds with `Strict-Transport-Security:` headers, this
bug can make the subdomain's expiry timeout *bleed over* and get set for the
parent domain `example.com` in curl's HSTS cache.

The result of a triggered bug is that HTTP accesses to `example.com` get
converted to HTTPS for a different period of time than what was asked for by
the origin server. If `example.com` for example stops supporting HTTPS at its
expiry time, curl might then fail to access `http://example.com` until the
(wrongly set) timeout expires. This bug can also expire the parent's entry
*earlier*, thus making curl inadvertently switch back to insecure HTTP earlier
than otherwise intended.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('374abe5670e45de4e3f87ef099353ff1292d34e5')">
                                    <div class="issue-number">2</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="374abe5670e45de4e3f87ef099353ff1292d34e5">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> BlueZ Audio Profile AVRCP avrcp_parse_attribute_list Out-Of-Bounds Read Information Disclosure Vulnerability. This vulnerability allows network-adjacent attackers to disclose sensitive information via Bluetooth on affected installations of BlueZ. User interaction is required to exploit this vulnerability in that the target must connect to a malicious device.

The specific flaw exists within the handling of the AVRCP protocol. The issue results from the lack of proper validation of user-supplied data, which can result in a read past the end of an allocated buffer. An attacker can leverage this in conjunction with other vulnerabilities to execute arbitrary code in the context of root. Was ZDI-CAN-20852.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('f3cb1cab97ddf3682ff28058de0df207198067a8')">
                                    <div class="issue-number">3</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="f3cb1cab97ddf3682ff28058de0df207198067a8">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> BlueZ Audio Profile AVRCP parse_media_element Out-Of-Bounds Read Information Disclosure Vulnerability. This vulnerability allows network-adjacent attackers to disclose sensitive information via Bluetooth on affected installations of BlueZ. User interaction is required to exploit this vulnerability in that the target must connect to a malicious device.

The specific flaw exists within the handling of the AVRCP protocol. The issue results from the lack of proper validation of user-supplied data, which can result in a read past the end of an allocated buffer. An attacker can leverage this in conjunction with other vulnerabilities to execute arbitrary code in the context of root. Was ZDI-CAN-20853.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('545a83984797cb976973769995ab78e061d0f594')">
                                    <div class="issue-number">4</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="545a83984797cb976973769995ab78e061d0f594">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> BlueZ Audio Profile AVRCP parse_media_folder Out-Of-Bounds Read Information Disclosure Vulnerability. This vulnerability allows network-adjacent attackers to disclose sensitive information via Bluetooth on affected installations of BlueZ. User interaction is required to exploit this vulnerability in that the target must connect to a malicious device.

The specific flaw exists within the handling of the AVRCP protocol. The issue results from the lack of proper validation of user-supplied data, which can result in a read past the end of an allocated buffer. An attacker can leverage this in conjunction with other vulnerabilities to execute arbitrary code in the context of root. Was ZDI-CAN-20854.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('d2633033607a2b83a40d6b2b2d874bc9998d82a4')">
                                    <div class="issue-number">5</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="d2633033607a2b83a40d6b2b2d874bc9998d82a4">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> BlueZ Audio Profile AVRCP avrcp_parse_attribute_list Out-Of-Bounds Read Information Disclosure Vulnerability. This vulnerability allows network-adjacent attackers to disclose sensitive information via Bluetooth on affected installations of BlueZ. User interaction is required to exploit this vulnerability in that the target must connect to a malicious device.

The specific flaw exists within the handling of the AVRCP protocol. The issue results from the lack of proper validation of user-supplied data, which can result in a read past the end of an allocated buffer. An attacker can leverage this in conjunction with other vulnerabilities to execute arbitrary code in the context of root. Was ZDI-CAN-20852.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('74ca9cb366b0e8eb83a7a2a86ee72c9a4d1c1f53')">
                                    <div class="issue-number">6</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="74ca9cb366b0e8eb83a7a2a86ee72c9a4d1c1f53">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> BlueZ Audio Profile AVRCP parse_media_element Out-Of-Bounds Read Information Disclosure Vulnerability. This vulnerability allows network-adjacent attackers to disclose sensitive information via Bluetooth on affected installations of BlueZ. User interaction is required to exploit this vulnerability in that the target must connect to a malicious device.

The specific flaw exists within the handling of the AVRCP protocol. The issue results from the lack of proper validation of user-supplied data, which can result in a read past the end of an allocated buffer. An attacker can leverage this in conjunction with other vulnerabilities to execute arbitrary code in the context of root. Was ZDI-CAN-20853.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('aacfb776893edf03c238fbe8b327f3af9dbee622')">
                                    <div class="issue-number">7</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="aacfb776893edf03c238fbe8b327f3af9dbee622">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> BlueZ Audio Profile AVRCP parse_media_folder Out-Of-Bounds Read Information Disclosure Vulnerability. This vulnerability allows network-adjacent attackers to disclose sensitive information via Bluetooth on affected installations of BlueZ. User interaction is required to exploit this vulnerability in that the target must connect to a malicious device.

The specific flaw exists within the handling of the AVRCP protocol. The issue results from the lack of proper validation of user-supplied data, which can result in a read past the end of an allocated buffer. An attacker can leverage this in conjunction with other vulnerabilities to execute arbitrary code in the context of root. Was ZDI-CAN-20854.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('59eaa3ebc6a068b3e5f1f1719f71e028afa44543')">
                                    <div class="issue-number">8</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="59eaa3ebc6a068b3e5f1f1719f71e028afa44543">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> When curl is asked to use HSTS, the expiry time for a subdomain might
overwrite a parent domain's cache entry, making it end sooner or later than
otherwise intended.

This affects curl using applications that enable HSTS and use URLs with the
insecure `HTTP://` scheme and perform transfers with hosts like
`x.example.com` as well as `example.com` where the first host is a subdomain
of the second host.

(The HSTS cache either needs to have been populated manually or there needs to
have been previous HTTPS accesses done as the cache needs to have entries for
the domains involved to trigger this problem.)

When `x.example.com` responds with `Strict-Transport-Security:` headers, this
bug can make the subdomain's expiry timeout *bleed over* and get set for the
parent domain `example.com` in curl's HSTS cache.

The result of a triggered bug is that HTTP accesses to `example.com` get
converted to HTTPS for a different period of time than what was asked for by
the origin server. If `example.com` for example stops supporting HTTPS at its
expiry time, curl might then fail to access `http://example.com` until the
(wrongly set) timeout expires. This bug can also expire the parent's entry
*earlier*, thus making curl inadvertently switch back to insecure HTTP earlier
than otherwise intended.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('dc043018d7686a31dfa6be89f68330317e8589cf')">
                                    <div class="issue-number">9</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="dc043018d7686a31dfa6be89f68330317e8589cf">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> When curl is asked to use HSTS, the expiry time for a subdomain might
overwrite a parent domain's cache entry, making it end sooner or later than
otherwise intended.

This affects curl using applications that enable HSTS and use URLs with the
insecure `HTTP://` scheme and perform transfers with hosts like
`x.example.com` as well as `example.com` where the first host is a subdomain
of the second host.

(The HSTS cache either needs to have been populated manually or there needs to
have been previous HTTPS accesses done as the cache needs to have entries for
the domains involved to trigger this problem.)

When `x.example.com` responds with `Strict-Transport-Security:` headers, this
bug can make the subdomain's expiry timeout *bleed over* and get set for the
parent domain `example.com` in curl's HSTS cache.

The result of a triggered bug is that HTTP accesses to `example.com` get
converted to HTTPS for a different period of time than what was asked for by
the origin server. If `example.com` for example stops supporting HTTPS at its
expiry time, curl might then fail to access `http://example.com` until the
(wrongly set) timeout expires. This bug can also expire the parent's entry
*earlier*, thus making curl inadvertently switch back to insecure HTTP earlier
than otherwise intended.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('bc93f8d16942c8f67793b544001961e3d3eeed1e')">
                                    <div class="issue-number">10</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="bc93f8d16942c8f67793b544001961e3d3eeed1e">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> When curl is asked to use HSTS, the expiry time for a subdomain might
overwrite a parent domain's cache entry, making it end sooner or later than
otherwise intended.

This affects curl using applications that enable HSTS and use URLs with the
insecure `HTTP://` scheme and perform transfers with hosts like
`x.example.com` as well as `example.com` where the first host is a subdomain
of the second host.

(The HSTS cache either needs to have been populated manually or there needs to
have been previous HTTPS accesses done as the cache needs to have entries for
the domains involved to trigger this problem.)

When `x.example.com` responds with `Strict-Transport-Security:` headers, this
bug can make the subdomain's expiry timeout *bleed over* and get set for the
parent domain `example.com` in curl's HSTS cache.

The result of a triggered bug is that HTTP accesses to `example.com` get
converted to HTTPS for a different period of time than what was asked for by
the origin server. If `example.com` for example stops supporting HTTPS at its
expiry time, curl might then fail to access `http://example.com` until the
(wrongly set) timeout expires. This bug can also expire the parent's entry
*earlier*, thus making curl inadvertently switch back to insecure HTTP earlier
than otherwise intended.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('240d147767a87cd6e216730c737b6cb843a16bcb')">
                                    <div class="issue-number">11</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="240d147767a87cd6e216730c737b6cb843a16bcb">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> VideoLAN dav1d before 1.2.0 has a thread_task.c race condition that can lead to an application crash, related to dav1d_decode_frame_exit.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('d2973a8b5a32f906af91b3a6873898ebe5e2eb6f')">
                                    <div class="issue-number">12</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="d2973a8b5a32f906af91b3a6873898ebe5e2eb6f">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Buffer Overflow vulnerability in libde265 v1.0.12 allows a local attacker to cause a denial of service via the allocation size exceeding the maximum supported size of 0x10000000000.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('5799ce92fcbec660fca9d5356a5f6ea86d567c07')">
                                    <div class="issue-number">13</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="5799ce92fcbec660fca9d5356a5f6ea86d567c07">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Heap Buffer Overflow vulnerability in Libde265 v1.0.15 allows attackers to crash the application via crafted payload to display444as420 function at sdl.cc</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('4a473c12933b60068d9b88bfdb6f66efe31206da')">
                                    <div class="issue-number">14</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="4a473c12933b60068d9b88bfdb6f66efe31206da">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Heap Buffer Overflow vulnerability in Libde265 v1.0.15 allows attackers to crash the application via crafted payload to __interceptor_memcpy function.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('35bf271e3a5249dc408fcac0e7e1e5cd55d4e5fa')">
                                    <div class="issue-number">15</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="35bf271e3a5249dc408fcac0e7e1e5cd55d4e5fa">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered IW44Image.cpp in djvulibre 3.5.28 in allows attackers to cause a denial of service via divide by zero.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('dbaccbacb71d17758ef1a16d0a4d8529fed5d839')">
                                    <div class="issue-number">16</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="dbaccbacb71d17758ef1a16d0a4d8529fed5d839">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered IW44EncodeCodec.cpp in djvulibre 3.5.28 in allows attackers to cause a denial of service via divide by zero.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('647b99b61d3562cd5913ef587dfed94ffb585fdb')">
                                    <div class="issue-number">17</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="647b99b61d3562cd5913ef587dfed94ffb585fdb">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered IW44Image.cpp in djvulibre 3.5.28 in allows attackers to cause a denial of service via divide by zero.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('80d1f8ca5ad825e0f3684322edb6450bee3eb99d')">
                                    <div class="issue-number">18</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="80d1f8ca5ad825e0f3684322edb6450bee3eb99d">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered IW44EncodeCodec.cpp in djvulibre 3.5.28 in allows attackers to cause a denial of service via divide by zero.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('7981d3a54a1c72ffe4181dd0afd7cd3e190cb7bb')">
                                    <div class="issue-number">19</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="7981d3a54a1c72ffe4181dd0afd7cd3e190cb7bb">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered IW44Image.cpp in djvulibre 3.5.28 in allows attackers to cause a denial of service via divide by zero.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('5cc3992cadf28e0993ee202d66dfc5fb0c9c0687')">
                                    <div class="issue-number">20</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="5cc3992cadf28e0993ee202d66dfc5fb0c9c0687">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered IW44EncodeCodec.cpp in djvulibre 3.5.28 in allows attackers to cause a denial of service via divide by zero.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('76222995a746f6fec1cfdb62fb907117736268a4')">
                                    <div class="issue-number">21</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="76222995a746f6fec1cfdb62fb907117736268a4">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in libexpat before 2.6.4. There is a crash within the XML_ResumeParser function because XML_StopParser can stop/suspend an unstarted parser.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('5779d55ae2bba33eef30fe05afbe83016af428af')">
                                    <div class="issue-number">22</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="5779d55ae2bba33eef30fe05afbe83016af428af">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in libexpat before 2.6.4. There is a crash within the XML_ResumeParser function because XML_StopParser can stop/suspend an unstarted parser.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('3197e28ab8de033c1a2eb6ba7a5042303f8aee15')">
                                    <div class="issue-number">23</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="3197e28ab8de033c1a2eb6ba7a5042303f8aee15">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A timing-based side-channel flaw was found in libgcrypt's RSA implementation. This issue may allow a remote attacker to initiate a Bleichenbacher-style attack, which can lead to the decryption of RSA ciphertexts.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('6da1bf8d0d2776049d90c4ab0ec8ec6698725329')">
                                    <div class="issue-number">24</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="6da1bf8d0d2776049d90c4ab0ec8ec6698725329">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Vulnerability in the MySQL Server product of Oracle MySQL (component: Client: mysqldump).  Supported versions that are affected are 8.0.36 and prior and  8.3.0 and prior. Difficult to exploit vulnerability allows unauthenticated attacker with logon to the infrastructure where MySQL Server executes to compromise MySQL Server.  Successful attacks of this vulnerability can result in  unauthorized update, insert or delete access to some of MySQL Server accessible data as well as  unauthorized read access to a subset of MySQL Server accessible data and unauthorized ability to cause a partial denial of service (partial DOS) of MySQL Server. CVSS 3.1 Base Score 4.9 (Confidentiality, Integrity and Availability impacts).  CVSS Vector: (CVSS:3.1/AV:L/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:L).</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('92ce2caef14379dc4bc46887b424351846074e55')">
                                    <div class="issue-number">25</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="92ce2caef14379dc4bc46887b424351846074e55">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Vulnerability in the MySQL Server product of Oracle MySQL (component: Client: mysqldump).  Supported versions that are affected are 8.0.36 and prior and  8.3.0 and prior. Difficult to exploit vulnerability allows unauthenticated attacker with logon to the infrastructure where MySQL Server executes to compromise MySQL Server.  Successful attacks of this vulnerability can result in  unauthorized update, insert or delete access to some of MySQL Server accessible data as well as  unauthorized read access to a subset of MySQL Server accessible data and unauthorized ability to cause a partial denial of service (partial DOS) of MySQL Server. CVSS 3.1 Base Score 4.9 (Confidentiality, Integrity and Availability impacts).  CVSS Vector: (CVSS:3.1/AV:L/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:L).</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('5a6fed544fb0378353fa90c7d7c81f6cb34d7b5e')">
                                    <div class="issue-number">26</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="5a6fed544fb0378353fa90c7d7c81f6cb34d7b5e">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Vulnerability in the MySQL Server product of Oracle MySQL (component: Client: mysqldump).  Supported versions that are affected are 8.0.36 and prior and  8.3.0 and prior. Difficult to exploit vulnerability allows unauthenticated attacker with logon to the infrastructure where MySQL Server executes to compromise MySQL Server.  Successful attacks of this vulnerability can result in  unauthorized update, insert or delete access to some of MySQL Server accessible data as well as  unauthorized read access to a subset of MySQL Server accessible data and unauthorized ability to cause a partial denial of service (partial DOS) of MySQL Server. CVSS 3.1 Base Score 4.9 (Confidentiality, Integrity and Availability impacts).  CVSS Vector: (CVSS:3.1/AV:L/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:L).</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('7760d0556819ef0e0431f25e3119545847b3a05e')">
                                    <div class="issue-number">27</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="7760d0556819ef0e0431f25e3119545847b3a05e">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> NCurse v6.4-20230418 was discovered to contain a segmentation fault via the component _nc_wrap_entry().</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('ab1a43a8e87f0346ce6f7e00f37d185acfa18bcf')">
                                    <div class="issue-number">28</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="ab1a43a8e87f0346ce6f7e00f37d185acfa18bcf">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> NCurse v6.4-20230418 was discovered to contain a segmentation fault via the component _nc_wrap_entry().</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('c1586765bbc53d9ca01acc831ce457988784c2da')">
                                    <div class="issue-number">29</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="c1586765bbc53d9ca01acc831ce457988784c2da">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> NCurse v6.4-20230418 was discovered to contain a segmentation fault via the component _nc_wrap_entry().</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('1e3a4e2c1facb41a70d7b26a25d061145c7604fb')">
                                    <div class="issue-number">30</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="1e3a4e2c1facb41a70d7b26a25d061145c7604fb">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> NCurse v6.4-20230418 was discovered to contain a segmentation fault via the component _nc_wrap_entry().</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('7accf8ddc22b8425f282cf8303e70210cb4f40e5')">
                                    <div class="issue-number">31</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="7accf8ddc22b8425f282cf8303e70210cb4f40e5">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> NCurse v6.4-20230418 was discovered to contain a segmentation fault via the component _nc_wrap_entry().</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('b30d3ee7adaebfa013b1d36e558e0560bdfc16d3')">
                                    <div class="issue-number">32</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="b30d3ee7adaebfa013b1d36e558e0560bdfc16d3">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A flaw was found in OpenJPEG. Maliciously constructed pictures can cause the program to enter a large loop and continuously print warning messages on the terminal.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('99fc7a09fbc6266dae1e4365c1222729a8e71950')">
                                    <div class="issue-number">33</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="99fc7a09fbc6266dae1e4365c1222729a8e71950">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A vulnerability was found in OpenJPEG similar to CVE-2019-6988. This flaw allows an attacker to bypass existing protections and cause an application crash through a maliciously crafted file.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('c021f8c2abc457e4c5954b66d3b6597f8d0f34da')">
                                    <div class="issue-number">34</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="c021f8c2abc457e4c5954b66d3b6597f8d0f34da">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A flaw was found in OpenJPEG. A resource exhaustion can occur in the opj_t1_decode_cblks function in tcd.c through a crafted image file, causing a denial of service.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('4a7b474f79e2a26bbbcade035a9464c8406c682f')">
                                    <div class="issue-number">35</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="4a7b474f79e2a26bbbcade035a9464c8406c682f">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A flaw was found in OpenJPEG. Maliciously constructed pictures can cause the program to enter a large loop and continuously print warning messages on the terminal.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('3a6917b1b5648b9b56b076d96f0e4dcb1e7176b7')">
                                    <div class="issue-number">36</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="3a6917b1b5648b9b56b076d96f0e4dcb1e7176b7">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A vulnerability was found in OpenJPEG similar to CVE-2019-6988. This flaw allows an attacker to bypass existing protections and cause an application crash through a maliciously crafted file.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('dc56d7cc177e77179843aeb9c2299500a4d928e6')">
                                    <div class="issue-number">37</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="dc56d7cc177e77179843aeb9c2299500a4d928e6">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A flaw was found in OpenJPEG. A resource exhaustion can occur in the opj_t1_decode_cblks function in tcd.c through a crafted image file, causing a denial of service.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('108c3f281fc4b010a454580a2136360d76e8bfb9')">
                                    <div class="issue-number">38</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="108c3f281fc4b010a454580a2136360d76e8bfb9">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A vulnerability was found in PAM. The secret information is stored in memory, where the attacker can trigger the victim program to execute by sending characters to its standard input (stdin). As this occurs, the attacker can train the branch predictor to execute an ROP chain speculatively. This flaw could result in leaked passwords, such as those found in /etc/shadow while performing authentications.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('1c53575cbd75ad864581c43e07f9707372f9e1f0')">
                                    <div class="issue-number">39</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="1c53575cbd75ad864581c43e07f9707372f9e1f0">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> linux-pam (aka Linux PAM) before 1.6.0 allows attackers to cause a denial of service (blocked login process) via mkfifo because the openat call (for protect_dir) lacks O_DIRECTORY.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('74ccb41cf6d36ae5db290948e2520cf872361e62')">
                                    <div class="issue-number">40</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="74ccb41cf6d36ae5db290948e2520cf872361e62">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A vulnerability was found in PAM. The secret information is stored in memory, where the attacker can trigger the victim program to execute by sending characters to its standard input (stdin). As this occurs, the attacker can train the branch predictor to execute an ROP chain speculatively. This flaw could result in leaked passwords, such as those found in /etc/shadow while performing authentications.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('b486ff4c95d57ba0c57435a1d7745db681da253b')">
                                    <div class="issue-number">41</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="b486ff4c95d57ba0c57435a1d7745db681da253b">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> linux-pam (aka Linux PAM) before 1.6.0 allows attackers to cause a denial of service (blocked login process) via mkfifo because the openat call (for protect_dir) lacks O_DIRECTORY.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('d4ca50879964e6585b3cf9d895bf42522b3c8837')">
                                    <div class="issue-number">42</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="d4ca50879964e6585b3cf9d895bf42522b3c8837">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A vulnerability was found in PAM. The secret information is stored in memory, where the attacker can trigger the victim program to execute by sending characters to its standard input (stdin). As this occurs, the attacker can train the branch predictor to execute an ROP chain speculatively. This flaw could result in leaked passwords, such as those found in /etc/shadow while performing authentications.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('05213558ade10cde13a446a2f53efde02fca1c2f')">
                                    <div class="issue-number">43</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="05213558ade10cde13a446a2f53efde02fca1c2f">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> linux-pam (aka Linux PAM) before 1.6.0 allows attackers to cause a denial of service (blocked login process) via mkfifo because the openat call (for protect_dir) lacks O_DIRECTORY.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('3ab8b3b680a2c1877b4b6d94f16fbd7f0a64cce7')">
                                    <div class="issue-number">44</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="3ab8b3b680a2c1877b4b6d94f16fbd7f0a64cce7">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A vulnerability was found in PAM. The secret information is stored in memory, where the attacker can trigger the victim program to execute by sending characters to its standard input (stdin). As this occurs, the attacker can train the branch predictor to execute an ROP chain speculatively. This flaw could result in leaked passwords, such as those found in /etc/shadow while performing authentications.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('b41549ead809dcd47669500ed777b73c5f79024b')">
                                    <div class="issue-number">45</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="b41549ead809dcd47669500ed777b73c5f79024b">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> linux-pam (aka Linux PAM) before 1.6.0 allows attackers to cause a denial of service (blocked login process) via mkfifo because the openat call (for protect_dir) lacks O_DIRECTORY.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('7a8c7df1bcb6bbd5c8c5f7e5626bbecaa559cc64')">
                                    <div class="issue-number">46</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="7a8c7df1bcb6bbd5c8c5f7e5626bbecaa559cc64">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The email module of Python through 3.11.3 incorrectly parses e-mail addresses that contain a special character. The wrong portion of an RFC2822 header is identified as the value of the addr-spec. In some applications, an attacker can bypass a protection mechanism in which application access is granted only after verifying receipt of e-mail to a specific domain (e.g., only @company.example.com addresses may be used for signup). This occurs in email/_parseaddr.py in recent versions of Python.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('2f32f71375f6ac7876b9bdc7a27cb00d7f49df84')">
                                    <div class="issue-number">47</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="2f32f71375f6ac7876b9bdc7a27cb00d7f49df84">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> There is a MEDIUM severity vulnerability affecting CPython.

The 
email module didn’t properly quote newlines for email headers when 
serializing an email message allowing for header injection when an email
 is serialized.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('7a9411017f5c26a28b41737dc718a2602898ad14')">
                                    <div class="issue-number">48</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="7a9411017f5c26a28b41737dc718a2602898ad14">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A vulnerability has been found in the CPython `venv` module and CLI where path names provided when creating a virtual environment were not quoted properly, allowing the creator to inject commands into virtual environment "activation" scripts (ie "source venv/bin/activate"). This means that attacker-controlled virtual environments are able to run commands when the virtual environment is activated. Virtual environments which are not created by an attacker or which aren't activated before being used (ie "./venv/bin/python") are not affected.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('0c6d7f45e45c5d4d3892df1d0f26810a87e6902e')">
                                    <div class="issue-number">49</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="0c6d7f45e45c5d4d3892df1d0f26810a87e6902e">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The email module of Python through 3.11.3 incorrectly parses e-mail addresses that contain a special character. The wrong portion of an RFC2822 header is identified as the value of the addr-spec. In some applications, an attacker can bypass a protection mechanism in which application access is granted only after verifying receipt of e-mail to a specific domain (e.g., only @company.example.com addresses may be used for signup). This occurs in email/_parseaddr.py in recent versions of Python.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('237c6e965555de8e4f8f57545bb220404dccb2be')">
                                    <div class="issue-number">50</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="237c6e965555de8e4f8f57545bb220404dccb2be">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> There is a MEDIUM severity vulnerability affecting CPython.

The 
email module didn’t properly quote newlines for email headers when 
serializing an email message allowing for header injection when an email
 is serialized.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('d2fa0246edd4c46f11129b0ae3b2d7453ab22472')">
                                    <div class="issue-number">51</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="d2fa0246edd4c46f11129b0ae3b2d7453ab22472">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A vulnerability has been found in the CPython `venv` module and CLI where path names provided when creating a virtual environment were not quoted properly, allowing the creator to inject commands into virtual environment "activation" scripts (ie "source venv/bin/activate"). This means that attacker-controlled virtual environments are able to run commands when the virtual environment is activated. Virtual environments which are not created by an attacker or which aren't activated before being used (ie "./venv/bin/python") are not affected.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('75c4e19a9edbb29ce32c6db1e1c5669da1b6a9de')">
                                    <div class="issue-number">52</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="75c4e19a9edbb29ce32c6db1e1c5669da1b6a9de">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The email module of Python through 3.11.3 incorrectly parses e-mail addresses that contain a special character. The wrong portion of an RFC2822 header is identified as the value of the addr-spec. In some applications, an attacker can bypass a protection mechanism in which application access is granted only after verifying receipt of e-mail to a specific domain (e.g., only @company.example.com addresses may be used for signup). This occurs in email/_parseaddr.py in recent versions of Python.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('19289113a4a4810225ac738f0c4d9fe856b176af')">
                                    <div class="issue-number">53</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="19289113a4a4810225ac738f0c4d9fe856b176af">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> There is a MEDIUM severity vulnerability affecting CPython.

The 
email module didn’t properly quote newlines for email headers when 
serializing an email message allowing for header injection when an email
 is serialized.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('1d249dc2699de619028735c393e50d5b8af301fc')">
                                    <div class="issue-number">54</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="1d249dc2699de619028735c393e50d5b8af301fc">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A vulnerability has been found in the CPython `venv` module and CLI where path names provided when creating a virtual environment were not quoted properly, allowing the creator to inject commands into virtual environment "activation" scripts (ie "source venv/bin/activate"). This means that attacker-controlled virtual environments are able to run commands when the virtual environment is activated. Virtual environments which are not created by an attacker or which aren't activated before being used (ie "./venv/bin/python") are not affected.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('94660487808aac309316c9367c73d168790eabcb')">
                                    <div class="issue-number">55</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="94660487808aac309316c9367c73d168790eabcb">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> libtiff 4.5.0 is vulnerable to Buffer Overflow via /libtiff/tools/tiffcrop.c:8499. Incorrect updating of buffer size after rotateImage() in tiffcrop cause heap-buffer-overflow and SEGV.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('f685bd5749e95588eb5fd133b6c582612f7c5de0')">
                                    <div class="issue-number">56</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="f685bd5749e95588eb5fd133b6c582612f7c5de0">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> loadImage() in tools/tiffcrop.c in LibTIFF through 4.5.0 has a heap-based use after free via a crafted TIFF image.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('5126e4e454e8d32f3d8caded92f93b2b297180d7')">
                                    <div class="issue-number">57</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="5126e4e454e8d32f3d8caded92f93b2b297180d7">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> libtiff 4.5.0 is vulnerable to Buffer Overflow in uv_encode() when libtiff reads a corrupted little-endian TIFF file and specifies the output to be big-endian.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('3c0e403b51850201020d835b9c4142925c721ccc')">
                                    <div class="issue-number">58</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="3c0e403b51850201020d835b9c4142925c721ccc">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A null pointer dereference issue was found in Libtiff's tif_dir.c file. This issue may allow an attacker to pass a crafted TIFF image file to the tiffcp utility which triggers a runtime error that causes undefined behavior. This will result in an application crash, eventually leading to a denial of service.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('f6002f777c7411d5ea3f06ce0a793eae0ba4c4b5')">
                                    <div class="issue-number">59</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="f6002f777c7411d5ea3f06ce0a793eae0ba4c4b5">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A flaw was found in libtiff. A specially crafted tiff file can lead to a segmentation fault due to a buffer overflow in the Fax3Encode function in libtiff/tif_fax3.c, resulting in a denial of service.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('7204b1e238edeb9d775c855aab82cd15223a7025')">
                                    <div class="issue-number">60</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="7204b1e238edeb9d775c855aab82cd15223a7025">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An out-of-memory flaw was found in libtiff. Passing a crafted tiff file to TIFFOpen() API may allow a remote attacker to cause a denial of service via a craft input with size smaller than 379 KB.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('70ae2cf200baaf4db472e0b8751c1198bfc2d38e')">
                                    <div class="issue-number">61</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="70ae2cf200baaf4db472e0b8751c1198bfc2d38e">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> libtiff 4.5.0 is vulnerable to Buffer Overflow via /libtiff/tools/tiffcrop.c:8499. Incorrect updating of buffer size after rotateImage() in tiffcrop cause heap-buffer-overflow and SEGV.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('82786faa7bcf72356fc65ce5f1ce831efdcf240f')">
                                    <div class="issue-number">62</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="82786faa7bcf72356fc65ce5f1ce831efdcf240f">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> loadImage() in tools/tiffcrop.c in LibTIFF through 4.5.0 has a heap-based use after free via a crafted TIFF image.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('0eb985d924d984109c470458308105f312250d09')">
                                    <div class="issue-number">63</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="0eb985d924d984109c470458308105f312250d09">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> libtiff 4.5.0 is vulnerable to Buffer Overflow in uv_encode() when libtiff reads a corrupted little-endian TIFF file and specifies the output to be big-endian.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('40cfa76eb2b6c8dda438cc3f6ff00f7d721cf27f')">
                                    <div class="issue-number">64</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="40cfa76eb2b6c8dda438cc3f6ff00f7d721cf27f">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A null pointer dereference issue was found in Libtiff's tif_dir.c file. This issue may allow an attacker to pass a crafted TIFF image file to the tiffcp utility which triggers a runtime error that causes undefined behavior. This will result in an application crash, eventually leading to a denial of service.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('06dc1e59da17d9da1147e3c5e94e51d732aeba06')">
                                    <div class="issue-number">65</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="06dc1e59da17d9da1147e3c5e94e51d732aeba06">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A flaw was found in libtiff. A specially crafted tiff file can lead to a segmentation fault due to a buffer overflow in the Fax3Encode function in libtiff/tif_fax3.c, resulting in a denial of service.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('9c17ddde5921a307c3e44530cc1775f0e466f740')">
                                    <div class="issue-number">66</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="9c17ddde5921a307c3e44530cc1775f0e466f740">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An out-of-memory flaw was found in libtiff. Passing a crafted tiff file to TIFFOpen() API may allow a remote attacker to cause a denial of service via a craft input with size smaller than 379 KB.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('ea42801c1b16e7db5d2382215c5272f9f89161a4')">
                                    <div class="issue-number">67</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="ea42801c1b16e7db5d2382215c5272f9f89161a4">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> libtiff 4.5.0 is vulnerable to Buffer Overflow via /libtiff/tools/tiffcrop.c:8499. Incorrect updating of buffer size after rotateImage() in tiffcrop cause heap-buffer-overflow and SEGV.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('34dec852839a5f00bb9c9fcf1e70a234a1b5e1e6')">
                                    <div class="issue-number">68</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="34dec852839a5f00bb9c9fcf1e70a234a1b5e1e6">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> loadImage() in tools/tiffcrop.c in LibTIFF through 4.5.0 has a heap-based use after free via a crafted TIFF image.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('8d28e1eedf2fb31815c1cbae5b5c403cb5c5d4e7')">
                                    <div class="issue-number">69</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="8d28e1eedf2fb31815c1cbae5b5c403cb5c5d4e7">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> libtiff 4.5.0 is vulnerable to Buffer Overflow in uv_encode() when libtiff reads a corrupted little-endian TIFF file and specifies the output to be big-endian.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('21565c70b3bc1673c92b60e2e84e08c62e9c78cb')">
                                    <div class="issue-number">70</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="21565c70b3bc1673c92b60e2e84e08c62e9c78cb">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A null pointer dereference issue was found in Libtiff's tif_dir.c file. This issue may allow an attacker to pass a crafted TIFF image file to the tiffcp utility which triggers a runtime error that causes undefined behavior. This will result in an application crash, eventually leading to a denial of service.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('d9b38c7bcb997ad26eba075e10ebc4662008ed5c')">
                                    <div class="issue-number">71</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="d9b38c7bcb997ad26eba075e10ebc4662008ed5c">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A flaw was found in libtiff. A specially crafted tiff file can lead to a segmentation fault due to a buffer overflow in the Fax3Encode function in libtiff/tif_fax3.c, resulting in a denial of service.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('94ea302e26624c4996c5b763be47de5dfb51734f')">
                                    <div class="issue-number">72</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="94ea302e26624c4996c5b763be47de5dfb51734f">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An out-of-memory flaw was found in libtiff. Passing a crafted tiff file to TIFFOpen() API may allow a remote attacker to cause a denial of service via a craft input with size smaller than 379 KB.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('19d1f640462c309f0ae9133dfe5102ff39d4aea6')">
                                    <div class="issue-number">73</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="19d1f640462c309f0ae9133dfe5102ff39d4aea6">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> NCurse v6.4-20230418 was discovered to contain a segmentation fault via the component _nc_wrap_entry().</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('9fd0e0fede841a0b91a24aace933f35cb8a5176f')">
                                    <div class="issue-number">74</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="9fd0e0fede841a0b91a24aace933f35cb8a5176f">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Xmlsoft Libxml2 v2.11.0 was discovered to contain an out-of-bounds read via the xmlSAX2StartElement() function at /libxml2/SAX2.c. This vulnerability allows attackers to cause a Denial of Service (DoS) via supplying a crafted XML file. NOTE: the vendor's position is that the product does not support the legacy SAX1 interface with custom callbacks; there is a crash even without crafted input.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('7f6f34a8bdc6785a51fdeacc6b29d26bb0be2bcd')">
                                    <div class="issue-number">75</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="7f6f34a8bdc6785a51fdeacc6b29d26bb0be2bcd">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> libxml2 through 2.11.5 has a use-after-free that can only occur after a certain memory allocation fails. This occurs in xmlUnlinkNode in tree.c. NOTE: the vendor's position is "I don't think these issues are critical enough to warrant a CVE ID ... because an attacker typically can't control when memory allocations fail."</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('62c23975d00842e7b6044e65a7ad7d81b6697f79')">
                                    <div class="issue-number">76</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="62c23975d00842e7b6044e65a7ad7d81b6697f79">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Xmlsoft Libxml2 v2.11.0 was discovered to contain an out-of-bounds read via the xmlSAX2StartElement() function at /libxml2/SAX2.c. This vulnerability allows attackers to cause a Denial of Service (DoS) via supplying a crafted XML file. NOTE: the vendor's position is that the product does not support the legacy SAX1 interface with custom callbacks; there is a crash even without crafted input.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('d7913fd877ced2b49583b1163f59d9cd3a7764b2')">
                                    <div class="issue-number">77</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="d7913fd877ced2b49583b1163f59d9cd3a7764b2">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> libxml2 through 2.11.5 has a use-after-free that can only occur after a certain memory allocation fails. This occurs in xmlUnlinkNode in tree.c. NOTE: the vendor's position is "I don't think these issues are critical enough to warrant a CVE ID ... because an attacker typically can't control when memory allocations fail."</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('1ce4f7c32a9b83dcf11bd34fc2483ad23896679c')">
                                    <div class="issue-number">78</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="1ce4f7c32a9b83dcf11bd34fc2483ad23896679c">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in the Linux kernel before 5.2.3. There is a use-after-free caused by a malicious USB device in the drivers/media/usb/dvb-usb/dvb-usb-init.c driver.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('e5937d7e7ec39a536a0b3ead27c458b166bd6663')">
                                    <div class="issue-number">79</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="e5937d7e7ec39a536a0b3ead27c458b166bd6663">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in the Linux kernel through 5.2.13. nbd_genl_status in drivers/block/nbd.c does not check the nla_nest_start_noflag return value.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('55c8f7f8be339bfd323238f7fea4ef355bc5ae79')">
                                    <div class="issue-number">80</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="55c8f7f8be339bfd323238f7fea4ef355bc5ae79">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in the Linux kernel 4.18 through 5.6.11 when unprivileged user namespaces are allowed. A user can create their own PID namespace, and mount a FUSE filesystem. Upon interaction with this FUSE filesystem, if the userspace component is terminated via a kill of the PID namespace's pid 1, it will result in a hung task, and resources being permanently locked up until system reboot. This can result in resource exhaustion.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('f1ed02d0cadb41219bcc2c176688b30ba0e4f7b7')">
                                    <div class="issue-number">81</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="f1ed02d0cadb41219bcc2c176688b30ba0e4f7b7">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A memory disclosure flaw was found in the Linux kernel's ethernet drivers, in the way it read data from the EEPROM of the device. This flaw allows a local user to read uninitialized values from the kernel memory. The highest threat from this vulnerability is to confidentiality.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('b18b5e294c8f77307bf5c08bb9639dc91aba6527')">
                                    <div class="issue-number">82</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="b18b5e294c8f77307bf5c08bb9639dc91aba6527">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in netfilter in the Linux kernel before 5.10. There can be a use-after-free in the packet processing context, because the per-CPU sequence count is mishandled during concurrent iptables rules replacement. This could be exploited with the CAP_NET_ADMIN capability in an unprivileged namespace. NOTE: cc00bca was reverted in 5.12.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('95dd101315588df9a4caf05feafbb5b527a1e02e')">
                                    <div class="issue-number">83</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="95dd101315588df9a4caf05feafbb5b527a1e02e">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A flaw named "EntryBleed" was found in the Linux Kernel Page Table Isolation (KPTI). This issue could allow a local attacker to leak KASLR base via prefetch side-channels based on TLB timing for Intel systems.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('d89098557d86b62ac9b58885e60f556b2a7ec039')">
                                    <div class="issue-number">84</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="d89098557d86b62ac9b58885e60f556b2a7ec039">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A deadlock flaw was found in the Linux kernel’s BPF subsystem. This flaw allows a local user to potentially crash the system.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('a3fad63d6f0c0168366ef44ac8869e6f57ef4003')">
                                    <div class="issue-number">85</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="a3fad63d6f0c0168366ef44ac8869e6f57ef4003">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A flaw possibility of memory leak in the Linux kernel cpu_entry_area mapping of X86 CPU data to memory was found in the way user can guess location of exception stack(s) or other important data. A local user could use this flaw to get access to some important data with expected location in memory.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('0c9bf14f4d74895772a7e93a1dac7663a32826ee')">
                                    <div class="issue-number">86</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="0c9bf14f4d74895772a7e93a1dac7663a32826ee">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In multiple functions of mem_protect.c, there is a possible way to access hypervisor memory due to a memory access check in the wrong place. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation.

</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('d9d10da1173f08e6a1cf3346643c8638a13d86e8')">
                                    <div class="issue-number">87</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="d9d10da1173f08e6a1cf3346643c8638a13d86e8">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel before 6.2, mm/memory-tiers.c misinterprets the alloc_memory_type return value (expects it to be NULL in the error case, whereas it is actually an error pointer). NOTE: this is disputed by third parties because there are no realistic cases in which a user can cause the alloc_memory_type error case to be reached.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('12d509c6b43baaab7da10143fcbce9ca5cc44c7b')">
                                    <div class="issue-number">88</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="12d509c6b43baaab7da10143fcbce9ca5cc44c7b">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in drivers/tty/n_gsm.c in the Linux kernel 6.2. There is a sleeping function called from an invalid context in gsmld_write, which will block the kernel. Note: This has been disputed by 3rd parties as not a valid vulnerability.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('7fe906a991c7d1c3b4d5c8360cf3e1ae71e1c235')">
                                    <div class="issue-number">89</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="7fe906a991c7d1c3b4d5c8360cf3e1ae71e1c235">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A race condition occurred between the functions lmLogClose and txEnd in JFS, in the Linux Kernel, executed in different threads. This flaw allows a local attacker with normal user privileges to crash the system or leak internal kernel information.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('af34f92c5db54b37df5419c9f8b38b291c28504d')">
                                    <div class="issue-number">90</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="af34f92c5db54b37df5419c9f8b38b291c28504d">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in the Linux kernel through 6.4.2. A crafted UDF filesystem image causes a use-after-free write operation in the udf_put_super and udf_close_lvid functions in fs/udf/super.c. NOTE: the suse.com reference has a different perspective about this.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('628e6649bcf9cbba2aeef1b278ad478b23fb472f')">
                                    <div class="issue-number">91</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="628e6649bcf9cbba2aeef1b278ad478b23fb472f">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A flaw was found in the USB Host Controller Driver framework in the Linux kernel. The usb_giveback_urb function has a logic loophole in its implementation. Due to the inappropriate judgment condition of the goto statement, the function cannot return under the input of a specific malformed descriptor file, so it falls into an endless loop, resulting in a denial of service.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('26803ea0118387eeae8acce88d7b68d631cc62ec')">
                                    <div class="issue-number">92</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="26803ea0118387eeae8acce88d7b68d631cc62ec">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A use-after-free vulnerability was found in the cxgb4 driver in the Linux kernel. The bug occurs when the cxgb4 device is detaching due to a possible rearming of the flower_stats_timer from the work queue. This flaw allows a local user to crash the system, causing a denial of service condition.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('7b3d942283ee72ffafc07a427b718c956eeea67c')">
                                    <div class="issue-number">93</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="7b3d942283ee72ffafc07a427b718c956eeea67c">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Wake DMCUB before sending a command

[Why]
We can hang in place trying to send commands when the DMCUB isn't
powered on.

[How]
For functions that execute within a DC context or DC lock we can
wrap the direct calls to dm_execute_dmub_cmd/list with code that
exits idle power optimizations and reallows once we're done with
the command submission on success.

For DM direct submissions the DM will need to manage the enter/exit
sequencing manually.

We cannot invoke a DMCUB command directly within the DM execution
helper or we can deadlock.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('c96f2574f85aee8e2614aa02dbfceee744922bfa')">
                                    <div class="issue-number">94</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="c96f2574f85aee8e2614aa02dbfceee744922bfa">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/msm/dpu: Add mutex lock in control vblank irq

Add a mutex lock to control vblank irq to synchronize vblank
enable/disable operations happening from different threads to prevent
race conditions while registering/unregistering the vblank irq callback.

v4: -Removed vblank_ctl_lock from dpu_encoder_virt, so it is only a
    parameter of dpu_encoder_phys.
    -Switch from atomic refcnt to a simple int counter as mutex has
    now been added
v3: Mistakenly did not change wording in last version. It is done now.
v2: Slightly changed wording of commit message

Patchwork: https://patchwork.freedesktop.org/patch/571854/</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('f0a39c206f3617c49d9f920e484bc0f0ada972ea')">
                                    <div class="issue-number">95</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="f0a39c206f3617c49d9f920e484bc0f0ada972ea">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

reiserfs: Avoid touching renamed directory if parent does not change

The VFS will not be locking moved directory if its parent does not
change. Change reiserfs rename code to avoid touching renamed directory
if its parent does not change as without locking that can corrupt the
filesystem.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('0a5f6755da5cbe0700103dcbe80f478987c762a7')">
                                    <div class="issue-number">96</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="0a5f6755da5cbe0700103dcbe80f478987c762a7">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

sysctl: Fix out of bounds access for empty sysctl registers

When registering tables to the sysctl subsystem there is a check to see
if header is a permanently empty directory (used for mounts). This check
evaluates the first element of the ctl_table. This results in an out of
bounds evaluation when registering empty directories.

The function register_sysctl_mount_point now passes a ctl_table of size
1 instead of size 0. It now relies solely on the type to identify
a permanently empty register.

Make sure that the ctl_table has at least one element before testing for
permanent emptiness.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('c49165df4168860af9694f0d0c7edab5454edc6d')">
                                    <div class="issue-number">97</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="c49165df4168860af9694f0d0c7edab5454edc6d">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Wake DMCUB before executing GPINT commands

[Why]
DMCUB can be in idle when we attempt to interface with the HW through
the GPINT mailbox resulting in a system hang.

[How]
Add dc_wake_and_execute_gpint() to wrap the wake, execute, sleep
sequence.

If the GPINT executes successfully then DMCUB will be put back into
sleep after the optional response is returned.

It functions similar to the inbox command interface.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('9075cf7df89bac8dbc3ab94217bd4654d0874da9')">
                                    <div class="issue-number">98</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="9075cf7df89bac8dbc3ab94217bd4654d0874da9">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Refactor DMCUB enter/exit idle interface

[Why]
We can hang in place trying to send commands when the DMCUB isn't
powered on.

[How]
We need to exit out of the idle state prior to sending a command,
but the process that performs the exit also invokes a command itself.

Fixing this issue involves the following:

1. Using a software state to track whether or not we need to start
   the process to exit idle or notify idle.

It's possible for the hardware to have exited an idle state without
driver knowledge, but entering one is always restricted to a driver
allow - which makes the SW state vs HW state mismatch issue purely one
of optimization, which should seldomly be hit, if at all.

2. Refactor any instances of exit/notify idle to use a single wrapper
   that maintains this SW state.

This works simialr to dc_allow_idle_optimizations, but works at the
DMCUB level and makes sure the state is marked prior to any notify/exit
idle so we don't enter an infinite loop.

3. Make sure we exit out of idle prior to sending any commands or
   waiting for DMCUB idle.

This patch takes care of 1/2. A future patch will take care of wrapping
DMCUB command submission with calls to this new interface.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('8d57a2e2833250fb52170a4877e89f8082544106')">
                                    <div class="issue-number">99</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="8d57a2e2833250fb52170a4877e89f8082544106">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

sh: push-switch: Reorder cleanup operations to avoid use-after-free bug

The original code puts flush_work() before timer_shutdown_sync()
in switch_drv_remove(). Although we use flush_work() to stop
the worker, it could be rescheduled in switch_timer(). As a result,
a use-after-free bug can occur. The details are shown below:

      (cpu 0)                    |      (cpu 1)
switch_drv_remove()              |
 flush_work()                    |
  ...                            |  switch_timer // timer
                                 |   schedule_work(&psw->work)
 timer_shutdown_sync()           |
 ...                             |  switch_work_handler // worker
 kfree(psw) // free              |
                                 |   psw->state = 0 // use

This patch puts timer_shutdown_sync() before flush_work() to
mitigate the bugs. As a result, the worker and timer will be
stopped safely before the deallocate operations.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('1031299a0518cfccb15cf94f0a2f8dd98d89a6f0')">
                                    <div class="issue-number">100</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="1031299a0518cfccb15cf94f0a2f8dd98d89a6f0">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Fix disable_otg_wa logic

[Why]
When switching to another HDMI mode, we are unnecesarilly
disabling/enabling FIFO causing both HPO and DIG registers to be set at
the same time when only HPO is supposed to be set.

This can lead to a system hang the next time we change refresh rates as
there are cases when we don't disable OTG/FIFO but FIFO is enabled when
it isn't supposed to be.

[How]
Removing the enable/disable FIFO entirely.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('48e5d777bb05e1cb2f47630cd9966df0c4e0b113')">
                                    <div class="issue-number">101</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="48e5d777bb05e1cb2f47630cd9966df0c4e0b113">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/vmwgfx: Unmap the surface before resetting it on a plane state

Switch to a new plane state requires unreferencing of all held surfaces.
In the work required for mob cursors the mapped surfaces started being
cached but the variable indicating whether the surface is currently
mapped was not being reset. This leads to crashes as the duplicated
state, incorrectly, indicates the that surface is mapped even when
no surface is present. That's because after unreferencing the surface
it's perfectly possible for the plane to be backed by a bo instead of a
surface.

Reset the surface mapped flag when unreferencing the plane state surface
to fix null derefs in cleanup. Fixes crashes in KDE KWin 6.0 on Wayland:

Oops: 0000 [#1] PREEMPT SMP PTI
CPU: 4 PID: 2533 Comm: kwin_wayland Not tainted 6.7.0-rc3-vmwgfx #2
Hardware name: VMware, Inc. VMware Virtual Platform/440BX Desktop Reference Platform, BIOS 6.00 11/12/2020
RIP: 0010:vmw_du_cursor_plane_cleanup_fb+0x124/0x140 [vmwgfx]
Code: 00 00 00 75 3a 48 83 c4 10 5b 5d c3 cc cc cc cc 48 8b b3 a8 00 00 00 48 c7 c7 99 90 43 c0 e8 93 c5 db ca 48 8b 83 a8 00 00 00 <48> 8b 78 28 e8 e3 f>
RSP: 0018:ffffb6b98216fa80 EFLAGS: 00010246
RAX: 0000000000000000 RBX: ffff969d84cdcb00 RCX: 0000000000000027
RDX: 0000000000000000 RSI: 0000000000000001 RDI: ffff969e75f21600
RBP: ffff969d4143dc50 R08: 0000000000000000 R09: ffffb6b98216f920
R10: 0000000000000003 R11: ffff969e7feb3b10 R12: 0000000000000000
R13: 0000000000000000 R14: 000000000000027b R15: ffff969d49c9fc00
FS:  00007f1e8f1b4180(0000) GS:ffff969e75f00000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 0000000000000028 CR3: 0000000104006004 CR4: 00000000003706f0
Call Trace:
 <TASK>
 ? __die+0x23/0x70
 ? page_fault_oops+0x171/0x4e0
 ? exc_page_fault+0x7f/0x180
 ? asm_exc_page_fault+0x26/0x30
 ? vmw_du_cursor_plane_cleanup_fb+0x124/0x140 [vmwgfx]
 drm_atomic_helper_cleanup_planes+0x9b/0xc0
 commit_tail+0xd1/0x130
 drm_atomic_helper_commit+0x11a/0x140
 drm_atomic_commit+0x97/0xd0
 ? __pfx___drm_printfn_info+0x10/0x10
 drm_atomic_helper_update_plane+0xf5/0x160
 drm_mode_cursor_universal+0x10e/0x270
 drm_mode_cursor_common+0x102/0x230
 ? __pfx_drm_mode_cursor2_ioctl+0x10/0x10
 drm_ioctl_kernel+0xb2/0x110
 drm_ioctl+0x26d/0x4b0
 ? __pfx_drm_mode_cursor2_ioctl+0x10/0x10
 ? __pfx_drm_ioctl+0x10/0x10
 vmw_generic_ioctl+0xa4/0x110 [vmwgfx]
 __x64_sys_ioctl+0x94/0xd0
 do_syscall_64+0x61/0xe0
 ? __x64_sys_ioctl+0xaf/0xd0
 ? syscall_exit_to_user_mode+0x2b/0x40
 ? do_syscall_64+0x70/0xe0
 ? __x64_sys_ioctl+0xaf/0xd0
 ? syscall_exit_to_user_mode+0x2b/0x40
 ? do_syscall_64+0x70/0xe0
 ? exc_page_fault+0x7f/0x180
 entry_SYSCALL_64_after_hwframe+0x6e/0x76
RIP: 0033:0x7f1e93f279ed
Code: 04 25 28 00 00 00 48 89 45 c8 31 c0 48 8d 45 10 c7 45 b0 10 00 00 00 48 89 45 b8 48 8d 45 d0 48 89 45 c0 b8 10 00 00 00 0f 05 <89> c2 3d 00 f0 ff f>
RSP: 002b:00007ffca0faf600 EFLAGS: 00000246 ORIG_RAX: 0000000000000010
RAX: ffffffffffffffda RBX: 000055db876ed2c0 RCX: 00007f1e93f279ed
RDX: 00007ffca0faf6c0 RSI: 00000000c02464bb RDI: 0000000000000015
RBP: 00007ffca0faf650 R08: 000055db87184010 R09: 0000000000000007
R10: 000055db886471a0 R11: 0000000000000246 R12: 00007ffca0faf6c0
R13: 00000000c02464bb R14: 0000000000000015 R15: 00007ffca0faf790
 </TASK>
Modules linked in: snd_seq_dummy snd_hrtimer nf_conntrack_netbios_ns nf_conntrack_broadcast nft_fib_inet nft_fib_ipv4 nft_fib_ipv6 nft_fib nft_reject_ine>
CR2: 0000000000000028
---[ end trace 0000000000000000 ]---
RIP: 0010:vmw_du_cursor_plane_cleanup_fb+0x124/0x140 [vmwgfx]
Code: 00 00 00 75 3a 48 83 c4 10 5b 5d c3 cc cc cc cc 48 8b b3 a8 00 00 00 48 c7 c7 99 90 43 c0 e8 93 c5 db ca 48 8b 83 a8 00 00 00 <48> 8b 78 28 e8 e3 f>
RSP: 0018:ffffb6b98216fa80 EFLAGS: 00010246
RAX: 0000000000000000 RBX: ffff969d84cdcb00 RCX: 0000000000000027
RDX: 0000000000000000 RSI: 0000000000000001 RDI: ffff969e75f21600
RBP: ffff969d4143
---truncated---</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('f4a0d8682e44dcc41bc5f3f2ad244cd70a88b1d4')">
                                    <div class="issue-number">102</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="f4a0d8682e44dcc41bc5f3f2ad244cd70a88b1d4">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

SUNRPC: fix a memleak in gss_import_v2_context

The ctx->mech_used.data allocated by kmemdup is not freed in neither
gss_import_v2_context nor it only caller gss_krb5_import_sec_context,
which frees ctx on error.

Thus, this patch reform the last call of gss_import_v2_context to the
gss_krb5_import_ctx_v2, preventing the memleak while keepping the return
formation.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('06f440fce853c9ae0f826e1365e344d6571bbef0')">
                                    <div class="issue-number">103</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="06f440fce853c9ae0f826e1365e344d6571bbef0">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

Revert "net/mlx5: Block entering switchdev mode with ns inconsistency"

This reverts commit 662404b24a4c4d839839ed25e3097571f5938b9b.
The revert is required due to the suspicion it is not good for anything
and cause crash.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('07669129e18ce84238342643daa494bc925138ae')">
                                    <div class="issue-number">104</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="07669129e18ce84238342643daa494bc925138ae">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Fix hang/underflow when transitioning to ODM4:1

[Why]
Under some circumstances, disabling an OPTC and attempting to reclaim
its OPP(s) for a different OPTC could cause a hang/underflow due to OPPs
not being properly disconnected from the disabled OPTC.

[How]
Ensure that all OPPs are unassigned from an OPTC when it gets disabled.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('fd3d2a66777fa2c04bd6538349954b04507590f4')">
                                    <div class="issue-number">105</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="fd3d2a66777fa2c04bd6538349954b04507590f4">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Fix a debugfs null pointer error

[WHY & HOW]
Check whether get_subvp_en() callback exists before calling it.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('061aa9b51cca5e0c2588179ab79dfe3255fccb1c')">
                                    <div class="issue-number">106</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="061aa9b51cca5e0c2588179ab79dfe3255fccb1c">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

bpf: Guard stack limits against 32bit overflow

This patch promotes the arithmetic around checking stack bounds to be
done in the 64-bit domain, instead of the current 32bit. The arithmetic
implies adding together a 64-bit register with a int offset. The
register was checked to be below 1<<29 when it was variable, but not
when it was fixed. The offset either comes from an instruction (in which
case it is 16 bit), from another register (in which case the caller
checked it to be below 1<<29 [1]), or from the size of an argument to a
kfunc (in which case it can be a u32 [2]). Between the register being
inconsistently checked to be below 1<<29, and the offset being up to an
u32, it appears that we were open to overflowing the `int`s which were
currently used for arithmetic.

[1] https://github.com/torvalds/linux/blob/815fb87b753055df2d9e50f6cd80eb10235fe3e9/kernel/bpf/verifier.c#L7494-L7498
[2] https://github.com/torvalds/linux/blob/815fb87b753055df2d9e50f6cd80eb10235fe3e9/kernel/bpf/verifier.c#L11904</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('86fbd4243cf017b86e8876c5ce815f9e826a9950')">
                                    <div class="issue-number">107</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="86fbd4243cf017b86e8876c5ce815f9e826a9950">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

riscv: VMAP_STACK overflow detection thread-safe

commit 31da94c25aea ("riscv: add VMAP_STACK overflow detection") added
support for CONFIG_VMAP_STACK. If overflow is detected, CPU switches to
`shadow_stack` temporarily before switching finally to per-cpu
`overflow_stack`.

If two CPUs/harts are racing and end up in over flowing kernel stack, one
or both will end up corrupting each other state because `shadow_stack` is
not per-cpu. This patch optimizes per-cpu overflow stack switch by
directly picking per-cpu `overflow_stack` and gets rid of `shadow_stack`.

Following are the changes in this patch

 - Defines an asm macro to obtain per-cpu symbols in destination
   register.
 - In entry.S, when overflow is detected, per-cpu overflow stack is
   located using per-cpu asm macro. Computing per-cpu symbol requires
   a temporary register. x31 is saved away into CSR_SCRATCH
   (CSR_SCRATCH is anyways zero since we're in kernel).

Please see Links for additional relevant disccussion and alternative
solution.

Tested by `echo EXHAUST_STACK > /sys/kernel/debug/provoke-crash/DIRECT`
Kernel crash log below

 Insufficient stack space to handle exception!/debug/provoke-crash/DIRECT
 Task stack:     [0xff20000010a98000..0xff20000010a9c000]
 Overflow stack: [0xff600001f7d98370..0xff600001f7d99370]
 CPU: 1 PID: 205 Comm: bash Not tainted 6.1.0-rc2-00001-g328a1f96f7b9 #34
 Hardware name: riscv-virtio,qemu (DT)
 epc : __memset+0x60/0xfc
  ra : recursive_loop+0x48/0xc6 [lkdtm]
 epc : ffffffff808de0e4 ra : ffffffff0163a752 sp : ff20000010a97e80
  gp : ffffffff815c0330 tp : ff600000820ea280 t0 : ff20000010a97e88
  t1 : 000000000000002e t2 : 3233206874706564 s0 : ff20000010a982b0
  s1 : 0000000000000012 a0 : ff20000010a97e88 a1 : 0000000000000000
  a2 : 0000000000000400 a3 : ff20000010a98288 a4 : 0000000000000000
  a5 : 0000000000000000 a6 : fffffffffffe43f0 a7 : 00007fffffffffff
  s2 : ff20000010a97e88 s3 : ffffffff01644680 s4 : ff20000010a9be90
  s5 : ff600000842ba6c0 s6 : 00aaaaaac29e42b0 s7 : 00fffffff0aa3684
  s8 : 00aaaaaac2978040 s9 : 0000000000000065 s10: 00ffffff8a7cad10
  s11: 00ffffff8a76a4e0 t3 : ffffffff815dbaf4 t4 : ffffffff815dbaf4
  t5 : ffffffff815dbab8 t6 : ff20000010a9bb48
 status: 0000000200000120 badaddr: ff20000010a97e88 cause: 000000000000000f
 Kernel panic - not syncing: Kernel stack overflow
 CPU: 1 PID: 205 Comm: bash Not tainted 6.1.0-rc2-00001-g328a1f96f7b9 #34
 Hardware name: riscv-virtio,qemu (DT)
 Call Trace:
 [<ffffffff80006754>] dump_backtrace+0x30/0x38
 [<ffffffff808de798>] show_stack+0x40/0x4c
 [<ffffffff808ea2a8>] dump_stack_lvl+0x44/0x5c
 [<ffffffff808ea2d8>] dump_stack+0x18/0x20
 [<ffffffff808dec06>] panic+0x126/0x2fe
 [<ffffffff800065ea>] walk_stackframe+0x0/0xf0
 [<ffffffff0163a752>] recursive_loop+0x48/0xc6 [lkdtm]
 SMP: stopping secondary CPUs
 ---[ end Kernel panic - not syncing: Kernel stack overflow ]---</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('10bcf7e3e96a8d94c22c6dadcf36d3b804767659')">
                                    <div class="issue-number">108</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="10bcf7e3e96a8d94c22c6dadcf36d3b804767659">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

f2fs: split initial and dynamic conditions for extent_cache

Let's allocate the extent_cache tree without dynamic conditions to avoid a
missing condition causing a panic as below.

 # create a file w/ a compressed flag
 # disable the compression
 # panic while updating extent_cache

F2FS-fs (dm-64): Swapfile: last extent is not aligned to section
F2FS-fs (dm-64): Swapfile (3) is not align to section: 1) creat(), 2) ioctl(F2FS_IOC_SET_PIN_FILE), 3) fallocate(2097152 * N)
Adding 124996k swap on ./swap-file.  Priority:0 extents:2 across:17179494468k
==================================================================
BUG: KASAN: null-ptr-deref in instrument_atomic_read_write out/common/include/linux/instrumented.h:101 [inline]
BUG: KASAN: null-ptr-deref in atomic_try_cmpxchg_acquire out/common/include/asm-generic/atomic-instrumented.h:705 [inline]
BUG: KASAN: null-ptr-deref in queued_write_lock out/common/include/asm-generic/qrwlock.h:92 [inline]
BUG: KASAN: null-ptr-deref in __raw_write_lock out/common/include/linux/rwlock_api_smp.h:211 [inline]
BUG: KASAN: null-ptr-deref in _raw_write_lock+0x5a/0x110 out/common/kernel/locking/spinlock.c:295
Write of size 4 at addr 0000000000000030 by task syz-executor154/3327

CPU: 0 PID: 3327 Comm: syz-executor154 Tainted: G           O      5.10.185 #1
Hardware name: emulation qemu-x86/qemu-x86, BIOS 2023.01-21885-gb3cc1cd24d 01/01/2023
Call Trace:
 __dump_stack out/common/lib/dump_stack.c:77 [inline]
 dump_stack_lvl+0x17e/0x1c4 out/common/lib/dump_stack.c:118
 __kasan_report+0x16c/0x260 out/common/mm/kasan/report.c:415
 kasan_report+0x51/0x70 out/common/mm/kasan/report.c:428
 kasan_check_range+0x2f3/0x340 out/common/mm/kasan/generic.c:186
 __kasan_check_write+0x14/0x20 out/common/mm/kasan/shadow.c:37
 instrument_atomic_read_write out/common/include/linux/instrumented.h:101 [inline]
 atomic_try_cmpxchg_acquire out/common/include/asm-generic/atomic-instrumented.h:705 [inline]
 queued_write_lock out/common/include/asm-generic/qrwlock.h:92 [inline]
 __raw_write_lock out/common/include/linux/rwlock_api_smp.h:211 [inline]
 _raw_write_lock+0x5a/0x110 out/common/kernel/locking/spinlock.c:295
 __drop_extent_tree+0xdf/0x2f0 out/common/fs/f2fs/extent_cache.c:1155
 f2fs_drop_extent_tree+0x17/0x30 out/common/fs/f2fs/extent_cache.c:1172
 f2fs_insert_range out/common/fs/f2fs/file.c:1600 [inline]
 f2fs_fallocate+0x19fd/0x1f40 out/common/fs/f2fs/file.c:1764
 vfs_fallocate+0x514/0x9b0 out/common/fs/open.c:310
 ksys_fallocate out/common/fs/open.c:333 [inline]
 __do_sys_fallocate out/common/fs/open.c:341 [inline]
 __se_sys_fallocate out/common/fs/open.c:339 [inline]
 __x64_sys_fallocate+0xb8/0x100 out/common/fs/open.c:339
 do_syscall_64+0x35/0x50 out/common/arch/x86/entry/common.c:46</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('207f201c6af915641ce6eda31d7fa21cb93e0d4a')">
                                    <div class="issue-number">109</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="207f201c6af915641ce6eda31d7fa21cb93e0d4a">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

cxl/port: Fix delete_endpoint() vs parent unregistration race

The CXL subsystem, at cxl_mem ->probe() time, establishes a lineage of
ports (struct cxl_port objects) between an endpoint and the root of a
CXL topology. Each port including the endpoint port is attached to the
cxl_port driver.

Given that setup, it follows that when either any port in that lineage
goes through a cxl_port ->remove() event, or the memdev goes through a
cxl_mem ->remove() event. The hierarchy below the removed port, or the
entire hierarchy if the memdev is removed needs to come down.

The delete_endpoint() callback is careful to check whether it is being
called to tear down the hierarchy, or if it is only being called to
teardown the memdev because an ancestor port is going through
->remove().

That care needs to take the device_lock() of the endpoint's parent.
Which requires 2 bugs to be fixed:

1/ A reference on the parent is needed to prevent use-after-free
   scenarios like this signature:

    BUG: spinlock bad magic on CPU#0, kworker/u56:0/11
    Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS edk2-20230524-3.fc38 05/24/2023
    Workqueue: cxl_port detach_memdev [cxl_core]
    RIP: 0010:spin_bug+0x65/0xa0
    Call Trace:
      do_raw_spin_lock+0x69/0xa0
     __mutex_lock+0x695/0xb80
     delete_endpoint+0xad/0x150 [cxl_core]
     devres_release_all+0xb8/0x110
     device_unbind_cleanup+0xe/0x70
     device_release_driver_internal+0x1d2/0x210
     detach_memdev+0x15/0x20 [cxl_core]
     process_one_work+0x1e3/0x4c0
     worker_thread+0x1dd/0x3d0

2/ In the case of RCH topologies, the parent device that needs to be
   locked is not always @port->dev as returned by cxl_mem_find_port(), use
   endpoint->dev.parent instead.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('8e657be8163474c8ab7226c8decbeab8cb059e9b')">
                                    <div class="issue-number">110</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="8e657be8163474c8ab7226c8decbeab8cb059e9b">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drivers: perf: Check find_first_bit() return value

We must check the return value of find_first_bit() before using the
return value as an index array since it happens to overflow the array
and then panic:

[  107.318430] Kernel BUG [#1]
[  107.319434] CPU: 3 PID: 1238 Comm: kill Tainted: G            E      6.6.0-rc6ubuntu-defconfig #2
[  107.319465] Hardware name: riscv-virtio,qemu (DT)
[  107.319551] epc : pmu_sbi_ovf_handler+0x3a4/0x3ae
[  107.319840]  ra : pmu_sbi_ovf_handler+0x52/0x3ae
[  107.319868] epc : ffffffff80a0a77c ra : ffffffff80a0a42a sp : ffffaf83fecda350
[  107.319884]  gp : ffffffff823961a8 tp : ffffaf8083db1dc0 t0 : ffffaf83fecda480
[  107.319899]  t1 : ffffffff80cafe62 t2 : 000000000000ff00 s0 : ffffaf83fecda520
[  107.319921]  s1 : ffffaf83fecda380 a0 : 00000018fca29df0 a1 : ffffffffffffffff
[  107.319936]  a2 : 0000000001073734 a3 : 0000000000000004 a4 : 0000000000000000
[  107.319951]  a5 : 0000000000000040 a6 : 000000001d1c8774 a7 : 0000000000504d55
[  107.319965]  s2 : ffffffff82451f10 s3 : ffffffff82724e70 s4 : 000000000000003f
[  107.319980]  s5 : 0000000000000011 s6 : ffffaf8083db27c0 s7 : 0000000000000000
[  107.319995]  s8 : 0000000000000001 s9 : 00007fffb45d6558 s10: 00007fffb45d81a0
[  107.320009]  s11: ffffaf7ffff60000 t3 : 0000000000000004 t4 : 0000000000000000
[  107.320023]  t5 : ffffaf7f80000000 t6 : ffffaf8000000000
[  107.320037] status: 0000000200000100 badaddr: 0000000000000000 cause: 0000000000000003
[  107.320081] [<ffffffff80a0a77c>] pmu_sbi_ovf_handler+0x3a4/0x3ae
[  107.320112] [<ffffffff800b42d0>] handle_percpu_devid_irq+0x9e/0x1a0
[  107.320131] [<ffffffff800ad92c>] generic_handle_domain_irq+0x28/0x36
[  107.320148] [<ffffffff8065f9f8>] riscv_intc_irq+0x36/0x4e
[  107.320166] [<ffffffff80caf4a0>] handle_riscv_irq+0x54/0x86
[  107.320189] [<ffffffff80cb0036>] do_irq+0x64/0x96
[  107.320271] Code: 85a6 855e b097 ff7f 80e7 9220 b709 9002 4501 bbd9 (9002) 6097
[  107.320585] ---[ end trace 0000000000000000 ]---
[  107.320704] Kernel panic - not syncing: Fatal exception in interrupt
[  107.320775] SMP: stopping secondary CPUs
[  107.321219] Kernel Offset: 0x0 from 0xffffffff80000000
[  107.333051] ---[ end Kernel panic - not syncing: Fatal exception in interrupt ]---</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('850c27e45fab93d8b94ce71f68beee0d693a64b2')">
                                    <div class="issue-number">111</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="850c27e45fab93d8b94ce71f68beee0d693a64b2">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/mediatek: Fix coverity issue with unintentional integer overflow

1. Instead of multiplying 2 variable of different types. Change to
assign a value of one variable and then multiply the other variable.

2. Add a int variable for multiplier calculation instead of calculating
different types multiplier with dma_addr_t variable directly.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('8c5a77f4f860c4be0d7ae195cca2abec40091680')">
                                    <div class="issue-number">112</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="8c5a77f4f860c4be0d7ae195cca2abec40091680">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

media: mediatek: vcodec: Only free buffer VA that is not NULL

In the MediaTek vcodec driver, while mtk_vcodec_mem_free() is mostly
called only when the buffer to free exists, there are some instances
that didn't do the check and triggered warnings in practice.

We believe those checks were forgotten unintentionally. Add the checks
back to fix the warnings.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('27e011219da40e969a8fbebfffa289dd4bb35486')">
                                    <div class="issue-number">113</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="27e011219da40e969a8fbebfffa289dd4bb35486">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

media: aspeed: Fix memory overwrite if timing is 1600x900

When capturing 1600x900, system could crash when system memory usage is
tight.

The way to reproduce this issue:
1. Use 1600x900 to display on host
2. Mount ISO through 'Virtual media' on OpenBMC's web
3. Run script as below on host to do sha continuously
  #!/bin/bash
  while [ [1] ];
  do
	find /media -type f -printf '"%h/%f"\n' | xargs sha256sum
  done
4. Open KVM on OpenBMC's web

The size of macro block captured is 8x8. Therefore, we should make sure
the height of src-buf is 8 aligned to fix this issue.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('7f9bc0715b2b06717a9ef3642cd674e1388b7dfa')">
                                    <div class="issue-number">114</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="7f9bc0715b2b06717a9ef3642cd674e1388b7dfa">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

bpf: support non-r10 register spill/fill to/from stack in precision tracking

Use instruction (jump) history to record instructions that performed
register spill/fill to/from stack, regardless if this was done through
read-only r10 register, or any other register after copying r10 into it
*and* potentially adjusting offset.

To make this work reliably, we push extra per-instruction flags into
instruction history, encoding stack slot index (spi) and stack frame
number in extra 10 bit flags we take away from prev_idx in instruction
history. We don't touch idx field for maximum performance, as it's
checked most frequently during backtracking.

This change removes basically the last remaining practical limitation of
precision backtracking logic in BPF verifier. It fixes known
deficiencies, but also opens up new opportunities to reduce number of
verified states, explored in the subsequent patches.

There are only three differences in selftests' BPF object files
according to veristat, all in the positive direction (less states).

File                                    Program        Insns (A)  Insns (B)  Insns  (DIFF)  States (A)  States (B)  States (DIFF)
--------------------------------------  -------------  ---------  ---------  -------------  ----------  ----------  -------------
test_cls_redirect_dynptr.bpf.linked3.o  cls_redirect        2987       2864  -123 (-4.12%)         240         231    -9 (-3.75%)
xdp_synproxy_kern.bpf.linked3.o         syncookie_tc       82848      82661  -187 (-0.23%)        5107        5073   -34 (-0.67%)
xdp_synproxy_kern.bpf.linked3.o         syncookie_xdp      85116      84964  -152 (-0.18%)        5162        5130   -32 (-0.62%)

Note, I avoided renaming jmp_history to more generic insn_hist to
minimize number of lines changed and potential merge conflicts between
bpf and bpf-next trees.

Notice also cur_hist_entry pointer reset to NULL at the beginning of
instruction verification loop. This pointer avoids the problem of
relying on last jump history entry's insn_idx to determine whether we
already have entry for current instruction or not. It can happen that we
added jump history entry because current instruction is_jmp_point(), but
also we need to add instruction flags for stack access. In this case, we
don't want to entries, so we need to reuse last added entry, if it is
present.

Relying on insn_idx comparison has the same ambiguity problem as the one
that was fixed recently in [0], so we avoid that.

  [0] https://patchwork.kernel.org/project/netdevbpf/patch/20231110002638.4168352-3-andrii@kernel.org/</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('9fbdef1b4b4075884bed61f567f71a378896892c')">
                                    <div class="issue-number">115</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="9fbdef1b4b4075884bed61f567f71a378896892c">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A use-after-free flaw was found in lan78xx_disconnect in drivers/net/usb/lan78xx.c in the network sub-component, net/usb/lan78xx in the Linux Kernel. This flaw allows a local attacker to crash the system when the LAN78XX USB device detaches.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('0441812745523b6c24b59168badab73e6bd8aa9c')">
                                    <div class="issue-number">116</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="0441812745523b6c24b59168badab73e6bd8aa9c">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A Marvin vulnerability side-channel leakage was found in the RSA decryption operation in the Linux Kernel. This issue may allow a network attacker to decrypt ciphertexts or forge signatures, limiting the services that use that private key.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('793995727d8fad942a11762b2affce538ca5668a')">
                                    <div class="issue-number">117</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="793995727d8fad942a11762b2affce538ca5668a">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A flaw was found in the Linux kernel's memory deduplication mechanism. The max page sharing of Kernel Samepage Merging (KSM), added in Linux kernel version 4.4.0-96.119, can create a side channel. When the attacker and the victim share the same host and the default setting of KSM is "max page sharing=256", it is possible for the attacker to time the unmap to merge with the victim's page. The unmapping time depends on whether it merges with the victim's page and additional physical pages are created beyond the KSM's "max page share". Through these operations, the attacker can leak the victim's page.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('e877a1eca643b03d01e2150cef71f2dab02cda67')">
                                    <div class="issue-number">118</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="e877a1eca643b03d01e2150cef71f2dab02cda67">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A Speculative Race Condition (SRC) vulnerability that impacts modern CPU architectures supporting speculative execution (related to Spectre V1) has been disclosed. An unauthenticated attacker can exploit this vulnerability to disclose arbitrary data from the CPU using race conditions to access the speculative executable code paths.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('a9aee136fa1f6f3e5b9e1ebe54405bf077cbecb1')">
                                    <div class="issue-number">119</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="a9aee136fa1f6f3e5b9e1ebe54405bf077cbecb1">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A race condition was found in the Linux kernel's drm/exynos device driver in exynos_drm_crtc_atomic_disable() function. This can result in a null pointer dereference issue, possibly leading to a kernel panic or denial of service issue.


</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('fda75691eab3bd285423dcbab30dac07d5d8b570')">
                                    <div class="issue-number">120</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="fda75691eab3bd285423dcbab30dac07d5d8b570">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A race condition was found in the Linux kernel's scsi device driver in lpfc_unregister_fcf_rescan() function. This can result in a null pointer dereference issue, possibly leading to a kernel panic or denial of service issue.




</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('fd8c95f16f6b98afc54a8bed1a526d3d92d98608')">
                                    <div class="issue-number">121</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="fd8c95f16f6b98afc54a8bed1a526d3d92d98608">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A race condition was found in the Linux kernel's media/dvb-core in dvbdmx_write() function. This can result in a null pointer dereference issue, possibly leading to a kernel panic or denial of service issue.




</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('c1ebb7e24f45b33d8e8d49865c9b3632fea5b955')">
                                    <div class="issue-number">122</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="c1ebb7e24f45b33d8e8d49865c9b3632fea5b955">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A memory leak flaw was found in the UBI driver in drivers/mtd/ubi/attach.c in the Linux kernel through 6.7.4 for UBI_IOCATT, because kobj->name is not released.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('9fa1fe3bf5035d8d47c44791e92aeba29f9c252a')">
                                    <div class="issue-number">123</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="9fa1fe3bf5035d8d47c44791e92aeba29f9c252a">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

mlxsw: spectrum_acl_tcam: Fix NULL pointer dereference in error path

When calling mlxsw_sp_acl_tcam_region_destroy() from an error path after
failing to attach the region to an ACL group, we hit a NULL pointer
dereference upon 'region->group->tcam' [1].

Fix by retrieving the 'tcam' pointer using mlxsw_sp_acl_to_tcam().

[1]
BUG: kernel NULL pointer dereference, address: 0000000000000000
[...]
RIP: 0010:mlxsw_sp_acl_tcam_region_destroy+0xa0/0xd0
[...]
Call Trace:
 mlxsw_sp_acl_tcam_vchunk_get+0x88b/0xa20
 mlxsw_sp_acl_tcam_ventry_add+0x25/0xe0
 mlxsw_sp_acl_rule_add+0x47/0x240
 mlxsw_sp_flower_replace+0x1a9/0x1d0
 tc_setup_cb_add+0xdc/0x1c0
 fl_hw_replace_filter+0x146/0x1f0
 fl_change+0xc17/0x1360
 tc_new_tfilter+0x472/0xb90
 rtnetlink_rcv_msg+0x313/0x3b0
 netlink_rcv_skb+0x58/0x100
 netlink_unicast+0x244/0x390
 netlink_sendmsg+0x1e4/0x440
 ____sys_sendmsg+0x164/0x260
 ___sys_sendmsg+0x9a/0xe0
 __sys_sendmsg+0x7a/0xc0
 do_syscall_64+0x40/0xe0
 entry_SYSCALL_64_after_hwframe+0x63/0x6b</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('f5a1800654ab7f47a07d1bf3316cfdcdba6b3bb5')">
                                    <div class="issue-number">124</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="f5a1800654ab7f47a07d1bf3316cfdcdba6b3bb5">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

net: dsa: fix netdev_priv() dereference before check on non-DSA netdevice events

After the blamed commit, we started doing this dereference for every
NETDEV_CHANGEUPPER and NETDEV_PRECHANGEUPPER event in the system.

static inline struct dsa_port *dsa_user_to_port(const struct net_device *dev)
{
	struct dsa_user_priv *p = netdev_priv(dev);

	return p->dp;
}

Which is obviously bogus, because not all net_devices have a netdev_priv()
of type struct dsa_user_priv. But struct dsa_user_priv is fairly small,
and p->dp means dereferencing 8 bytes starting with offset 16. Most
drivers allocate that much private memory anyway, making our access not
fault, and we discard the bogus data quickly afterwards, so this wasn't
caught.

But the dummy interface is somewhat special in that it calls
alloc_netdev() with a priv size of 0. So every netdev_priv() dereference
is invalid, and we get this when we emit a NETDEV_PRECHANGEUPPER event
with a VLAN as its new upper:

$ ip link add dummy1 type dummy
$ ip link add link dummy1 name dummy1.100 type vlan id 100
[   43.309174] ==================================================================
[   43.316456] BUG: KASAN: slab-out-of-bounds in dsa_user_prechangeupper+0x30/0xe8
[   43.323835] Read of size 8 at addr ffff3f86481d2990 by task ip/374
[   43.330058]
[   43.342436] Call trace:
[   43.366542]  dsa_user_prechangeupper+0x30/0xe8
[   43.371024]  dsa_user_netdevice_event+0xb38/0xee8
[   43.375768]  notifier_call_chain+0xa4/0x210
[   43.379985]  raw_notifier_call_chain+0x24/0x38
[   43.384464]  __netdev_upper_dev_link+0x3ec/0x5d8
[   43.389120]  netdev_upper_dev_link+0x70/0xa8
[   43.393424]  register_vlan_dev+0x1bc/0x310
[   43.397554]  vlan_newlink+0x210/0x248
[   43.401247]  rtnl_newlink+0x9fc/0xe30
[   43.404942]  rtnetlink_rcv_msg+0x378/0x580

Avoid the kernel oops by dereferencing after the type check, as customary.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('5283927ab24a45882e3f72c927a41f84c6cd2be6')">
                                    <div class="issue-number">125</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="5283927ab24a45882e3f72c927a41f84c6cd2be6">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

arm64/sme: Always exit sme_alloc() early with existing storage

When sme_alloc() is called with existing storage and we are not flushing we
will always allocate new storage, both leaking the existing storage and
corrupting the state. Fix this by separating the checks for flushing and
for existing storage as we do for SVE.

Callers that reallocate (eg, due to changing the vector length) should
call sme_free() themselves.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('50e99e6e2e3db3ecb48b469e8c3c0d2b7a79253e')">
                                    <div class="issue-number">126</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="50e99e6e2e3db3ecb48b469e8c3c0d2b7a79253e">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Fix late derefrence 'dsc' check in 'link_set_dsc_pps_packet()'

In link_set_dsc_pps_packet(), 'struct display_stream_compressor *dsc'
was dereferenced in a DC_LOGGER_INIT(dsc->ctx->logger); before the 'dsc'
NULL pointer check.

Fixes the below:
drivers/gpu/drm/amd/amdgpu/../display/dc/link/link_dpms.c:905 link_set_dsc_pps_packet() warn: variable dereferenced before check 'dsc' (see line 903)</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('2d053e9274071a7022bd3546478224ef8283d1c1')">
                                    <div class="issue-number">127</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="2d053e9274071a7022bd3546478224ef8283d1c1">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Fix variable deferencing before NULL check in edp_setup_replay()

In edp_setup_replay(), 'struct dc *dc' & 'struct dmub_replay *replay'
was dereferenced before the pointer 'link' & 'replay' NULL check.

Fixes the below:
drivers/gpu/drm/amd/amdgpu/../display/dc/link/protocols/link_edp_panel_control.c:947 edp_setup_replay() warn: variable dereferenced before check 'link' (see line 933)</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('dda862da7003c7b7657de4b0b3628c941c0ed5b0')">
                                    <div class="issue-number">128</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="dda862da7003c7b7657de4b0b3628c941c0ed5b0">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amdgpu: fix use-after-free bug

The bug can be triggered by sending a single amdgpu_gem_userptr_ioctl
to the AMDGPU DRM driver on any ASICs with an invalid address and size.
The bug was reported by Joonkyo Jung <joonkyoj@yonsei.ac.kr>.
For example the following code:

static void Syzkaller1(int fd)
{
	struct drm_amdgpu_gem_userptr arg;
	int ret;

	arg.addr = 0xffffffffffff0000;
	arg.size = 0x80000000; /*2 Gb*/
	arg.flags = 0x7;
	ret = drmIoctl(fd, 0xc1186451/*amdgpu_gem_userptr_ioctl*/, &arg);
}

Due to the address and size are not valid there is a failure in
amdgpu_hmm_register->mmu_interval_notifier_insert->__mmu_interval_notifier_insert->
check_shl_overflow, but we even the amdgpu_hmm_register failure we still call
amdgpu_hmm_unregister into  amdgpu_gem_object_free which causes access to a bad address.
The following stack is below when the issue is reproduced when Kazan is enabled:

[  +0.000014] Hardware name: ASUS System Product Name/ROG STRIX B550-F GAMING (WI-FI), BIOS 1401 12/03/2020
[  +0.000009] RIP: 0010:mmu_interval_notifier_remove+0x327/0x340
[  +0.000017] Code: ff ff 49 89 44 24 08 48 b8 00 01 00 00 00 00 ad de 4c 89 f7 49 89 47 40 48 83 c0 22 49 89 47 48 e8 ce d1 2d 01 e9 32 ff ff ff <0f> 0b e9 16 ff ff ff 4c 89 ef e8 fa 14 b3 ff e9 36 ff ff ff e8 80
[  +0.000014] RSP: 0018:ffffc90002657988 EFLAGS: 00010246
[  +0.000013] RAX: 0000000000000000 RBX: 1ffff920004caf35 RCX: ffffffff8160565b
[  +0.000011] RDX: dffffc0000000000 RSI: 0000000000000004 RDI: ffff8881a9f78260
[  +0.000010] RBP: ffffc90002657a70 R08: 0000000000000001 R09: fffff520004caf25
[  +0.000010] R10: 0000000000000003 R11: ffffffff8161d1d6 R12: ffff88810e988c00
[  +0.000010] R13: ffff888126fb5a00 R14: ffff88810e988c0c R15: ffff8881a9f78260
[  +0.000011] FS:  00007ff9ec848540(0000) GS:ffff8883cc880000(0000) knlGS:0000000000000000
[  +0.000012] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[  +0.000010] CR2: 000055b3f7e14328 CR3: 00000001b5770000 CR4: 0000000000350ef0
[  +0.000010] Call Trace:
[  +0.000006]  <TASK>
[  +0.000007]  ? show_regs+0x6a/0x80
[  +0.000018]  ? __warn+0xa5/0x1b0
[  +0.000019]  ? mmu_interval_notifier_remove+0x327/0x340
[  +0.000018]  ? report_bug+0x24a/0x290
[  +0.000022]  ? handle_bug+0x46/0x90
[  +0.000015]  ? exc_invalid_op+0x19/0x50
[  +0.000016]  ? asm_exc_invalid_op+0x1b/0x20
[  +0.000017]  ? kasan_save_stack+0x26/0x50
[  +0.000017]  ? mmu_interval_notifier_remove+0x23b/0x340
[  +0.000019]  ? mmu_interval_notifier_remove+0x327/0x340
[  +0.000019]  ? mmu_interval_notifier_remove+0x23b/0x340
[  +0.000020]  ? __pfx_mmu_interval_notifier_remove+0x10/0x10
[  +0.000017]  ? kasan_save_alloc_info+0x1e/0x30
[  +0.000018]  ? srso_return_thunk+0x5/0x5f
[  +0.000014]  ? __kasan_kmalloc+0xb1/0xc0
[  +0.000018]  ? srso_return_thunk+0x5/0x5f
[  +0.000013]  ? __kasan_check_read+0x11/0x20
[  +0.000020]  amdgpu_hmm_unregister+0x34/0x50 [amdgpu]
[  +0.004695]  amdgpu_gem_object_free+0x66/0xa0 [amdgpu]
[  +0.004534]  ? __pfx_amdgpu_gem_object_free+0x10/0x10 [amdgpu]
[  +0.004291]  ? do_syscall_64+0x5f/0xe0
[  +0.000023]  ? srso_return_thunk+0x5/0x5f
[  +0.000017]  drm_gem_object_free+0x3b/0x50 [drm]
[  +0.000489]  amdgpu_gem_userptr_ioctl+0x306/0x500 [amdgpu]
[  +0.004295]  ? __pfx_amdgpu_gem_userptr_ioctl+0x10/0x10 [amdgpu]
[  +0.004270]  ? srso_return_thunk+0x5/0x5f
[  +0.000014]  ? __this_cpu_preempt_check+0x13/0x20
[  +0.000015]  ? srso_return_thunk+0x5/0x5f
[  +0.000013]  ? sysvec_apic_timer_interrupt+0x57/0xc0
[  +0.000020]  ? srso_return_thunk+0x5/0x5f
[  +0.000014]  ? asm_sysvec_apic_timer_interrupt+0x1b/0x20
[  +0.000022]  ? drm_ioctl_kernel+0x17b/0x1f0 [drm]
[  +0.000496]  ? __pfx_amdgpu_gem_userptr_ioctl+0x10/0x10 [amdgpu]
[  +0.004272]  ? drm_ioctl_kernel+0x190/0x1f0 [drm]
[  +0.000492]  drm_ioctl_kernel+0x140/0x1f0 [drm]
[  +0.000497]  ? __pfx_amdgpu_gem_userptr_ioctl+0x10/0x10 [amdgpu]
[  +0.004297]  ? __pfx_drm_ioctl_kernel+0x10/0x10 [d
---truncated---</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('40dfe2c2c8fdb8d42f90158df7b1e8f5215d0556')">
                                    <div class="issue-number">129</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="40dfe2c2c8fdb8d42f90158df7b1e8f5215d0556">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

bcachefs: grab s_umount only if snapshotting

When I was testing mongodb over bcachefs with compression,
there is a lockdep warning when snapshotting mongodb data volume.

$ cat test.sh
prog=bcachefs

$prog subvolume create /mnt/data
$prog subvolume create /mnt/data/snapshots

while true;do
    $prog subvolume snapshot /mnt/data /mnt/data/snapshots/$(date +%s)
    sleep 1s
done

$ cat /etc/mongodb.conf
systemLog:
  destination: file
  logAppend: true
  path: /mnt/data/mongod.log

storage:
  dbPath: /mnt/data/

lockdep reports:
[ 3437.452330] ======================================================
[ 3437.452750] WARNING: possible circular locking dependency detected
[ 3437.453168] 6.7.0-rc7-custom+ #85 Tainted: G            E
[ 3437.453562] ------------------------------------------------------
[ 3437.453981] bcachefs/35533 is trying to acquire lock:
[ 3437.454325] ffffa0a02b2b1418 (sb_writers#10){.+.+}-{0:0}, at: filename_create+0x62/0x190
[ 3437.454875]
               but task is already holding lock:
[ 3437.455268] ffffa0a02b2b10e0 (&type->s_umount_key#48){.+.+}-{3:3}, at: bch2_fs_file_ioctl+0x232/0xc90 [bcachefs]
[ 3437.456009]
               which lock already depends on the new lock.

[ 3437.456553]
               the existing dependency chain (in reverse order) is:
[ 3437.457054]
               -> #3 (&type->s_umount_key#48){.+.+}-{3:3}:
[ 3437.457507]        down_read+0x3e/0x170
[ 3437.457772]        bch2_fs_file_ioctl+0x232/0xc90 [bcachefs]
[ 3437.458206]        __x64_sys_ioctl+0x93/0xd0
[ 3437.458498]        do_syscall_64+0x42/0xf0
[ 3437.458779]        entry_SYSCALL_64_after_hwframe+0x6e/0x76
[ 3437.459155]
               -> #2 (&c->snapshot_create_lock){++++}-{3:3}:
[ 3437.459615]        down_read+0x3e/0x170
[ 3437.459878]        bch2_truncate+0x82/0x110 [bcachefs]
[ 3437.460276]        bchfs_truncate+0x254/0x3c0 [bcachefs]
[ 3437.460686]        notify_change+0x1f1/0x4a0
[ 3437.461283]        do_truncate+0x7f/0xd0
[ 3437.461555]        path_openat+0xa57/0xce0
[ 3437.461836]        do_filp_open+0xb4/0x160
[ 3437.462116]        do_sys_openat2+0x91/0xc0
[ 3437.462402]        __x64_sys_openat+0x53/0xa0
[ 3437.462701]        do_syscall_64+0x42/0xf0
[ 3437.462982]        entry_SYSCALL_64_after_hwframe+0x6e/0x76
[ 3437.463359]
               -> #1 (&sb->s_type->i_mutex_key#15){+.+.}-{3:3}:
[ 3437.463843]        down_write+0x3b/0xc0
[ 3437.464223]        bch2_write_iter+0x5b/0xcc0 [bcachefs]
[ 3437.464493]        vfs_write+0x21b/0x4c0
[ 3437.464653]        ksys_write+0x69/0xf0
[ 3437.464839]        do_syscall_64+0x42/0xf0
[ 3437.465009]        entry_SYSCALL_64_after_hwframe+0x6e/0x76
[ 3437.465231]
               -> #0 (sb_writers#10){.+.+}-{0:0}:
[ 3437.465471]        __lock_acquire+0x1455/0x21b0
[ 3437.465656]        lock_acquire+0xc6/0x2b0
[ 3437.465822]        mnt_want_write+0x46/0x1a0
[ 3437.465996]        filename_create+0x62/0x190
[ 3437.466175]        user_path_create+0x2d/0x50
[ 3437.466352]        bch2_fs_file_ioctl+0x2ec/0xc90 [bcachefs]
[ 3437.466617]        __x64_sys_ioctl+0x93/0xd0
[ 3437.466791]        do_syscall_64+0x42/0xf0
[ 3437.466957]        entry_SYSCALL_64_after_hwframe+0x6e/0x76
[ 3437.467180]
               other info that might help us debug this:

[ 3437.469670] 2 locks held by bcachefs/35533:
               other info that might help us debug this:

[ 3437.467507] Chain exists of:
                 sb_writers#10 --> &c->snapshot_create_lock --> &type->s_umount_key#48

[ 3437.467979]  Possible unsafe locking scenario:

[ 3437.468223]        CPU0                    CPU1
[ 3437.468405]        ----                    ----
[ 3437.468585]   rlock(&type->s_umount_key#48);
[ 3437.468758]                                lock(&c->snapshot_create_lock);
[ 3437.469030]                                lock(&type->s_umount_key#48);
[ 3437.469291]   rlock(sb_writers#10);
[ 3437.469434]
                *** DEADLOCK ***

[ 3437.469
---truncated---</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('3a4bbc60e571fa5233f2985c632af3e6002997cf')">
                                    <div class="issue-number">130</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="3a4bbc60e571fa5233f2985c632af3e6002997cf">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Add NULL test for 'timing generator' in 'dcn21_set_pipe()'

In "u32 otg_inst = pipe_ctx->stream_res.tg->inst;"
pipe_ctx->stream_res.tg could be NULL, it is relying on the caller to
ensure the tg is not NULL.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('2f2d7ecd8f23a5a18bdb8f2dbd36ccfaaea086a2')">
                                    <div class="issue-number">131</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="2f2d7ecd8f23a5a18bdb8f2dbd36ccfaaea086a2">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Fix 'panel_cntl' could be null in 'dcn21_set_backlight_level()'

'panel_cntl' structure used to control the display panel could be null,
dereferencing it could lead to a null pointer access.

Fixes the below:
drivers/gpu/drm/amd/amdgpu/../display/dc/hwss/dcn21/dcn21_hwseq.c:269 dcn21_set_backlight_level() error: we previously assumed 'panel_cntl' could be null (see line 250)</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('ce378940a033de73ee98a19dee40e65411db31d3')">
                                    <div class="issue-number">132</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="ce378940a033de73ee98a19dee40e65411db31d3">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

arm64: entry: fix ARM64_WORKAROUND_SPECULATIVE_UNPRIV_LOAD

Currently the ARM64_WORKAROUND_SPECULATIVE_UNPRIV_LOAD workaround isn't
quite right, as it is supposed to be applied after the last explicit
memory access, but is immediately followed by an LDR.

The ARM64_WORKAROUND_SPECULATIVE_UNPRIV_LOAD workaround is used to
handle Cortex-A520 erratum 2966298 and Cortex-A510 erratum 3117295,
which are described in:

* https://developer.arm.com/documentation/SDEN2444153/0600/?lang=en
* https://developer.arm.com/documentation/SDEN1873361/1600/?lang=en

In both cases the workaround is described as:

| If pagetable isolation is disabled, the context switch logic in the
| kernel can be updated to execute the following sequence on affected
| cores before exiting to EL0, and after all explicit memory accesses:
|
| 1. A non-shareable TLBI to any context and/or address, including
|    unused contexts or addresses, such as a `TLBI VALE1 Xzr`.
|
| 2. A DSB NSH to guarantee completion of the TLBI.

The important part being that the TLBI+DSB must be placed "after all
explicit memory accesses".

Unfortunately, as-implemented, the TLBI+DSB is immediately followed by
an LDR, as we have:

| alternative_if ARM64_WORKAROUND_SPECULATIVE_UNPRIV_LOAD
| 	tlbi	vale1, xzr
| 	dsb	nsh
| alternative_else_nop_endif
| alternative_if_not ARM64_UNMAP_KERNEL_AT_EL0
| 	ldr	lr, [sp, #S_LR]
| 	add	sp, sp, #PT_REGS_SIZE		// restore sp
| 	eret
| alternative_else_nop_endif
|
| [ ... KPTI exception return path ... ]

This patch fixes this by reworking the logic to place the TLBI+DSB
immediately before the ERET, after all explicit memory accesses.

The ERET is currently in a separate alternative block, and alternatives
cannot be nested. To account for this, the alternative block for
ARM64_UNMAP_KERNEL_AT_EL0 is replaced with a single alternative branch
to skip the KPTI logic, with the new shape of the logic being:

| alternative_insn "b .L_skip_tramp_exit_\@", nop, ARM64_UNMAP_KERNEL_AT_EL0
| 	[ ... KPTI exception return path ... ]
| .L_skip_tramp_exit_\@:
|
| 	ldr	lr, [sp, #S_LR]
| 	add	sp, sp, #PT_REGS_SIZE		// restore sp
|
| alternative_if ARM64_WORKAROUND_SPECULATIVE_UNPRIV_LOAD
| 	tlbi	vale1, xzr
| 	dsb	nsh
| alternative_else_nop_endif
| 	eret

The new structure means that the workaround is only applied when KPTI is
not in use; this is fine as noted in the documented implications of the
erratum:

| Pagetable isolation between EL0 and higher level ELs prevents the
| issue from occurring.

... and as per the workaround description quoted above, the workaround
is only necessary "If pagetable isolation is disabled".</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('32b5103741ad7d2a6dffc80a673ecaa28dcc81f6')">
                                    <div class="issue-number">133</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="32b5103741ad7d2a6dffc80a673ecaa28dcc81f6">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amdgpu: Fix variable 'mca_funcs' dereferenced before NULL check in 'amdgpu_mca_smu_get_mca_entry()'

Fixes the below:

drivers/gpu/drm/amd/amdgpu/amdgpu_mca.c:377 amdgpu_mca_smu_get_mca_entry() warn: variable dereferenced before check 'mca_funcs' (see line 368)

357 int amdgpu_mca_smu_get_mca_entry(struct amdgpu_device *adev,
				     enum amdgpu_mca_error_type type,
358                                  int idx, struct mca_bank_entry *entry)
359 {
360         const struct amdgpu_mca_smu_funcs *mca_funcs =
						adev->mca.mca_funcs;
361         int count;
362
363         switch (type) {
364         case AMDGPU_MCA_ERROR_TYPE_UE:
365                 count = mca_funcs->max_ue_count;

mca_funcs is dereferenced here.

366                 break;
367         case AMDGPU_MCA_ERROR_TYPE_CE:
368                 count = mca_funcs->max_ce_count;

mca_funcs is dereferenced here.

369                 break;
370         default:
371                 return -EINVAL;
372         }
373
374         if (idx >= count)
375                 return -EINVAL;
376
377         if (mca_funcs && mca_funcs->mca_get_mca_entry)
	        ^^^^^^^^^

Checked too late!</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('bdc00b875577890f4a86f7e298805a61266e6658')">
                                    <div class="issue-number">134</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="bdc00b875577890f4a86f7e298805a61266e6658">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

rxrpc: Fix delayed ACKs to not set the reference serial number

Fix the construction of delayed ACKs to not set the reference serial number
as they can't be used as an RTT reference.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('6d8b7b6971d91050392f1e34f83aa970485737d9')">
                                    <div class="issue-number">135</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="6d8b7b6971d91050392f1e34f83aa970485737d9">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

KVM: arm64: Fix circular locking dependency

The rule inside kvm enforces that the vcpu->mutex is taken *inside*
kvm->lock. The rule is violated by the pkvm_create_hyp_vm() which acquires
the kvm->lock while already holding the vcpu->mutex lock from
kvm_vcpu_ioctl(). Avoid the circular locking dependency altogether by
protecting the hyp vm handle with the config_lock, much like we already
do for other forms of VM-scoped data.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('965a51e79b0b195459c67fd9428d4a5d271f814f')">
                                    <div class="issue-number">136</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="965a51e79b0b195459c67fd9428d4a5d271f814f">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Fix array-index-out-of-bounds in dcn35_clkmgr

[Why]
There is a potential memory access violation while
iterating through array of dcn35 clks.

[How]
Limit iteration per array size.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('3b90809d20162d0cc4e50326560ce49499050619')">
                                    <div class="issue-number">137</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="3b90809d20162d0cc4e50326560ce49499050619">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

nouveau: offload fence uevents work to workqueue

This should break the deadlock between the fctx lock and the irq lock.

This offloads the processing off the work from the irq into a workqueue.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('91734f91768e2a4c1ce15f74d3795c3d36fc86d7')">
                                    <div class="issue-number">138</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="91734f91768e2a4c1ce15f74d3795c3d36fc86d7">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

net/sched: act_mirred: don't override retval if we already lost the skb

If we're redirecting the skb, and haven't called tcf_mirred_forward(),
yet, we need to tell the core to drop the skb by setting the retcode
to SHOT. If we have called tcf_mirred_forward(), however, the skb
is out of our hands and returning SHOT will lead to UaF.

Move the retval override to the error path which actually need it.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('41011668d3c3ed9c8416dc668f5c1694e6fb293a')">
                                    <div class="issue-number">139</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="41011668d3c3ed9c8416dc668f5c1694e6fb293a">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

net/sched: act_mirred: use the backlog for mirred ingress

The test Davide added in commit ca22da2fbd69 ("act_mirred: use the backlog
for nested calls to mirred ingress") hangs our testing VMs every 10 or so
runs, with the familiar tcp_v4_rcv -> tcp_v4_rcv deadlock reported by
lockdep.

The problem as previously described by Davide (see Link) is that
if we reverse flow of traffic with the redirect (egress -> ingress)
we may reach the same socket which generated the packet. And we may
still be holding its socket lock. The common solution to such deadlocks
is to put the packet in the Rx backlog, rather than run the Rx path
inline. Do that for all egress -> ingress reversals, not just once
we started to nest mirred calls.

In the past there was a concern that the backlog indirection will
lead to loss of error reporting / less accurate stats. But the current
workaround does not seem to address the issue.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('b8d780fa67102c5ace1dcaa8449be59e9a19bc47')">
                                    <div class="issue-number">140</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="b8d780fa67102c5ace1dcaa8449be59e9a19bc47">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

md: Don't register sync_thread for reshape directly

Currently, if reshape is interrupted, then reassemble the array will
register sync_thread directly from pers->run(), in this case
'MD_RECOVERY_RUNNING' is set directly, however, there is no guarantee
that md_do_sync() will be executed, hence stop_sync_thread() will hang
because 'MD_RECOVERY_RUNNING' can't be cleared.

Last patch make sure that md_do_sync() will set MD_RECOVERY_DONE,
however, following hang can still be triggered by dm-raid test
shell/lvconvert-raid-reshape.sh occasionally:

[root@fedora ~]# cat /proc/1982/stack
[<0>] stop_sync_thread+0x1ab/0x270 [md_mod]
[<0>] md_frozen_sync_thread+0x5c/0xa0 [md_mod]
[<0>] raid_presuspend+0x1e/0x70 [dm_raid]
[<0>] dm_table_presuspend_targets+0x40/0xb0 [dm_mod]
[<0>] __dm_destroy+0x2a5/0x310 [dm_mod]
[<0>] dm_destroy+0x16/0x30 [dm_mod]
[<0>] dev_remove+0x165/0x290 [dm_mod]
[<0>] ctl_ioctl+0x4bb/0x7b0 [dm_mod]
[<0>] dm_ctl_ioctl+0x11/0x20 [dm_mod]
[<0>] vfs_ioctl+0x21/0x60
[<0>] __x64_sys_ioctl+0xb9/0xe0
[<0>] do_syscall_64+0xc6/0x230
[<0>] entry_SYSCALL_64_after_hwframe+0x6c/0x74

Meanwhile mddev->recovery is:
MD_RECOVERY_RUNNING |
MD_RECOVERY_INTR |
MD_RECOVERY_RESHAPE |
MD_RECOVERY_FROZEN

Fix this problem by remove the code to register sync_thread directly
from raid10 and raid5. And let md_check_recovery() to register
sync_thread.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('457af18c22b3fc4ad88c842df4f3df40c20a541e')">
                                    <div class="issue-number">141</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="457af18c22b3fc4ad88c842df4f3df40c20a541e">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

md: Don't ignore read-only array in md_check_recovery()

Usually if the array is not read-write, md_check_recovery() won't
register new sync_thread in the first place. And if the array is
read-write and sync_thread is registered, md_set_readonly() will
unregister sync_thread before setting the array read-only. md/raid
follow this behavior hence there is no problem.

After commit f52f5c71f3d4 ("md: fix stopping sync thread"), following
hang can be triggered by test shell/integrity-caching.sh:

1) array is read-only. dm-raid update super block:
rs_update_sbs
 ro = mddev->ro
 mddev->ro = 0
  -> set array read-write
 md_update_sb

2) register new sync thread concurrently.

3) dm-raid set array back to read-only:
rs_update_sbs
 mddev->ro = ro

4) stop the array:
raid_dtr
 md_stop
  stop_sync_thread
    set_bit(MD_RECOVERY_INTR, &mddev->recovery);
    md_wakeup_thread_directly(mddev->sync_thread);
    wait_event(..., !test_bit(MD_RECOVERY_RUNNING, &mddev->recovery))

5) sync thread done:
 md_do_sync
 set_bit(MD_RECOVERY_DONE, &mddev->recovery);
 md_wakeup_thread(mddev->thread);

6) daemon thread can't unregister sync thread:
 md_check_recovery
  if (!md_is_rdwr(mddev) &&
      !test_bit(MD_RECOVERY_NEEDED, &mddev->recovery))
   return;
  -> -> MD_RECOVERY_RUNNING can't be cleared, hence step 4 hang;

The root cause is that dm-raid manipulate 'mddev->ro' by itself,
however, dm-raid really should stop sync thread before setting the
array read-only. Unfortunately, I need to read more code before I
can refacter the handler of 'mddev->ro' in dm-raid, hence let's fix
the problem the easy way for now to prevent dm-raid regression.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('17f28eadfbc77aa0bfc2add9d873c987122f274f')">
                                    <div class="issue-number">142</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="17f28eadfbc77aa0bfc2add9d873c987122f274f">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

md: Don't ignore suspended array in md_check_recovery()

mddev_suspend() never stop sync_thread, hence it doesn't make sense to
ignore suspended array in md_check_recovery(), which might cause
sync_thread can't be unregistered.

After commit f52f5c71f3d4 ("md: fix stopping sync thread"), following
hang can be triggered by test shell/integrity-caching.sh:

1) suspend the array:
raid_postsuspend
 mddev_suspend

2) stop the array:
raid_dtr
 md_stop
  __md_stop_writes
   stop_sync_thread
    set_bit(MD_RECOVERY_INTR, &mddev->recovery);
    md_wakeup_thread_directly(mddev->sync_thread);
    wait_event(..., !test_bit(MD_RECOVERY_RUNNING, &mddev->recovery))

3) sync thread done:
md_do_sync
 set_bit(MD_RECOVERY_DONE, &mddev->recovery);
 md_wakeup_thread(mddev->thread);

4) daemon thread can't unregister sync thread:
md_check_recovery
 if (mddev->suspended)
   return; -> return directly
 md_read_sync_thread
 clear_bit(MD_RECOVERY_RUNNING, &mddev->recovery);
 -> MD_RECOVERY_RUNNING can't be cleared, hence step 2 hang;

This problem is not just related to dm-raid, fix it by ignoring
suspended array in md_check_recovery(). And follow up patches will
improve dm-raid better to frozen sync thread during suspend.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('f9387b1bbb7d0a5c9cef0f1496dc2a3c7e98614e')">
                                    <div class="issue-number">143</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="f9387b1bbb7d0a5c9cef0f1496dc2a3c7e98614e">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: fixed integer types and null check locations

[why]:
issues fixed:
- comparison with wider integer type in loop condition which can cause
infinite loops
- pointer dereference before null check</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('e97a88ef4211a03cf48259f13bc4605735f57bcc')">
                                    <div class="issue-number">144</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="e97a88ef4211a03cf48259f13bc4605735f57bcc">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

LoongArch: Change acpi_core_pic[NR_CPUS] to acpi_core_pic[MAX_CORE_PIC]

With default config, the value of NR_CPUS is 64. When HW platform has
more then 64 cpus, system will crash on these platforms. MAX_CORE_PIC
is the maximum cpu number in MADT table (max physical number) which can
exceed the supported maximum cpu number (NR_CPUS, max logical number),
but kernel should not crash. Kernel should boot cpus with NR_CPUS, let
the remainder cpus stay in BIOS.

The potential crash reason is that the array acpi_core_pic[NR_CPUS] can
be overflowed when parsing MADT table, and it is obvious that CORE_PIC
should be corresponding to physical core rather than logical core, so it
is better to define the array as acpi_core_pic[MAX_CORE_PIC].

With the patch, system can boot up 64 vcpus with qemu parameter -smp 128,
otherwise system will crash with the following message.

[    0.000000] CPU 0 Unable to handle kernel paging request at virtual address 0000420000004259, era == 90000000037a5f0c, ra == 90000000037a46ec
[    0.000000] Oops[#1]:
[    0.000000] CPU: 0 PID: 0 Comm: swapper Not tainted 6.8.0-rc2+ #192
[    0.000000] Hardware name: QEMU QEMU Virtual Machine, BIOS unknown 2/2/2022
[    0.000000] pc 90000000037a5f0c ra 90000000037a46ec tp 9000000003c90000 sp 9000000003c93d60
[    0.000000] a0 0000000000000019 a1 9000000003d93bc0 a2 0000000000000000 a3 9000000003c93bd8
[    0.000000] a4 9000000003c93a74 a5 9000000083c93a67 a6 9000000003c938f0 a7 0000000000000005
[    0.000000] t0 0000420000004201 t1 0000000000000000 t2 0000000000000001 t3 0000000000000001
[    0.000000] t4 0000000000000003 t5 0000000000000000 t6 0000000000000030 t7 0000000000000063
[    0.000000] t8 0000000000000014 u0 ffffffffffffffff s9 0000000000000000 s0 9000000003caee98
[    0.000000] s1 90000000041b0480 s2 9000000003c93da0 s3 9000000003c93d98 s4 9000000003c93d90
[    0.000000] s5 9000000003caa000 s6 000000000a7fd000 s7 000000000f556b60 s8 000000000e0a4330
[    0.000000]    ra: 90000000037a46ec platform_init+0x214/0x250
[    0.000000]   ERA: 90000000037a5f0c efi_runtime_init+0x30/0x94
[    0.000000]  CRMD: 000000b0 (PLV0 -IE -DA +PG DACF=CC DACM=CC -WE)
[    0.000000]  PRMD: 00000000 (PPLV0 -PIE -PWE)
[    0.000000]  EUEN: 00000000 (-FPE -SXE -ASXE -BTE)
[    0.000000]  ECFG: 00070800 (LIE=11 VS=7)
[    0.000000] ESTAT: 00010000 [PIL] (IS= ECode=1 EsubCode=0)
[    0.000000]  BADV: 0000420000004259
[    0.000000]  PRID: 0014c010 (Loongson-64bit, Loongson-3A5000)
[    0.000000] Modules linked in:
[    0.000000] Process swapper (pid: 0, threadinfo=(____ptrval____), task=(____ptrval____))
[    0.000000] Stack : 9000000003c93a14 9000000003800898 90000000041844f8 90000000037a46ec
[    0.000000]         000000000a7fd000 0000000008290000 0000000000000000 0000000000000000
[    0.000000]         0000000000000000 0000000000000000 00000000019d8000 000000000f556b60
[    0.000000]         000000000a7fd000 000000000f556b08 9000000003ca7700 9000000003800000
[    0.000000]         9000000003c93e50 9000000003800898 9000000003800108 90000000037a484c
[    0.000000]         000000000e0a4330 000000000f556b60 000000000a7fd000 000000000f556b08
[    0.000000]         9000000003ca7700 9000000004184000 0000000000200000 000000000e02b018
[    0.000000]         000000000a7fd000 90000000037a0790 9000000003800108 0000000000000000
[    0.000000]         0000000000000000 000000000e0a4330 000000000f556b60 000000000a7fd000
[    0.000000]         000000000f556b08 000000000eaae298 000000000eaa5040 0000000000200000
[    0.000000]         ...
[    0.000000] Call Trace:
[    0.000000] [<90000000037a5f0c>] efi_runtime_init+0x30/0x94
[    0.000000] [<90000000037a46ec>] platform_init+0x214/0x250
[    0.000000] [<90000000037a484c>] setup_arch+0x124/0x45c
[    0.000000] [<90000000037a0790>] start_kernel+0x90/0x670
[    0.000000] [<900000000378b0d8>] kernel_entry+0xd8/0xdc</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('19dcf8b7759c32596057b35afcebb64a4fc2b227')">
                                    <div class="issue-number">145</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="19dcf8b7759c32596057b35afcebb64a4fc2b227">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

HID: nvidia-shield: Add missing null pointer checks to LED initialization

devm_kasprintf() returns a pointer to dynamically allocated memory
which can be NULL upon failure. Ensure the allocation was successful
by checking the pointer validity.

[jkosina@suse.com: tweak changelog a bit]</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('c52d1202284fb24d97702c8cf06b86d765a1ffc5')">
                                    <div class="issue-number">146</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="c52d1202284fb24d97702c8cf06b86d765a1ffc5">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

mm/vmscan: fix a bug calling wakeup_kswapd() with a wrong zone index

With numa balancing on, when a numa system is running where a numa node
doesn't have its local memory so it has no managed zones, the following
oops has been observed.  It's because wakeup_kswapd() is called with a
wrong zone index, -1.  Fixed it by checking the index before calling
wakeup_kswapd().

> BUG: unable to handle page fault for address: 00000000000033f3
> #PF: supervisor read access in kernel mode
> #PF: error_code(0x0000) - not-present page
> PGD 0 P4D 0
> Oops: 0000 [#1] PREEMPT SMP NOPTI
> CPU: 2 PID: 895 Comm: masim Not tainted 6.6.0-dirty #255
> Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS
>    rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014
> RIP: 0010:wakeup_kswapd (./linux/mm/vmscan.c:7812)
> Code: (omitted)
> RSP: 0000:ffffc90004257d58 EFLAGS: 00010286
> RAX: ffffffffffffffff RBX: ffff88883fff0480 RCX: 0000000000000003
> RDX: 0000000000000000 RSI: 0000000000000000 RDI: ffff88883fff0480
> RBP: ffffffffffffffff R08: ff0003ffffffffff R09: ffffffffffffffff
> R10: ffff888106c95540 R11: 0000000055555554 R12: 0000000000000003
> R13: 0000000000000000 R14: 0000000000000000 R15: ffff88883fff0940
> FS:  00007fc4b8124740(0000) GS:ffff888827c00000(0000) knlGS:0000000000000000
> CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
> CR2: 00000000000033f3 CR3: 000000026cc08004 CR4: 0000000000770ee0
> DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
> DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
> PKRU: 55555554
> Call Trace:
>  <TASK>
> ? __die
> ? page_fault_oops
> ? __pte_offset_map_lock
> ? exc_page_fault
> ? asm_exc_page_fault
> ? wakeup_kswapd
> migrate_misplaced_page
> __handle_mm_fault
> handle_mm_fault
> do_user_addr_fault
> exc_page_fault
> asm_exc_page_fault
> RIP: 0033:0x55b897ba0808
> Code: (omitted)
> RSP: 002b:00007ffeefa821a0 EFLAGS: 00010287
> RAX: 000055b89983acd0 RBX: 00007ffeefa823f8 RCX: 000055b89983acd0
> RDX: 00007fc2f8122010 RSI: 0000000000020000 RDI: 000055b89983acd0
> RBP: 00007ffeefa821a0 R08: 0000000000000037 R09: 0000000000000075
> R10: 0000000000000000 R11: 0000000000000202 R12: 0000000000000000
> R13: 00007ffeefa82410 R14: 000055b897ba5dd8 R15: 00007fc4b8340000
>  </TASK></p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('af889842928959d098cac64713a068e95e0c8a7c')">
                                    <div class="issue-number">147</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="af889842928959d098cac64713a068e95e0c8a7c">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

ASoC: qcom: Fix uninitialized pointer dmactl

In the case where __lpass_get_dmactl_handle is called and the driver
id dai_id is invalid the pointer dmactl is not being assigned a value,
and dmactl contains a garbage value since it has not been initialized
and so the null check may not work. Fix this to initialize dmactl to
NULL. One could argue that modern compilers will set this to zero, but
it is useful to keep this initialized as per the same way in functions
__lpass_platform_codec_intf_init and lpass_cdc_dma_daiops_hw_params.

Cleans up clang scan build warning:
sound/soc/qcom/lpass-cdc-dma.c:275:7: warning: Branch condition
evaluates to a garbage value [core.uninitialized.Branch]</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('e717385f56fea00fe54081c5a7a6d4f94b3d510a')">
                                    <div class="issue-number">148</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="e717385f56fea00fe54081c5a7a6d4f94b3d510a">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

Both cadence-quadspi ->runtime_suspend() and ->runtime_resume()
implementations start with:

	struct cqspi_st *cqspi = dev_get_drvdata(dev);
	struct spi_controller *host = dev_get_drvdata(dev);

This obviously cannot be correct, unless "struct cqspi_st" is the
first member of " struct spi_controller", or the other way around, but
it is not the case. "struct spi_controller" is allocated by
devm_spi_alloc_host(), which allocates an extra amount of memory for
private data, used to store "struct cqspi_st".

The ->probe() function of the cadence-quadspi driver then sets the
device drvdata to store the address of the "struct cqspi_st"
structure. Therefore:

	struct cqspi_st *cqspi = dev_get_drvdata(dev);

is correct, but:

	struct spi_controller *host = dev_get_drvdata(dev);

is not, as it makes "host" point not to a "struct spi_controller" but
to the same "struct cqspi_st" structure as above.

This obviously leads to bad things (memory corruption, kernel crashes)
directly during ->probe(), as ->probe() enables the device using PM
runtime, leading the ->runtime_resume() hook being called, which in
turns calls spi_controller_resume() with the wrong pointer.

This has at least been reported [0] to cause a kernel crash, but the
exact behavior will depend on the memory contents.

[0] https://lore.kernel.org/all/20240226121803.5a7r5wkpbbowcxgx@dhruva/

This issue potentially affects all platforms that are currently using
the cadence-quadspi driver.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('c70c5254401cf731be98f1a46fa5eef278207403')">
                                    <div class="issue-number">149</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="c70c5254401cf731be98f1a46fa5eef278207403">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

smb: client: set correct id, uid and cruid for multiuser automounts

When uid, gid and cruid are not specified, we need to dynamically
set them into the filesystem context used for automounting otherwise
they'll end up reusing the values from the parent mount.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('f159f3b0e63ec44e0a1c5dcac6da9385cbc4ede3')">
                                    <div class="issue-number">150</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="f159f3b0e63ec44e0a1c5dcac6da9385cbc4ede3">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

platform/x86: think-lmi: Fix password opcode ordering for workstations

The Lenovo workstations require the password opcode to be run before
the attribute value is changed (if Admin password is enabled).

Tested on some Thinkpads to confirm they are OK with this order too.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('4c8db1017b15bf1e709276d31faa4fba7aab9146')">
                                    <div class="issue-number">151</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="4c8db1017b15bf1e709276d31faa4fba7aab9146">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

LoongArch: Update cpu_sibling_map when disabling nonboot CPUs

Update cpu_sibling_map when disabling nonboot CPUs by defining & calling
clear_cpu_sibling_map(), otherwise we get such errors on SMT systems:

jump label: negative count!
WARNING: CPU: 6 PID: 45 at kernel/jump_label.c:263 __static_key_slow_dec_cpuslocked+0xec/0x100
CPU: 6 PID: 45 Comm: cpuhp/6 Not tainted 6.8.0-rc5+ #1340
pc 90000000004c302c ra 90000000004c302c tp 90000001005bc000 sp 90000001005bfd20
a0 000000000000001b a1 900000000224c278 a2 90000001005bfb58 a3 900000000224c280
a4 900000000224c278 a5 90000001005bfb50 a6 0000000000000001 a7 0000000000000001
t0 ce87a4763eb5234a t1 ce87a4763eb5234a t2 0000000000000000 t3 0000000000000000
t4 0000000000000006 t5 0000000000000000 t6 0000000000000064 t7 0000000000001964
t8 000000000009ebf6 u0 9000000001f2a068 s9 0000000000000000 s0 900000000246a2d8
s1 ffffffffffffffff s2 ffffffffffffffff s3 90000000021518c0 s4 0000000000000040
s5 9000000002151058 s6 9000000009828e40 s7 00000000000000b4 s8 0000000000000006
   ra: 90000000004c302c __static_key_slow_dec_cpuslocked+0xec/0x100
  ERA: 90000000004c302c __static_key_slow_dec_cpuslocked+0xec/0x100
 CRMD: 000000b0 (PLV0 -IE -DA +PG DACF=CC DACM=CC -WE)
 PRMD: 00000004 (PPLV0 +PIE -PWE)
 EUEN: 00000000 (-FPE -SXE -ASXE -BTE)
 ECFG: 00071c1c (LIE=2-4,10-12 VS=7)
ESTAT: 000c0000 [BRK] (IS= ECode=12 EsubCode=0)
 PRID: 0014d000 (Loongson-64bit, Loongson-3A6000-HV)
CPU: 6 PID: 45 Comm: cpuhp/6 Not tainted 6.8.0-rc5+ #1340
Stack : 0000000000000000 900000000203f258 900000000179afc8 90000001005bc000
        90000001005bf980 0000000000000000 90000001005bf988 9000000001fe0be0
        900000000224c280 900000000224c278 90000001005bf8c0 0000000000000001
        0000000000000001 ce87a4763eb5234a 0000000007f38000 90000001003f8cc0
        0000000000000000 0000000000000006 0000000000000000 4c206e6f73676e6f
        6f4c203a656d616e 000000000009ec99 0000000007f38000 0000000000000000
        900000000214b000 9000000001fe0be0 0000000000000004 0000000000000000
        0000000000000107 0000000000000009 ffffffffffafdabe 00000000000000b4
        0000000000000006 90000000004c302c 9000000000224528 00005555939a0c7c
        00000000000000b0 0000000000000004 0000000000000000 0000000000071c1c
        ...
Call Trace:
[<9000000000224528>] show_stack+0x48/0x1a0
[<900000000179afc8>] dump_stack_lvl+0x78/0xa0
[<9000000000263ed0>] __warn+0x90/0x1a0
[<90000000017419b8>] report_bug+0x1b8/0x280
[<900000000179c564>] do_bp+0x264/0x420
[<90000000004c302c>] __static_key_slow_dec_cpuslocked+0xec/0x100
[<90000000002b4d7c>] sched_cpu_deactivate+0x2fc/0x300
[<9000000000266498>] cpuhp_invoke_callback+0x178/0x8a0
[<9000000000267f70>] cpuhp_thread_fun+0xf0/0x240
[<90000000002a117c>] smpboot_thread_fn+0x1dc/0x2e0
[<900000000029a720>] kthread+0x140/0x160
[<9000000000222288>] ret_from_kernel_thread+0xc/0xa4</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('befa369ae575e3e91111bbae33e11b22d13415a6')">
                                    <div class="issue-number">152</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="befa369ae575e3e91111bbae33e11b22d13415a6">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

scsi: ufs: core: Fix shift issue in ufshcd_clear_cmd()

When task_tag >= 32 (in MCQ mode) and sizeof(unsigned int) == 4, 1U <<
task_tag will out of bounds for a u32 mask. Fix this up to prevent
SHIFT_ISSUE (bitwise shifts that are out of bounds for their data type).

[name:debug_monitors&]Unexpected kernel BRK exception at EL1
[name:traps&]Internal error: BRK handler: 00000000f2005514 [#1] PREEMPT SMP
[name:mediatek_cpufreq_hw&]cpufreq stop DVFS log done
[name:mrdump&]Kernel Offset: 0x1ba5800000 from 0xffffffc008000000
[name:mrdump&]PHYS_OFFSET: 0x80000000
[name:mrdump&]pstate: 22400005 (nzCv daif +PAN -UAO)
[name:mrdump&]pc : [0xffffffdbaf52bb2c] ufshcd_clear_cmd+0x280/0x288
[name:mrdump&]lr : [0xffffffdbaf52a774] ufshcd_wait_for_dev_cmd+0x3e4/0x82c
[name:mrdump&]sp : ffffffc0081471b0
<snip>
Workqueue: ufs_eh_wq_0 ufshcd_err_handler
Call trace:
 dump_backtrace+0xf8/0x144
 show_stack+0x18/0x24
 dump_stack_lvl+0x78/0x9c
 dump_stack+0x18/0x44
 mrdump_common_die+0x254/0x480 [mrdump]
 ipanic_die+0x20/0x30 [mrdump]
 notify_die+0x15c/0x204
 die+0x10c/0x5f8
 arm64_notify_die+0x74/0x13c
 do_debug_exception+0x164/0x26c
 el1_dbg+0x64/0x80
 el1h_64_sync_handler+0x3c/0x90
 el1h_64_sync+0x68/0x6c
 ufshcd_clear_cmd+0x280/0x288
 ufshcd_wait_for_dev_cmd+0x3e4/0x82c
 ufshcd_exec_dev_cmd+0x5bc/0x9ac
 ufshcd_verify_dev_init+0x84/0x1c8
 ufshcd_probe_hba+0x724/0x1ce0
 ufshcd_host_reset_and_restore+0x260/0x574
 ufshcd_reset_and_restore+0x138/0xbd0
 ufshcd_err_handler+0x1218/0x2f28
 process_one_work+0x5fc/0x1140
 worker_thread+0x7d8/0xe20
 kthread+0x25c/0x468
 ret_from_fork+0x10/0x20</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('d61cf38b9284c194d167d6b2b7540c4191566cfe')">
                                    <div class="issue-number">153</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="d61cf38b9284c194d167d6b2b7540c4191566cfe">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

spi: lpspi: Avoid potential use-after-free in probe()

fsl_lpspi_probe() is allocating/disposing memory manually with
spi_alloc_host()/spi_alloc_target(), but uses
devm_spi_register_controller(). In case of error after the latter call the
memory will be explicitly freed in the probe function by
spi_controller_put() call, but used afterwards by "devm" management outside
probe() (spi_unregister_controller() <- devm_spi_unregister() below).

Unable to handle kernel NULL pointer dereference at virtual address 0000000000000070
...
Call trace:
 kernfs_find_ns
 kernfs_find_and_get_ns
 sysfs_remove_group
 sysfs_remove_groups
 device_remove_attrs
 device_del
 spi_unregister_controller
 devm_spi_unregister
 release_nodes
 devres_release_all
 really_probe
 driver_probe_device
 __device_attach_driver
 bus_for_each_drv
 __device_attach
 device_initial_probe
 bus_probe_device
 deferred_probe_work_func
 process_one_work
 worker_thread
 kthread
 ret_from_fork</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('954c6ecdd3d1a333aa8dbd59d10355b8b8456676')">
                                    <div class="issue-number">154</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="954c6ecdd3d1a333aa8dbd59d10355b8b8456676">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

f2fs: fix to truncate meta inode pages forcely

Below race case can cause data corruption:

Thread A				GC thread
					- gc_data_segment
					 - ra_data_block
					  - locked meta_inode page
- f2fs_inplace_write_data
 - invalidate_mapping_pages
 : fail to invalidate meta_inode page
   due to lock failure or dirty|writeback
   status
 - f2fs_submit_page_bio
 : write last dirty data to old blkaddr
					 - move_data_block
					  - load old data from meta_inode page
					  - f2fs_submit_page_write
					  : write old data to new blkaddr

Because invalidate_mapping_pages() will skip invalidating page which
has unclear status including locked, dirty, writeback and so on, so
we need to use truncate_inode_pages_range() instead of
invalidate_mapping_pages() to make sure meta_inode page will be dropped.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('1b7af5f8e8db9710518d154a8aa763918537f334')">
                                    <div class="issue-number">155</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="1b7af5f8e8db9710518d154a8aa763918537f334">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/bridge: adv7511: fix crash on irq during probe

Moved IRQ registration down to end of adv7511_probe().

If an IRQ already is pending during adv7511_probe
(before adv7511_cec_init) then cec_received_msg_ts
could crash using uninitialized data:

    Unable to handle kernel read from unreadable memory at virtual address 00000000000003d5
    Internal error: Oops: 96000004 [#1] PREEMPT_RT SMP
    Call trace:
     cec_received_msg_ts+0x48/0x990 [cec]
     adv7511_cec_irq_process+0x1cc/0x308 [adv7511]
     adv7511_irq_process+0xd8/0x120 [adv7511]
     adv7511_irq_handler+0x1c/0x30 [adv7511]
     irq_thread_fn+0x30/0xa0
     irq_thread+0x14c/0x238
     kthread+0x190/0x1a8</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('832e489fa624d983b5c98a20d15a2b57f0d8c82d')">
                                    <div class="issue-number">156</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="832e489fa624d983b5c98a20d15a2b57f0d8c82d">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

perf: RISCV: Fix panic on pmu overflow handler

(1 << idx) of int is not desired when setting bits in unsigned long
overflowed_ctrs, use BIT() instead. This panic happens when running
'perf record -e branches' on sophgo sg2042.

[  273.311852] Unable to handle kernel NULL pointer dereference at virtual address 0000000000000098
[  273.320851] Oops [#1]
[  273.323179] Modules linked in:
[  273.326303] CPU: 0 PID: 1475 Comm: perf Not tainted 6.6.0-rc3+ #9
[  273.332521] Hardware name: Sophgo Mango (DT)
[  273.336878] epc : riscv_pmu_ctr_get_width_mask+0x8/0x62
[  273.342291]  ra : pmu_sbi_ovf_handler+0x2e0/0x34e
[  273.347091] epc : ffffffff80aecd98 ra : ffffffff80aee056 sp : fffffff6e36928b0
[  273.354454]  gp : ffffffff821f82d0 tp : ffffffd90c353200 t0 : 0000002ade4f9978
[  273.361815]  t1 : 0000000000504d55 t2 : ffffffff8016cd8c s0 : fffffff6e3692a70
[  273.369180]  s1 : 0000000000000020 a0 : 0000000000000000 a1 : 00001a8e81800000
[  273.376540]  a2 : 0000003c00070198 a3 : 0000003c00db75a4 a4 : 0000000000000015
[  273.383901]  a5 : ffffffd7ff8804b0 a6 : 0000000000000015 a7 : 000000000000002a
[  273.391327]  s2 : 000000000000ffff s3 : 0000000000000000 s4 : ffffffd7ff8803b0
[  273.398773]  s5 : 0000000000504d55 s6 : ffffffd905069800 s7 : ffffffff821fe210
[  273.406139]  s8 : 000000007fffffff s9 : ffffffd7ff8803b0 s10: ffffffd903f29098
[  273.413660]  s11: 0000000080000000 t3 : 0000000000000003 t4 : ffffffff8017a0ca
[  273.421022]  t5 : ffffffff8023cfc2 t6 : ffffffd9040780e8
[  273.426437] status: 0000000200000100 badaddr: 0000000000000098 cause: 000000000000000d
[  273.434512] [<ffffffff80aecd98>] riscv_pmu_ctr_get_width_mask+0x8/0x62
[  273.441169] [<ffffffff80076bd8>] handle_percpu_devid_irq+0x98/0x1ee
[  273.447562] [<ffffffff80071158>] generic_handle_domain_irq+0x28/0x36
[  273.454151] [<ffffffff8047a99a>] riscv_intc_irq+0x36/0x4e
[  273.459659] [<ffffffff80c944de>] handle_riscv_irq+0x4a/0x74
[  273.465442] [<ffffffff80c94c48>] do_irq+0x62/0x92
[  273.470360] Code: 0420 60a2 6402 5529 0141 8082 0013 0000 0013 0000 (6d5c) b783
[  273.477921] ---[ end trace 0000000000000000 ]---
[  273.482630] Kernel panic - not syncing: Fatal exception in interrupt</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('2115d621d175fe50a8012a0ba4f7a4a914cf2176')">
                                    <div class="issue-number">157</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="2115d621d175fe50a8012a0ba4f7a4a914cf2176">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: fix incorrect mpc_combine array size

[why]
MAX_SURFACES is per stream, while MAX_PLANES is per asic. The
mpc_combine is an array that records all the planes per asic. Therefore
MAX_PLANES should be used as the array size. Using MAX_SURFACES causes
array overflow when there are more than 3 planes.

[how]
Use the MAX_PLANES for the mpc_combine array size.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('afee62a4d745025b287da67058bde217b4265aca')">
                                    <div class="issue-number">158</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="afee62a4d745025b287da67058bde217b4265aca">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

btrfs: zoned: fix use-after-free in do_zone_finish()

Shinichiro reported the following use-after-free triggered by the device
replace operation in fstests btrfs/070.

 BTRFS info (device nullb1): scrub: finished on devid 1 with status: 0
 ==================================================================
 BUG: KASAN: slab-use-after-free in do_zone_finish+0x91a/0xb90 [btrfs]
 Read of size 8 at addr ffff8881543c8060 by task btrfs-cleaner/3494007

 CPU: 0 PID: 3494007 Comm: btrfs-cleaner Tainted: G        W          6.8.0-rc5-kts #1
 Hardware name: Supermicro Super Server/X11SPi-TF, BIOS 3.3 02/21/2020
 Call Trace:
  <TASK>
  dump_stack_lvl+0x5b/0x90
  print_report+0xcf/0x670
  ? __virt_addr_valid+0x200/0x3e0
  kasan_report+0xd8/0x110
  ? do_zone_finish+0x91a/0xb90 [btrfs]
  ? do_zone_finish+0x91a/0xb90 [btrfs]
  do_zone_finish+0x91a/0xb90 [btrfs]
  btrfs_delete_unused_bgs+0x5e1/0x1750 [btrfs]
  ? __pfx_btrfs_delete_unused_bgs+0x10/0x10 [btrfs]
  ? btrfs_put_root+0x2d/0x220 [btrfs]
  ? btrfs_clean_one_deleted_snapshot+0x299/0x430 [btrfs]
  cleaner_kthread+0x21e/0x380 [btrfs]
  ? __pfx_cleaner_kthread+0x10/0x10 [btrfs]
  kthread+0x2e3/0x3c0
  ? __pfx_kthread+0x10/0x10
  ret_from_fork+0x31/0x70
  ? __pfx_kthread+0x10/0x10
  ret_from_fork_asm+0x1b/0x30
  </TASK>

 Allocated by task 3493983:
  kasan_save_stack+0x33/0x60
  kasan_save_track+0x14/0x30
  __kasan_kmalloc+0xaa/0xb0
  btrfs_alloc_device+0xb3/0x4e0 [btrfs]
  device_list_add.constprop.0+0x993/0x1630 [btrfs]
  btrfs_scan_one_device+0x219/0x3d0 [btrfs]
  btrfs_control_ioctl+0x26e/0x310 [btrfs]
  __x64_sys_ioctl+0x134/0x1b0
  do_syscall_64+0x99/0x190
  entry_SYSCALL_64_after_hwframe+0x6e/0x76

 Freed by task 3494056:
  kasan_save_stack+0x33/0x60
  kasan_save_track+0x14/0x30
  kasan_save_free_info+0x3f/0x60
  poison_slab_object+0x102/0x170
  __kasan_slab_free+0x32/0x70
  kfree+0x11b/0x320
  btrfs_rm_dev_replace_free_srcdev+0xca/0x280 [btrfs]
  btrfs_dev_replace_finishing+0xd7e/0x14f0 [btrfs]
  btrfs_dev_replace_by_ioctl+0x1286/0x25a0 [btrfs]
  btrfs_ioctl+0xb27/0x57d0 [btrfs]
  __x64_sys_ioctl+0x134/0x1b0
  do_syscall_64+0x99/0x190
  entry_SYSCALL_64_after_hwframe+0x6e/0x76

 The buggy address belongs to the object at ffff8881543c8000
  which belongs to the cache kmalloc-1k of size 1024
 The buggy address is located 96 bytes inside of
  freed 1024-byte region [ffff8881543c8000, ffff8881543c8400)

 The buggy address belongs to the physical page:
 page:00000000fe2c1285 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x1543c8
 head:00000000fe2c1285 order:3 entire_mapcount:0 nr_pages_mapped:0 pincount:0
 flags: 0x17ffffc0000840(slab|head|node=0|zone=2|lastcpupid=0x1fffff)
 page_type: 0xffffffff()
 raw: 0017ffffc0000840 ffff888100042dc0 ffffea0019e8f200 dead000000000002
 raw: 0000000000000000 0000000000100010 00000001ffffffff 0000000000000000
 page dumped because: kasan: bad access detected

 Memory state around the buggy address:
  ffff8881543c7f00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  ffff8881543c7f80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
 >ffff8881543c8000: fa fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
                                                        ^
  ffff8881543c8080: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
  ffff8881543c8100: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb

This UAF happens because we're accessing stale zone information of a
already removed btrfs_device in do_zone_finish().

The sequence of events is as follows:

btrfs_dev_replace_start
  btrfs_scrub_dev
   btrfs_dev_replace_finishing
    btrfs_dev_replace_update_device_in_mapping_tree <-- devices replaced
    btrfs_rm_dev_replace_free_srcdev
     btrfs_free_device                              <-- device freed

cleaner_kthread
 btrfs_delete_unused_bgs
  btrfs_zone_finish
   do_zone_finish              <-- refers the freed device

The reason for this is that we're using a
---truncated---</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('82b8d45486c7766e726da99c64bfeace305e0e5f')">
                                    <div class="issue-number">159</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="82b8d45486c7766e726da99c64bfeace305e0e5f">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

crypto: iaa - Fix nr_cpus < nr_iaa case

If nr_cpus < nr_iaa, the calculated cpus_per_iaa will be 0, which
causes a divide-by-0 in rebalance_wq_table().

Make sure cpus_per_iaa is 1 in that case, and also in the nr_iaa == 0
case, even though cpus_per_iaa is never used if nr_iaa == 0, for
paranoia.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('8e79de558a2314119545aff241d5c320f314c631')">
                                    <div class="issue-number">160</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="8e79de558a2314119545aff241d5c320f314c631">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

ARM: 9359/1: flush: check if the folio is reserved for no-mapping addresses

Since commit a4d5613c4dc6 ("arm: extend pfn_valid to take into account
freed memory map alignment") changes the semantics of pfn_valid() to check
presence of the memory map for a PFN. A valid page for an address which
is reserved but not mapped by the kernel[1], the system crashed during
some uio test with the following memory layout:

 node   0: [mem 0x00000000c0a00000-0x00000000cc8fffff]
 node   0: [mem 0x00000000d0000000-0x00000000da1fffff]
 the uio layout is：0xc0900000, 0x100000

the crash backtrace like:

  Unable to handle kernel paging request at virtual address bff00000
  [...]
  CPU: 1 PID: 465 Comm: startapp.bin Tainted: G           O      5.10.0 #1
  Hardware name: Generic DT based system
  PC is at b15_flush_kern_dcache_area+0x24/0x3c
  LR is at __sync_icache_dcache+0x6c/0x98
  [...]
   (b15_flush_kern_dcache_area) from (__sync_icache_dcache+0x6c/0x98)
   (__sync_icache_dcache) from (set_pte_at+0x28/0x54)
   (set_pte_at) from (remap_pfn_range+0x1a0/0x274)
   (remap_pfn_range) from (uio_mmap+0x184/0x1b8 [uio])
   (uio_mmap [uio]) from (__mmap_region+0x264/0x5f4)
   (__mmap_region) from (__do_mmap_mm+0x3ec/0x440)
   (__do_mmap_mm) from (do_mmap+0x50/0x58)
   (do_mmap) from (vm_mmap_pgoff+0xfc/0x188)
   (vm_mmap_pgoff) from (ksys_mmap_pgoff+0xac/0xc4)
   (ksys_mmap_pgoff) from (ret_fast_syscall+0x0/0x5c)
  Code: e0801001 e2423001 e1c00003 f57ff04f (ee070f3e)
  ---[ end trace 09cf0734c3805d52 ]---
  Kernel panic - not syncing: Fatal exception

So check if PG_reserved was set to solve this issue.

[1]: https://lore.kernel.org/lkml/Zbtdue57RO0QScJM@linux.ibm.com/</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('5b6090b870f708ba7b4e77cd6cc91449fc39eb68')">
                                    <div class="issue-number">161</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="5b6090b870f708ba7b4e77cd6cc91449fc39eb68">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Add a dc_state NULL check in dc_state_release

[How]
Check wheather state is NULL before releasing it.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('86a380dc7ea5fed2d4152216674cd42d6458dd4b')">
                                    <div class="issue-number">162</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="86a380dc7ea5fed2d4152216674cd42d6458dd4b">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

net: esp: fix bad handling of pages from page_pool

When the skb is reorganized during esp_output (!esp->inline), the pages
coming from the original skb fragments are supposed to be released back
to the system through put_page. But if the skb fragment pages are
originating from a page_pool, calling put_page on them will trigger a
page_pool leak which will eventually result in a crash.

This leak can be easily observed when using CONFIG_DEBUG_VM and doing
ipsec + gre (non offloaded) forwarding:

  BUG: Bad page state in process ksoftirqd/16  pfn:1451b6
  page:00000000de2b8d32 refcount:0 mapcount:0 mapping:0000000000000000 index:0x1451b6000 pfn:0x1451b6
  flags: 0x200000000000000(node=0|zone=2)
  page_type: 0xffffffff()
  raw: 0200000000000000 dead000000000040 ffff88810d23c000 0000000000000000
  raw: 00000001451b6000 0000000000000001 00000000ffffffff 0000000000000000
  page dumped because: page_pool leak
  Modules linked in: ip_gre gre mlx5_ib mlx5_core xt_conntrack xt_MASQUERADE nf_conntrack_netlink nfnetlink iptable_nat nf_nat xt_addrtype br_netfilter rpcrdma rdma_ucm ib_iser libiscsi scsi_transport_iscsi ib_umad rdma_cm ib_ipoib iw_cm ib_cm ib_uverbs ib_core overlay zram zsmalloc fuse [last unloaded: mlx5_core]
  CPU: 16 PID: 96 Comm: ksoftirqd/16 Not tainted 6.8.0-rc4+ #22
  Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014
  Call Trace:
   <TASK>
   dump_stack_lvl+0x36/0x50
   bad_page+0x70/0xf0
   free_unref_page_prepare+0x27a/0x460
   free_unref_page+0x38/0x120
   esp_ssg_unref.isra.0+0x15f/0x200
   esp_output_tail+0x66d/0x780
   esp_xmit+0x2c5/0x360
   validate_xmit_xfrm+0x313/0x370
   ? validate_xmit_skb+0x1d/0x330
   validate_xmit_skb_list+0x4c/0x70
   sch_direct_xmit+0x23e/0x350
   __dev_queue_xmit+0x337/0xba0
   ? nf_hook_slow+0x3f/0xd0
   ip_finish_output2+0x25e/0x580
   iptunnel_xmit+0x19b/0x240
   ip_tunnel_xmit+0x5fb/0xb60
   ipgre_xmit+0x14d/0x280 [ip_gre]
   dev_hard_start_xmit+0xc3/0x1c0
   __dev_queue_xmit+0x208/0xba0
   ? nf_hook_slow+0x3f/0xd0
   ip_finish_output2+0x1ca/0x580
   ip_sublist_rcv_finish+0x32/0x40
   ip_sublist_rcv+0x1b2/0x1f0
   ? ip_rcv_finish_core.constprop.0+0x460/0x460
   ip_list_rcv+0x103/0x130
   __netif_receive_skb_list_core+0x181/0x1e0
   netif_receive_skb_list_internal+0x1b3/0x2c0
   napi_gro_receive+0xc8/0x200
   gro_cell_poll+0x52/0x90
   __napi_poll+0x25/0x1a0
   net_rx_action+0x28e/0x300
   __do_softirq+0xc3/0x276
   ? sort_range+0x20/0x20
   run_ksoftirqd+0x1e/0x30
   smpboot_thread_fn+0xa6/0x130
   kthread+0xcd/0x100
   ? kthread_complete_and_exit+0x20/0x20
   ret_from_fork+0x31/0x50
   ? kthread_complete_and_exit+0x20/0x20
   ret_from_fork_asm+0x11/0x20
   </TASK>

The suggested fix is to introduce a new wrapper (skb_page_unref) that
covers page refcounting for page_pool pages as well.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('70513de44a52fc0149bbfc0b99473d2947e71ead')">
                                    <div class="issue-number">163</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="70513de44a52fc0149bbfc0b99473d2947e71ead">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

dm-raid456, md/raid456: fix a deadlock for dm-raid456 while io concurrent with reshape

For raid456, if reshape is still in progress, then IO across reshape
position will wait for reshape to make progress. However, for dm-raid,
in following cases reshape will never make progress hence IO will hang:

1) the array is read-only;
2) MD_RECOVERY_WAIT is set;
3) MD_RECOVERY_FROZEN is set;

After commit c467e97f079f ("md/raid6: use valid sector values to determine
if an I/O should wait on the reshape") fix the problem that IO across
reshape position doesn't wait for reshape, the dm-raid test
shell/lvconvert-raid-reshape.sh start to hang:

[root@fedora ~]# cat /proc/979/stack
[<0>] wait_woken+0x7d/0x90
[<0>] raid5_make_request+0x929/0x1d70 [raid456]
[<0>] md_handle_request+0xc2/0x3b0 [md_mod]
[<0>] raid_map+0x2c/0x50 [dm_raid]
[<0>] __map_bio+0x251/0x380 [dm_mod]
[<0>] dm_submit_bio+0x1f0/0x760 [dm_mod]
[<0>] __submit_bio+0xc2/0x1c0
[<0>] submit_bio_noacct_nocheck+0x17f/0x450
[<0>] submit_bio_noacct+0x2bc/0x780
[<0>] submit_bio+0x70/0xc0
[<0>] mpage_readahead+0x169/0x1f0
[<0>] blkdev_readahead+0x18/0x30
[<0>] read_pages+0x7c/0x3b0
[<0>] page_cache_ra_unbounded+0x1ab/0x280
[<0>] force_page_cache_ra+0x9e/0x130
[<0>] page_cache_sync_ra+0x3b/0x110
[<0>] filemap_get_pages+0x143/0xa30
[<0>] filemap_read+0xdc/0x4b0
[<0>] blkdev_read_iter+0x75/0x200
[<0>] vfs_read+0x272/0x460
[<0>] ksys_read+0x7a/0x170
[<0>] __x64_sys_read+0x1c/0x30
[<0>] do_syscall_64+0xc6/0x230
[<0>] entry_SYSCALL_64_after_hwframe+0x6c/0x74

This is because reshape can't make progress.

For md/raid, the problem doesn't exist because register new sync_thread
doesn't rely on the IO to be done any more:

1) If array is read-only, it can switch to read-write by ioctl/sysfs;
2) md/raid never set MD_RECOVERY_WAIT;
3) If MD_RECOVERY_FROZEN is set, mddev_suspend() doesn't hold
   'reconfig_mutex', hence it can be cleared and reshape can continue by
   sysfs api 'sync_action'.

However, I'm not sure yet how to avoid the problem in dm-raid yet. This
patch on the one hand make sure raid_message() can't change
sync_thread() through raid_message() after presuspend(), on the other
hand detect the above 3 cases before wait for IO do be done in
dm_suspend(), and let dm-raid requeue those IO.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('12b757fba2431f3ce45f42776dcaa0c013dade82')">
                                    <div class="issue-number">164</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="12b757fba2431f3ce45f42776dcaa0c013dade82">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

ubifs: ubifs_symlink: Fix memleak of inode->i_link in error path

For error handling path in ubifs_symlink(), inode will be marked as
bad first, then iput() is invoked. If inode->i_link is initialized by
fscrypt_encrypt_symlink() in encryption scenario, inode->i_link won't
be freed by callchain ubifs_free_inode -> fscrypt_free_inode in error
handling path, because make_bad_inode() has changed 'inode->i_mode' as
'S_IFREG'.
Following kmemleak is easy to be reproduced by injecting error in
ubifs_jnl_update() when doing symlink in encryption scenario:
 unreferenced object 0xffff888103da3d98 (size 8):
  comm "ln", pid 1692, jiffies 4294914701 (age 12.045s)
  backtrace:
   kmemdup+0x32/0x70
   __fscrypt_encrypt_symlink+0xed/0x1c0
   ubifs_symlink+0x210/0x300 [ubifs]
   vfs_symlink+0x216/0x360
   do_symlinkat+0x11a/0x190
   do_syscall_64+0x3b/0xe0
There are two ways fixing it:
 1. Remove make_bad_inode() in error handling path. We can do that
    because ubifs_evict_inode() will do same processes for good
    symlink inode and bad symlink inode, for inode->i_nlink checking
    is before is_bad_inode().
 2. Free inode->i_link before marking inode bad.
Method 2 is picked, it has less influence, personally, I think.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('ffadf52d3f36b11401d5f73d01b18129df818c16')">
                                    <div class="issue-number">165</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="ffadf52d3f36b11401d5f73d01b18129df818c16">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

Squashfs: check the inode number is not the invalid value of zero

Syskiller has produced an out of bounds access in fill_meta_index().

That out of bounds access is ultimately caused because the inode
has an inode number with the invalid value of zero, which was not checked.

The reason this causes the out of bounds access is due to following
sequence of events:

1. Fill_meta_index() is called to allocate (via empty_meta_index())
   and fill a metadata index.  It however suffers a data read error
   and aborts, invalidating the newly returned empty metadata index.
   It does this by setting the inode number of the index to zero,
   which means unused (zero is not a valid inode number).

2. When fill_meta_index() is subsequently called again on another
   read operation, locate_meta_index() returns the previous index
   because it matches the inode number of 0.  Because this index
   has been returned it is expected to have been filled, and because
   it hasn't been, an out of bounds access is performed.

This patch adds a sanity check which checks that the inode number
is not zero when the inode is created and returns -EINVAL if it is.

[phillip@squashfs.org.uk: whitespace fix]
  Link: https://lkml.kernel.org/r/20240409204723.446925-1-phillip@squashfs.org.uk</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('520f000719dc4716c852b0d528cda97cffd7e929')">
                                    <div class="issue-number">166</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="520f000719dc4716c852b0d528cda97cffd7e929">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

interconnect: Don't access req_list while it's being manipulated

The icc_lock mutex was split into separate icc_lock and icc_bw_lock
mutexes in [1] to avoid lockdep splats. However, this didn't adequately
protect access to icc_node::req_list.

The icc_set_bw() function will eventually iterate over req_list while
only holding icc_bw_lock, but req_list can be modified while only
holding icc_lock. This causes races between icc_set_bw(), of_icc_get(),
and icc_put().

Example A:

  CPU0                               CPU1
  ----                               ----
  icc_set_bw(path_a)
    mutex_lock(&icc_bw_lock);
                                     icc_put(path_b)
                                       mutex_lock(&icc_lock);
    aggregate_requests()
      hlist_for_each_entry(r, ...
                                       hlist_del(...
        <r = invalid pointer>

Example B:

  CPU0                               CPU1
  ----                               ----
  icc_set_bw(path_a)
    mutex_lock(&icc_bw_lock);
                                     path_b = of_icc_get()
                                       of_icc_get_by_index()
                                         mutex_lock(&icc_lock);
                                         path_find()
                                           path_init()
    aggregate_requests()
      hlist_for_each_entry(r, ...
                                             hlist_add_head(...
        <r = invalid pointer>

Fix this by ensuring icc_bw_lock is always held before manipulating
icc_node::req_list. The additional places icc_bw_lock is held don't
perform any memory allocations, so we should still be safe from the
original lockdep splats that motivated the separate locks.

[1] commit af42269c3523 ("interconnect: Fix locking for runpm vs reclaim")</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('c470d5b5f09e79d09395f8726e5d436e412429a2')">
                                    <div class="issue-number">167</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="c470d5b5f09e79d09395f8726e5d436e412429a2">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

net/sched: Fix mirred deadlock on device recursion

When the mirred action is used on a classful egress qdisc and a packet is
mirrored or redirected to self we hit a qdisc lock deadlock.
See trace below.

[..... other info removed for brevity....]
[   82.890906]
[   82.890906] ============================================
[   82.890906] WARNING: possible recursive locking detected
[   82.890906] 6.8.0-05205-g77fadd89fe2d-dirty #213 Tainted: G        W
[   82.890906] --------------------------------------------
[   82.890906] ping/418 is trying to acquire lock:
[   82.890906] ffff888006994110 (&sch->q.lock){+.-.}-{3:3}, at:
__dev_queue_xmit+0x1778/0x3550
[   82.890906]
[   82.890906] but task is already holding lock:
[   82.890906] ffff888006994110 (&sch->q.lock){+.-.}-{3:3}, at:
__dev_queue_xmit+0x1778/0x3550
[   82.890906]
[   82.890906] other info that might help us debug this:
[   82.890906]  Possible unsafe locking scenario:
[   82.890906]
[   82.890906]        CPU0
[   82.890906]        ----
[   82.890906]   lock(&sch->q.lock);
[   82.890906]   lock(&sch->q.lock);
[   82.890906]
[   82.890906]  *** DEADLOCK ***
[   82.890906]
[..... other info removed for brevity....]

Example setup (eth0->eth0) to recreate
tc qdisc add dev eth0 root handle 1: htb default 30
tc filter add dev eth0 handle 1: protocol ip prio 2 matchall \
     action mirred egress redirect dev eth0

Another example(eth0->eth1->eth0) to recreate
tc qdisc add dev eth0 root handle 1: htb default 30
tc filter add dev eth0 handle 1: protocol ip prio 2 matchall \
     action mirred egress redirect dev eth1

tc qdisc add dev eth1 root handle 1: htb default 30
tc filter add dev eth1 handle 1: protocol ip prio 2 matchall \
     action mirred egress redirect dev eth0

We fix this by adding an owner field (CPU id) to struct Qdisc set after
root qdisc is entered. When the softirq enters it a second time, if the
qdisc owner is the same CPU, the packet is dropped to break the loop.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('c476f3544d198cef0d12699e749b3ca58c482cc0')">
                                    <div class="issue-number">168</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="c476f3544d198cef0d12699e749b3ca58c482cc0">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

netfilter: nf_tables: fix memleak in map from abort path

The delete set command does not rely on the transaction object for
element removal, therefore, a combination of delete element + delete set
from the abort path could result in restoring twice the refcount of the
mapping.

Check for inactive element in the next generation for the delete element
command in the abort path, skip restoring state if next generation bit
has been already cleared. This is similar to the activate logic using
the set walk iterator.

[ 6170.286929] ------------[ cut here ]------------
[ 6170.286939] WARNING: CPU: 6 PID: 790302 at net/netfilter/nf_tables_api.c:2086 nf_tables_chain_destroy+0x1f7/0x220 [nf_tables]
[ 6170.287071] Modules linked in: [...]
[ 6170.287633] CPU: 6 PID: 790302 Comm: kworker/6:2 Not tainted 6.9.0-rc3+ #365
[ 6170.287768] RIP: 0010:nf_tables_chain_destroy+0x1f7/0x220 [nf_tables]
[ 6170.287886] Code: df 48 8d 7d 58 e8 69 2e 3b df 48 8b 7d 58 e8 80 1b 37 df 48 8d 7d 68 e8 57 2e 3b df 48 8b 7d 68 e8 6e 1b 37 df 48 89 ef eb c4 <0f> 0b 48 83 c4 08 5b 5d 41 5c 41 5d 41 5e 41 5f c3 cc cc cc cc 0f
[ 6170.287895] RSP: 0018:ffff888134b8fd08 EFLAGS: 00010202
[ 6170.287904] RAX: 0000000000000001 RBX: ffff888125bffb28 RCX: dffffc0000000000
[ 6170.287912] RDX: 0000000000000003 RSI: ffffffffa20298ab RDI: ffff88811ebe4750
[ 6170.287919] RBP: ffff88811ebe4700 R08: ffff88838e812650 R09: fffffbfff0623a55
[ 6170.287926] R10: ffffffff8311d2af R11: 0000000000000001 R12: ffff888125bffb10
[ 6170.287933] R13: ffff888125bffb10 R14: dead000000000122 R15: dead000000000100
[ 6170.287940] FS:  0000000000000000(0000) GS:ffff888390b00000(0000) knlGS:0000000000000000
[ 6170.287948] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[ 6170.287955] CR2: 00007fd31fc00710 CR3: 0000000133f60004 CR4: 00000000001706f0
[ 6170.287962] Call Trace:
[ 6170.287967]  <TASK>
[ 6170.287973]  ? __warn+0x9f/0x1a0
[ 6170.287986]  ? nf_tables_chain_destroy+0x1f7/0x220 [nf_tables]
[ 6170.288092]  ? report_bug+0x1b1/0x1e0
[ 6170.287986]  ? nf_tables_chain_destroy+0x1f7/0x220 [nf_tables]
[ 6170.288092]  ? report_bug+0x1b1/0x1e0
[ 6170.288104]  ? handle_bug+0x3c/0x70
[ 6170.288112]  ? exc_invalid_op+0x17/0x40
[ 6170.288120]  ? asm_exc_invalid_op+0x1a/0x20
[ 6170.288132]  ? nf_tables_chain_destroy+0x2b/0x220 [nf_tables]
[ 6170.288243]  ? nf_tables_chain_destroy+0x1f7/0x220 [nf_tables]
[ 6170.288366]  ? nf_tables_chain_destroy+0x2b/0x220 [nf_tables]
[ 6170.288483]  nf_tables_trans_destroy_work+0x588/0x590 [nf_tables]</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('94e41bc61443d88a9bc6e9405731fca0382e944b')">
                                    <div class="issue-number">169</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="94e41bc61443d88a9bc6e9405731fca0382e944b">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

netfilter: nf_tables: restore set elements when delete set fails

From abort path, nft_mapelem_activate() needs to restore refcounters to
the original state. Currently, it uses the set->ops->walk() to iterate
over these set elements. The existing set iterator skips inactive
elements in the next generation, this does not work from the abort path
to restore the original state since it has to skip active elements
instead (not inactive ones).

This patch moves the check for inactive elements to the set iterator
callback, then it reverses the logic for the .activate case which
needs to skip active elements.

Toggle next generation bit for elements when delete set command is
invoked and call nft_clear() from .activate (abort) path to restore the
next generation bit.

The splat below shows an object in mappings memleak:

[43929.457523] ------------[ cut here ]------------
[43929.457532] WARNING: CPU: 0 PID: 1139 at include/net/netfilter/nf_tables.h:1237 nft_setelem_data_deactivate+0xe4/0xf0 [nf_tables]
[...]
[43929.458014] RIP: 0010:nft_setelem_data_deactivate+0xe4/0xf0 [nf_tables]
[43929.458076] Code: 83 f8 01 77 ab 49 8d 7c 24 08 e8 37 5e d0 de 49 8b 6c 24 08 48 8d 7d 50 e8 e9 5c d0 de 8b 45 50 8d 50 ff 89 55 50 85 c0 75 86 <0f> 0b eb 82 0f 0b eb b3 0f 1f 40 00 90 90 90 90 90 90 90 90 90 90
[43929.458081] RSP: 0018:ffff888140f9f4b0 EFLAGS: 00010246
[43929.458086] RAX: 0000000000000000 RBX: ffff8881434f5288 RCX: dffffc0000000000
[43929.458090] RDX: 00000000ffffffff RSI: ffffffffa26d28a7 RDI: ffff88810ecc9550
[43929.458093] RBP: ffff88810ecc9500 R08: 0000000000000001 R09: ffffed10281f3e8f
[43929.458096] R10: 0000000000000003 R11: ffff0000ffff0000 R12: ffff8881434f52a0
[43929.458100] R13: ffff888140f9f5f4 R14: ffff888151c7a800 R15: 0000000000000002
[43929.458103] FS:  00007f0c687c4740(0000) GS:ffff888390800000(0000) knlGS:0000000000000000
[43929.458107] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[43929.458111] CR2: 00007f58dbe5b008 CR3: 0000000123602005 CR4: 00000000001706f0
[43929.458114] Call Trace:
[43929.458118]  <TASK>
[43929.458121]  ? __warn+0x9f/0x1a0
[43929.458127]  ? nft_setelem_data_deactivate+0xe4/0xf0 [nf_tables]
[43929.458188]  ? report_bug+0x1b1/0x1e0
[43929.458196]  ? handle_bug+0x3c/0x70
[43929.458200]  ? exc_invalid_op+0x17/0x40
[43929.458211]  ? nft_setelem_data_deactivate+0xd7/0xf0 [nf_tables]
[43929.458271]  ? nft_setelem_data_deactivate+0xe4/0xf0 [nf_tables]
[43929.458332]  nft_mapelem_deactivate+0x24/0x30 [nf_tables]
[43929.458392]  nft_rhash_walk+0xdd/0x180 [nf_tables]
[43929.458453]  ? __pfx_nft_rhash_walk+0x10/0x10 [nf_tables]
[43929.458512]  ? rb_insert_color+0x2e/0x280
[43929.458520]  nft_map_deactivate+0xdc/0x1e0 [nf_tables]
[43929.458582]  ? __pfx_nft_map_deactivate+0x10/0x10 [nf_tables]
[43929.458642]  ? __pfx_nft_mapelem_deactivate+0x10/0x10 [nf_tables]
[43929.458701]  ? __rcu_read_unlock+0x46/0x70
[43929.458709]  nft_delset+0xff/0x110 [nf_tables]
[43929.458769]  nft_flush_table+0x16f/0x460 [nf_tables]
[43929.458830]  nf_tables_deltable+0x501/0x580 [nf_tables]</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('6d53f9365f097cc196b89a949baa827c56092a19')">
                                    <div class="issue-number">170</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="6d53f9365f097cc196b89a949baa827c56092a19">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: fix NULL checks for adev->dm.dc in amdgpu_dm_fini()

Since 'adev->dm.dc' in amdgpu_dm_fini() might turn out to be NULL
before the call to dc_enable_dmub_notifications(), check
beforehand to ensure there will not be a possible NULL-ptr-deref
there.

Also, since commit 1e88eb1b2c25 ("drm/amd/display: Drop
CONFIG_DRM_AMD_DC_HDCP") there are two separate checks for NULL in
'adev->dm.dc' before dc_deinit_callbacks() and dc_dmub_srv_destroy().
Clean up by combining them all under one 'if'.

Found by Linux Verification Center (linuxtesting.org) with static
analysis tool SVACE.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('52c189ef8d2f86d91e715a0e819a28ca3b2cc076')">
                                    <div class="issue-number">171</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="52c189ef8d2f86d91e715a0e819a28ca3b2cc076">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amdgpu: Fix potential out-of-bounds access in 'amdgpu_discovery_reg_base_init()'

The issue arises when the array 'adev->vcn.vcn_config' is accessed
before checking if the index 'adev->vcn.num_vcn_inst' is within the
bounds of the array.

The fix involves moving the bounds check before the array access. This
ensures that 'adev->vcn.num_vcn_inst' is within the bounds of the array
before it is used as an index.

Fixes the below:
drivers/gpu/drm/amd/amdgpu/amdgpu_discovery.c:1289 amdgpu_discovery_reg_base_init() error: testing array offset 'adev->vcn.num_vcn_inst' after use.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('e695481abaa25157ed2ccce4b6f073532bd627dc')">
                                    <div class="issue-number">172</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="e695481abaa25157ed2ccce4b6f073532bd627dc">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

wifi: iwlwifi: mvm: ensure offloading TID queue exists

The resume code path assumes that the TX queue for the offloading TID
has been configured. At resume time it then tries to sync the write
pointer as it may have been updated by the firmware.

In the unusual event that no packets have been send on TID 0, the queue
will not have been allocated and this causes a crash. Fix this by
ensuring the queue exist at suspend time.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('436645bd88219c78bfe5eed5500f7c729a657640')">
                                    <div class="issue-number">173</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="436645bd88219c78bfe5eed5500f7c729a657640">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

ASoC: SOF: ipc4-pcm: Workaround for crashed firmware on system suspend

When the system is suspended while audio is active, the
sof_ipc4_pcm_hw_free() is invoked to reset the pipelines since during
suspend the DSP is turned off, streams will be re-started after resume.

If the firmware crashes during while audio is running (or when we reset
the stream before suspend) then the sof_ipc4_set_multi_pipeline_state()
will fail with IPC error and the state change is interrupted.
This will cause misalignment between the kernel and firmware state on next
DSP boot resulting errors returned by firmware for IPC messages, eventually
failing the audio resume.
On stream close the errors are ignored so the kernel state will be
corrected on the next DSP boot, so the second boot after the DSP panic.

If sof_ipc4_trigger_pipelines() is called from sof_ipc4_pcm_hw_free() then
state parameter is SOF_IPC4_PIPE_RESET and only in this case.

Treat a forced pipeline reset similarly to how we treat a pcm_free by
ignoring error on state sending to allow the kernel's state to be
consistent with the state the firmware will have after the next boot.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('7c36c2bf5dbc92d9751e2349d0a7edcdb990d5e6')">
                                    <div class="issue-number">174</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="7c36c2bf5dbc92d9751e2349d0a7edcdb990d5e6">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

nouveau: lock the client object tree.

It appears the client object tree has no locking unless I've missed
something else. Fix races around adding/removing client objects,
mostly vram bar mappings.

 4562.099306] general protection fault, probably for non-canonical address 0x6677ed422bceb80c: 0000 [#1] PREEMPT SMP PTI
[ 4562.099314] CPU: 2 PID: 23171 Comm: deqp-vk Not tainted 6.8.0-rc6+ #27
[ 4562.099324] Hardware name: Gigabyte Technology Co., Ltd. Z390 I AORUS PRO WIFI/Z390 I AORUS PRO WIFI-CF, BIOS F8 11/05/2021
[ 4562.099330] RIP: 0010:nvkm_object_search+0x1d/0x70 [nouveau]
[ 4562.099503] Code: 90 90 90 90 90 90 90 90 90 90 90 90 90 66 0f 1f 00 0f 1f 44 00 00 48 89 f8 48 85 f6 74 39 48 8b 87 a0 00 00 00 48 85 c0 74 12 <48> 8b 48 f8 48 39 ce 73 15 48 8b 40 10 48 85 c0 75 ee 48 c7 c0 fe
[ 4562.099506] RSP: 0000:ffffa94cc420bbf8 EFLAGS: 00010206
[ 4562.099512] RAX: 6677ed422bceb814 RBX: ffff98108791f400 RCX: ffff9810f26b8f58
[ 4562.099517] RDX: 0000000000000000 RSI: ffff9810f26b9158 RDI: ffff98108791f400
[ 4562.099519] RBP: ffff9810f26b9158 R08: 0000000000000000 R09: 0000000000000000
[ 4562.099521] R10: ffffa94cc420bc48 R11: 0000000000000001 R12: ffff9810f02a7cc0
[ 4562.099526] R13: 0000000000000000 R14: 00000000000000ff R15: 0000000000000007
[ 4562.099528] FS:  00007f629c5017c0(0000) GS:ffff98142c700000(0000) knlGS:0000000000000000
[ 4562.099534] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[ 4562.099536] CR2: 00007f629a882000 CR3: 000000017019e004 CR4: 00000000003706f0
[ 4562.099541] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
[ 4562.099542] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
[ 4562.099544] Call Trace:
[ 4562.099555]  <TASK>
[ 4562.099573]  ? die_addr+0x36/0x90
[ 4562.099583]  ? exc_general_protection+0x246/0x4a0
[ 4562.099593]  ? asm_exc_general_protection+0x26/0x30
[ 4562.099600]  ? nvkm_object_search+0x1d/0x70 [nouveau]
[ 4562.099730]  nvkm_ioctl+0xa1/0x250 [nouveau]
[ 4562.099861]  nvif_object_map_handle+0xc8/0x180 [nouveau]
[ 4562.099986]  nouveau_ttm_io_mem_reserve+0x122/0x270 [nouveau]
[ 4562.100156]  ? dma_resv_test_signaled+0x26/0xb0
[ 4562.100163]  ttm_bo_vm_fault_reserved+0x97/0x3c0 [ttm]
[ 4562.100182]  ? __mutex_unlock_slowpath+0x2a/0x270
[ 4562.100189]  nouveau_ttm_fault+0x69/0xb0 [nouveau]
[ 4562.100356]  __do_fault+0x32/0x150
[ 4562.100362]  do_fault+0x7c/0x560
[ 4562.100369]  __handle_mm_fault+0x800/0xc10
[ 4562.100382]  handle_mm_fault+0x17c/0x3e0
[ 4562.100388]  do_user_addr_fault+0x208/0x860
[ 4562.100395]  exc_page_fault+0x7f/0x200
[ 4562.100402]  asm_exc_page_fault+0x26/0x30
[ 4562.100412] RIP: 0033:0x9b9870
[ 4562.100419] Code: 85 a8 f7 ff ff 8b 8d 80 f7 ff ff 89 08 e9 18 f2 ff ff 0f 1f 84 00 00 00 00 00 44 89 32 e9 90 fa ff ff 0f 1f 84 00 00 00 00 00 <44> 89 32 e9 f8 f1 ff ff 0f 1f 84 00 00 00 00 00 66 44 89 32 e9 e7
[ 4562.100422] RSP: 002b:00007fff9ba2dc70 EFLAGS: 00010246
[ 4562.100426] RAX: 0000000000000004 RBX: 000000000dd65e10 RCX: 000000fff0000000
[ 4562.100428] RDX: 00007f629a882000 RSI: 00007f629a882000 RDI: 0000000000000066
[ 4562.100432] RBP: 00007fff9ba2e570 R08: 0000000000000000 R09: 0000000123ddf000
[ 4562.100434] R10: 0000000000000001 R11: 0000000000000246 R12: 000000007fffffff
[ 4562.100436] R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000
[ 4562.100446]  </TASK>
[ 4562.100448] Modules linked in: nf_conntrack_netbios_ns nf_conntrack_broadcast nft_fib_inet nft_fib_ipv4 nft_fib_ipv6 nft_fib nft_reject_inet nf_reject_ipv4 nf_reject_ipv6 nft_reject nft_ct nft_chain_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 ip_set nf_tables libcrc32c nfnetlink cmac bnep sunrpc iwlmvm intel_rapl_msr intel_rapl_common snd_sof_pci_intel_cnl x86_pkg_temp_thermal intel_powerclamp snd_sof_intel_hda_common mac80211 coretemp snd_soc_acpi_intel_match kvm_intel snd_soc_acpi snd_soc_hdac_hda snd_sof_pci snd_sof_xtensa_dsp snd_sof_intel_hda_mlink 
---truncated---</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('834f918e1459f05a674a48a31362641f38c9109e')">
                                    <div class="issue-number">175</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="834f918e1459f05a674a48a31362641f38c9109e">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

iommu/vt-d: Fix NULL domain on device release

In the kdump kernel, the IOMMU operates in deferred_attach mode. In this
mode, info->domain may not yet be assigned by the time the release_device
function is called. It leads to the following crash in the crash kernel:

    BUG: kernel NULL pointer dereference, address: 000000000000003c
    ...
    RIP: 0010:do_raw_spin_lock+0xa/0xa0
    ...
    _raw_spin_lock_irqsave+0x1b/0x30
    intel_iommu_release_device+0x96/0x170
    iommu_deinit_device+0x39/0xf0
    __iommu_group_remove_device+0xa0/0xd0
    iommu_bus_notifier+0x55/0xb0
    notifier_call_chain+0x5a/0xd0
    blocking_notifier_call_chain+0x41/0x60
    bus_notify+0x34/0x50
    device_del+0x269/0x3d0
    pci_remove_bus_device+0x77/0x100
    p2sb_bar+0xae/0x1d0
    ...
    i801_probe+0x423/0x740

Use the release_domain mechanism to fix it. The scalable mode context
entry which is not part of release domain should be cleared in
release_device().</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('3a7601337dee732632f0ac44d89457ad0bc9ead7')">
                                    <div class="issue-number">176</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="3a7601337dee732632f0ac44d89457ad0bc9ead7">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

fs/ntfs3: Fixed overflow check in mi_enum_attr()</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('3ab63c84076c75d3639330fd9e71665d1f6fb5fa')">
                                    <div class="issue-number">177</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="3ab63c84076c75d3639330fd9e71665d1f6fb5fa">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

dmaengine: dw-edma: eDMA: Add sync read before starting the DMA transfer in remote setup

The Linked list element and pointer are not stored in the same memory as
the eDMA controller register. If the doorbell register is toggled before
the full write of the linked list a race condition error will occur.
In remote setup we can only use a readl to the memory to assure the full
write has occurred.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('01513b6944f3f43725e6e3a326f88d513a56b941')">
                                    <div class="issue-number">178</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="01513b6944f3f43725e6e3a326f88d513a56b941">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

btrfs: fix deadlock with fiemap and extent locking

While working on the patchset to remove extent locking I got a lockdep
splat with fiemap and pagefaulting with my new extent lock replacement
lock.

This deadlock exists with our normal code, we just don't have lockdep
annotations with the extent locking so we've never noticed it.

Since we're copying the fiemap extent to user space on every iteration
we have the chance of pagefaulting.  Because we hold the extent lock for
the entire range we could mkwrite into a range in the file that we have
mmap'ed.  This would deadlock with the following stack trace

[<0>] lock_extent+0x28d/0x2f0
[<0>] btrfs_page_mkwrite+0x273/0x8a0
[<0>] do_page_mkwrite+0x50/0xb0
[<0>] do_fault+0xc1/0x7b0
[<0>] __handle_mm_fault+0x2fa/0x460
[<0>] handle_mm_fault+0xa4/0x330
[<0>] do_user_addr_fault+0x1f4/0x800
[<0>] exc_page_fault+0x7c/0x1e0
[<0>] asm_exc_page_fault+0x26/0x30
[<0>] rep_movs_alternative+0x33/0x70
[<0>] _copy_to_user+0x49/0x70
[<0>] fiemap_fill_next_extent+0xc8/0x120
[<0>] emit_fiemap_extent+0x4d/0xa0
[<0>] extent_fiemap+0x7f8/0xad0
[<0>] btrfs_fiemap+0x49/0x80
[<0>] __x64_sys_ioctl+0x3e1/0xb50
[<0>] do_syscall_64+0x94/0x1a0
[<0>] entry_SYSCALL_64_after_hwframe+0x6e/0x76

I wrote an fstest to reproduce this deadlock without my replacement lock
and verified that the deadlock exists with our existing locking.

To fix this simply don't take the extent lock for the entire duration of
the fiemap.  This is safe in general because we keep track of where we
are when we're searching the tree, so if an ordered extent updates in
the middle of our fiemap call we'll still emit the correct extents
because we know what offset we were on before.

The only place we maintain the lock is searching delalloc.  Since the
delalloc stuff can change during writeback we want to lock the extent
range so we have a consistent view of delalloc at the time we're
checking to see if we need to set the delalloc flag.

With this patch applied we no longer deadlock with my testcase.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('a7e6428aa9fc11b6f4a3bdf6463434d4a861b437')">
                                    <div class="issue-number">179</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="a7e6428aa9fc11b6f4a3bdf6463434d4a861b437">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

usb: typec: altmodes/displayport: create sysfs nodes as driver's default device attribute group

The DisplayPort driver's sysfs nodes may be present to the userspace before
typec_altmode_set_drvdata() completes in dp_altmode_probe. This means that
a sysfs read can trigger a NULL pointer error by deferencing dp->hpd in
hpd_show or dp->lock in pin_assignment_show, as dev_get_drvdata() returns
NULL in those cases.

Remove manual sysfs node creation in favor of adding attribute group as
default for devices bound to the driver. The ATTRIBUTE_GROUPS() macro is
not used here otherwise the path to the sysfs nodes is no longer compliant
with the ABI.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('f8f23d45f1e8f420a190d903679f482df811b1fd')">
                                    <div class="issue-number">180</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="f8f23d45f1e8f420a190d903679f482df811b1fd">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

dm-raid: really frozen sync_thread during suspend

1) commit f52f5c71f3d4 ("md: fix stopping sync thread") remove
   MD_RECOVERY_FROZEN from __md_stop_writes() and doesn't realize that
   dm-raid relies on __md_stop_writes() to frozen sync_thread
   indirectly. Fix this problem by adding MD_RECOVERY_FROZEN in
   md_stop_writes(), and since stop_sync_thread() is only used for
   dm-raid in this case, also move stop_sync_thread() to
   md_stop_writes().
2) The flag MD_RECOVERY_FROZEN doesn't mean that sync thread is frozen,
   it only prevent new sync_thread to start, and it can't stop the
   running sync thread; In order to frozen sync_thread, after seting the
   flag, stop_sync_thread() should be used.
3) The flag MD_RECOVERY_FROZEN doesn't mean that writes are stopped, use
   it as condition for md_stop_writes() in raid_postsuspend() doesn't
   look correct. Consider that reentrant stop_sync_thread() do nothing,
   always call md_stop_writes() in raid_postsuspend().
4) raid_message can set/clear the flag MD_RECOVERY_FROZEN at anytime,
   and if MD_RECOVERY_FROZEN is cleared while the array is suspended,
   new sync_thread can start unexpected. Fix this by disallow
   raid_message() to change sync_thread status during suspend.

Note that after commit f52f5c71f3d4 ("md: fix stopping sync thread"), the
test shell/lvconvert-raid-reshape.sh start to hang in stop_sync_thread(),
and with previous fixes, the test won't hang there anymore, however, the
test will still fail and complain that ext4 is corrupted. And with this
patch, the test won't hang due to stop_sync_thread() or fail due to ext4
is corrupted anymore. However, there is still a deadlock related to
dm-raid456 that will be fixed in following patches.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('c5a93c5e47ad50f3f5a00a5f0d0a104686007a3e')">
                                    <div class="issue-number">181</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="c5a93c5e47ad50f3f5a00a5f0d0a104686007a3e">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Prevent crash when disable stream

[Why]
Disabling stream encoder invokes a function that no longer exists.

[How]
Check if the function declaration is NULL in disable stream encoder.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('c010a47c57d7477ceb72a3263ffb1086ae7fe97c')">
                                    <div class="issue-number">182</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="c010a47c57d7477ceb72a3263ffb1086ae7fe97c">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

md/dm-raid: don't call md_reap_sync_thread() directly

Currently md_reap_sync_thread() is called from raid_message() directly
without holding 'reconfig_mutex', this is definitely unsafe because
md_reap_sync_thread() can change many fields that is protected by
'reconfig_mutex'.

However, hold 'reconfig_mutex' here is still problematic because this
will cause deadlock, for example, commit 130443d60b1b ("md: refactor
idle/frozen_sync_thread() to fix deadlock").

Fix this problem by using stop_sync_thread() to unregister sync_thread,
like md/raid did.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('3850d7da0143f51bbfe41089f38dd96399a524c7')">
                                    <div class="issue-number">183</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="3850d7da0143f51bbfe41089f38dd96399a524c7">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

bcachefs: kvfree bch_fs::snapshots in bch2_fs_snapshots_exit

bch_fs::snapshots is allocated by kvzalloc in __snapshot_t_mut.
It should be freed by kvfree not kfree.
Or umount will triger:

[  406.829178 ] BUG: unable to handle page fault for address: ffffe7b487148008
[  406.830676 ] #PF: supervisor read access in kernel mode
[  406.831643 ] #PF: error_code(0x0000) - not-present page
[  406.832487 ] PGD 0 P4D 0
[  406.832898 ] Oops: 0000 [#1] PREEMPT SMP PTI
[  406.833512 ] CPU: 2 PID: 1754 Comm: umount Kdump: loaded Tainted: G           OE      6.7.0-rc7-custom+ #90
[  406.834746 ] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Arch Linux 1.16.3-1-1 04/01/2014
[  406.835796 ] RIP: 0010:kfree+0x62/0x140
[  406.836197 ] Code: 80 48 01 d8 0f 82 e9 00 00 00 48 c7 c2 00 00 00 80 48 2b 15 78 9f 1f 01 48 01 d0 48 c1 e8 0c 48 c1 e0 06 48 03 05 56 9f 1f 01 <48> 8b 50 08 48 89 c7 f6 c2 01 0f 85 b0 00 00 00 66 90 48 8b 07 f6
[  406.837810 ] RSP: 0018:ffffb9d641607e48 EFLAGS: 00010286
[  406.838213 ] RAX: ffffe7b487148000 RBX: ffffb9d645200000 RCX: ffffb9d641607dc4
[  406.838738 ] RDX: 000065bb00000000 RSI: ffffffffc0d88b84 RDI: ffffb9d645200000
[  406.839217 ] RBP: ffff9a4625d00068 R08: 0000000000000001 R09: 0000000000000001
[  406.839650 ] R10: 0000000000000001 R11: 000000000000001f R12: ffff9a4625d4da80
[  406.840055 ] R13: ffff9a4625d00000 R14: ffffffffc0e2eb20 R15: 0000000000000000
[  406.840451 ] FS:  00007f0a264ffb80(0000) GS:ffff9a4e2d500000(0000) knlGS:0000000000000000
[  406.840851 ] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[  406.841125 ] CR2: ffffe7b487148008 CR3: 000000018c4d2000 CR4: 00000000000006f0
[  406.841464 ] Call Trace:
[  406.841583 ]  <TASK>
[  406.841682 ]  ? __die+0x1f/0x70
[  406.841828 ]  ? page_fault_oops+0x159/0x470
[  406.842014 ]  ? fixup_exception+0x22/0x310
[  406.842198 ]  ? exc_page_fault+0x1ed/0x200
[  406.842382 ]  ? asm_exc_page_fault+0x22/0x30
[  406.842574 ]  ? bch2_fs_release+0x54/0x280 [bcachefs]
[  406.842842 ]  ? kfree+0x62/0x140
[  406.842988 ]  ? kfree+0x104/0x140
[  406.843138 ]  bch2_fs_release+0x54/0x280 [bcachefs]
[  406.843390 ]  kobject_put+0xb7/0x170
[  406.843552 ]  deactivate_locked_super+0x2f/0xa0
[  406.843756 ]  cleanup_mnt+0xba/0x150
[  406.843917 ]  task_work_run+0x59/0xa0
[  406.844083 ]  exit_to_user_mode_prepare+0x197/0x1a0
[  406.844302 ]  syscall_exit_to_user_mode+0x16/0x40
[  406.844510 ]  do_syscall_64+0x4e/0xf0
[  406.844675 ]  entry_SYSCALL_64_after_hwframe+0x6e/0x76
[  406.844907 ] RIP: 0033:0x7f0a2664e4fb</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('913c3f43324a36af650c50c59bd173961ef1be97')">
                                    <div class="issue-number">184</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="913c3f43324a36af650c50c59bd173961ef1be97">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

iommu/vt-d: Use device rbtree in iopf reporting path

The existing I/O page fault handler currently locates the PCI device by
calling pci_get_domain_bus_and_slot(). This function searches the list
of all PCI devices until the desired device is found. To improve lookup
efficiency, replace it with device_rbtree_find() to search the device
within the probed device rbtree.

The I/O page fault is initiated by the device, which does not have any
synchronization mechanism with the software to ensure that the device
stays in the probed device tree. Theoretically, a device could be released
by the IOMMU subsystem after device_rbtree_find() and before
iopf_get_dev_fault_param(), which would cause a use-after-free problem.

Add a mutex to synchronize the I/O page fault reporting path and the IOMMU
release device path. This lock doesn't introduce any performance overhead,
as the conflict between I/O page fault reporting and device releasing is
very rare.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('57ba1d76befef7542ed380ccd833146f4e2d5d94')">
                                    <div class="issue-number">185</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="57ba1d76befef7542ed380ccd833146f4e2d5d94">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

bpf: support deferring bpf_link dealloc to after RCU grace period

BPF link for some program types is passed as a "context" which can be
used by those BPF programs to look up additional information. E.g., for
multi-kprobes and multi-uprobes, link is used to fetch BPF cookie values.

Because of this runtime dependency, when bpf_link refcnt drops to zero
there could still be active BPF programs running accessing link data.

This patch adds generic support to defer bpf_link dealloc callback to
after RCU GP, if requested. This is done by exposing two different
deallocation callbacks, one synchronous and one deferred. If deferred
one is provided, bpf_link_free() will schedule dealloc_deferred()
callback to happen after RCU GP.

BPF is using two flavors of RCU: "classic" non-sleepable one and RCU
tasks trace one. The latter is used when sleepable BPF programs are
used. bpf_link_free() accommodates that by checking underlying BPF
program's sleepable flag, and goes either through normal RCU GP only for
non-sleepable, or through RCU tasks trace GP *and* then normal RCU GP
(taking into account rcu_trace_implies_rcu_gp() optimization), if BPF
program is sleepable.

We use this for multi-kprobe and multi-uprobe links, which dereference
link during program run. We also preventively switch raw_tp link to use
deferred dealloc callback, as upcoming changes in bpf-next tree expose
raw_tp link data (specifically, cookie value) to BPF program at runtime
as well.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('fe84ed379b8e7af2d1088ccea4a4a4d106126d48')">
                                    <div class="issue-number">186</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="fe84ed379b8e7af2d1088ccea4a4a4d106126d48">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

smb: client: fix potential UAF in cifs_dump_full_key()

Skip sessions that are being teared down (status == SES_EXITING) to
avoid UAF.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('018b63966c08444a19e73a217eef81a6addc7d9c')">
                                    <div class="issue-number">187</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="018b63966c08444a19e73a217eef81a6addc7d9c">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

smb: client: guarantee refcounted children from parent session

Avoid potential use-after-free bugs when walking DFS referrals,
mounting and performing DFS failover by ensuring that all children
from parent @tcon->ses are also refcounted.  They're all needed across
the entire DFS mount.  Get rid of @tcon->dfs_ses_list while we're at
it, too.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('457de735e58538c7dd0211c6cd776373049baf6a')">
                                    <div class="issue-number">188</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="457de735e58538c7dd0211c6cd776373049baf6a">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

smb: client: fix UAF in smb2_reconnect_server()

The UAF bug is due to smb2_reconnect_server() accessing a session that
is already being teared down by another thread that is executing
__cifs_put_smb_ses().  This can happen when (a) the client has
connection to the server but no session or (b) another thread ends up
setting @ses->ses_status again to something different than
SES_EXITING.

To fix this, we need to make sure to unconditionally set
@ses->ses_status to SES_EXITING and prevent any other threads from
setting a new status while we're still tearing it down.

The following can be reproduced by adding some delay to right after
the ipc is freed in __cifs_put_smb_ses() - which will give
smb2_reconnect_server() worker a chance to run and then accessing
@ses->ipc:

kinit ...
mount.cifs //srv/share /mnt/1 -o sec=krb5,nohandlecache,echo_interval=10
[disconnect srv]
ls /mnt/1 &>/dev/null
sleep 30
kdestroy
[reconnect srv]
sleep 10
umount /mnt/1
...
CIFS: VFS: Verify user has a krb5 ticket and keyutils is installed
CIFS: VFS: \\srv Send error in SessSetup = -126
CIFS: VFS: Verify user has a krb5 ticket and keyutils is installed
CIFS: VFS: \\srv Send error in SessSetup = -126
general protection fault, probably for non-canonical address
0x6b6b6b6b6b6b6b6b: 0000 [#1] PREEMPT SMP NOPTI
CPU: 3 PID: 50 Comm: kworker/3:1 Not tainted 6.9.0-rc2 #1
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.3-1.fc39
04/01/2014
Workqueue: cifsiod smb2_reconnect_server [cifs]
RIP: 0010:__list_del_entry_valid_or_report+0x33/0xf0
Code: 4f 08 48 85 d2 74 42 48 85 c9 74 59 48 b8 00 01 00 00 00 00 ad
de 48 39 c2 74 61 48 b8 22 01 00 00 00 00 74 69 <48> 8b 01 48 39 f8 75
7b 48 8b 72 08 48 39 c6 0f 85 88 00 00 00 b8
RSP: 0018:ffffc900001bfd70 EFLAGS: 00010a83
RAX: dead000000000122 RBX: ffff88810da53838 RCX: 6b6b6b6b6b6b6b6b
RDX: 6b6b6b6b6b6b6b6b RSI: ffffffffc02f6878 RDI: ffff88810da53800
RBP: ffff88810da53800 R08: 0000000000000001 R09: 0000000000000000
R10: 0000000000000000 R11: 0000000000000001 R12: ffff88810c064000
R13: 0000000000000001 R14: ffff88810c064000 R15: ffff8881039cc000
FS: 0000000000000000(0000) GS:ffff888157c00000(0000)
knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007fe3728b1000 CR3: 000000010caa4000 CR4: 0000000000750ef0
PKRU: 55555554
Call Trace:
 <TASK>
 ? die_addr+0x36/0x90
 ? exc_general_protection+0x1c1/0x3f0
 ? asm_exc_general_protection+0x26/0x30
 ? __list_del_entry_valid_or_report+0x33/0xf0
 __cifs_put_smb_ses+0x1ae/0x500 [cifs]
 smb2_reconnect_server+0x4ed/0x710 [cifs]
 process_one_work+0x205/0x6b0
 worker_thread+0x191/0x360
 ? __pfx_worker_thread+0x10/0x10
 kthread+0xe2/0x110
 ? __pfx_kthread+0x10/0x10
 ret_from_fork+0x34/0x50
 ? __pfx_kthread+0x10/0x10
 ret_from_fork_asm+0x1a/0x30
 </TASK></p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('6c428528f09bb6bec3da5b7604c91aba8aae3a06')">
                                    <div class="issue-number">189</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="6c428528f09bb6bec3da5b7604c91aba8aae3a06">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

of: module: prevent NULL pointer dereference in vsnprintf()

In of_modalias(), we can get passed the str and len parameters which would
cause a kernel oops in vsnprintf() since it only allows passing a NULL ptr
when the length is also 0. Also, we need to filter out the negative values
of the len parameter as these will result in a really huge buffer since
snprintf() takes size_t parameter while ours is ssize_t...

Found by Linux Verification Center (linuxtesting.org) with the Svace static
analysis tool.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('8d01f19d574f99b5ae00ae7dc22a6bf8626ca521')">
                                    <div class="issue-number">190</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="8d01f19d574f99b5ae00ae7dc22a6bf8626ca521">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

ax25: fix use-after-free bugs caused by ax25_ds_del_timer

When the ax25 device is detaching, the ax25_dev_device_down()
calls ax25_ds_del_timer() to cleanup the slave_timer. When
the timer handler is running, the ax25_ds_del_timer() that
calls del_timer() in it will return directly. As a result,
the use-after-free bugs could happen, one of the scenarios
is shown below:

      (Thread 1)          |      (Thread 2)
                          | ax25_ds_timeout()
ax25_dev_device_down()    |
  ax25_ds_del_timer()     |
    del_timer()           |
  ax25_dev_put() //FREE   |
                          |  ax25_dev-> //USE

In order to mitigate bugs, when the device is detaching, use
timer_shutdown_sync() to stop the timer.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('9acb71c3ed3560ece29ddfd52c9404058bf88a2d')">
                                    <div class="issue-number">191</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="9acb71c3ed3560ece29ddfd52c9404058bf88a2d">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

selinux: avoid dereference of garbage after mount failure

In case kern_mount() fails and returns an error pointer return in the
error branch instead of continuing and dereferencing the error pointer.

While on it drop the never read static variable selinuxfs_mount.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('eb78c2b5bb314f223d3bfede19b37ab68e91ad10')">
                                    <div class="issue-number">192</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="eb78c2b5bb314f223d3bfede19b37ab68e91ad10">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

usb: typec: ucsi: Limit read size on v1.2

Between UCSI 1.2 and UCSI 2.0, the size of the MESSAGE_IN region was
increased from 16 to 256. In order to avoid overflowing reads for older
systems, add a mechanism to use the read UCSI version to truncate read
sizes on UCSI v1.2.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('8a75ea3e9dff179b86c8bcf7bcd1ed687f2bf34e')">
                                    <div class="issue-number">193</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="8a75ea3e9dff179b86c8bcf7bcd1ed687f2bf34e">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

crypto: iaa - Fix async_disable descriptor leak

The disable_async paths of iaa_compress/decompress() don't free idxd
descriptors in the async_disable case. Currently this only happens in
the testcases where req->dst is set to null. Add a test to free them
in those paths.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('cf823c3d81b5f38ebbef5e81a32808d17aaf2448')">
                                    <div class="issue-number">194</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="cf823c3d81b5f38ebbef5e81a32808d17aaf2448">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

rcu/nocb: Fix WARN_ON_ONCE() in the rcu_nocb_bypass_lock()

For the kernels built with CONFIG_RCU_NOCB_CPU_DEFAULT_ALL=y and
CONFIG_RCU_LAZY=y, the following scenarios will trigger WARN_ON_ONCE()
in the rcu_nocb_bypass_lock() and rcu_nocb_wait_contended() functions:

        CPU2                                               CPU11
kthread
rcu_nocb_cb_kthread                                       ksys_write
rcu_do_batch                                              vfs_write
rcu_torture_timer_cb                                      proc_sys_write
__kmem_cache_free                                         proc_sys_call_handler
kmemleak_free                                             drop_caches_sysctl_handler
delete_object_full                                        drop_slab
__delete_object                                           shrink_slab
put_object                                                lazy_rcu_shrink_scan
call_rcu                                                  rcu_nocb_flush_bypass
__call_rcu_commn                                            rcu_nocb_bypass_lock
                                                            raw_spin_trylock(&rdp->nocb_bypass_lock) fail
                                                            atomic_inc(&rdp->nocb_lock_contended);
rcu_nocb_wait_contended                                     WARN_ON_ONCE(smp_processor_id() != rdp->cpu);
 WARN_ON_ONCE(atomic_read(&rdp->nocb_lock_contended))                                          |
                            |_ _ _ _ _ _ _ _ _ _same rdp and rdp->cpu != 11_ _ _ _ _ _ _ _ _ __|

Reproduce this bug with "echo 3 > /proc/sys/vm/drop_caches".

This commit therefore uses rcu_nocb_try_flush_bypass() instead of
rcu_nocb_flush_bypass() in lazy_rcu_shrink_scan().  If the nocb_bypass
queue is being flushed, then rcu_nocb_try_flush_bypass will return
directly.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('efb4cbfb54c1684e68e402296ed29daa424a6170')">
                                    <div class="issue-number">195</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="efb4cbfb54c1684e68e402296ed29daa424a6170">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amdgpu: Skip do PCI error slot reset during RAS recovery

Why:
    The PCI error slot reset maybe triggered after inject ue to UMC multi times, this
    caused system hang.
    [  557.371857] amdgpu 0000:af:00.0: amdgpu: GPU reset succeeded, trying to resume
    [  557.373718] [drm] PCIE GART of 512M enabled.
    [  557.373722] [drm] PTB located at 0x0000031FED700000
    [  557.373788] [drm] VRAM is lost due to GPU reset!
    [  557.373789] [drm] PSP is resuming...
    [  557.547012] mlx5_core 0000:55:00.0: mlx5_pci_err_detected Device state = 1 pci_status: 0. Exit, result = 3, need reset
    [  557.547067] [drm] PCI error: detected callback, state(1)!!
    [  557.547069] [drm] No support for XGMI hive yet...
    [  557.548125] mlx5_core 0000:55:00.0: mlx5_pci_slot_reset Device state = 1 pci_status: 0. Enter
    [  557.607763] mlx5_core 0000:55:00.0: wait vital counter value 0x16b5b after 1 iterations
    [  557.607777] mlx5_core 0000:55:00.0: mlx5_pci_slot_reset Device state = 1 pci_status: 1. Exit, err = 0, result = 5, recovered
    [  557.610492] [drm] PCI error: slot reset callback!!
    ...
    [  560.689382] amdgpu 0000:3f:00.0: amdgpu: GPU reset(2) succeeded!
    [  560.689546] amdgpu 0000:5a:00.0: amdgpu: GPU reset(2) succeeded!
    [  560.689562] general protection fault, probably for non-canonical address 0x5f080b54534f611f: 0000 [#1] SMP NOPTI
    [  560.701008] CPU: 16 PID: 2361 Comm: kworker/u448:9 Tainted: G           OE     5.15.0-91-generic #101-Ubuntu
    [  560.712057] Hardware name: Microsoft C278A/C278A, BIOS C2789.5.BS.1C11.AG.1 11/08/2023
    [  560.720959] Workqueue: amdgpu-reset-hive amdgpu_ras_do_recovery [amdgpu]
    [  560.728887] RIP: 0010:amdgpu_device_gpu_recover.cold+0xbf1/0xcf5 [amdgpu]
    [  560.736891] Code: ff 41 89 c6 e9 1b ff ff ff 44 0f b6 45 b0 e9 4f ff ff ff be 01 00 00 00 4c 89 e7 e8 76 c9 8b ff 44 0f b6 45 b0 e9 3c fd ff ff <48> 83 ba 18 02 00 00 00 0f 84 6a f8 ff ff 48 8d 7a 78 be 01 00 00
    [  560.757967] RSP: 0018:ffa0000032e53d80 EFLAGS: 00010202
    [  560.763848] RAX: ffa00000001dfd10 RBX: ffa0000000197090 RCX: ffa0000032e53db0
    [  560.771856] RDX: 5f080b54534f5f07 RSI: 0000000000000000 RDI: ff11000128100010
    [  560.779867] RBP: ffa0000032e53df0 R08: 0000000000000000 R09: ffffffffffe77f08
    [  560.787879] R10: 0000000000ffff0a R11: 0000000000000001 R12: 0000000000000000
    [  560.795889] R13: ffa0000032e53e00 R14: 0000000000000000 R15: 0000000000000000
    [  560.803889] FS:  0000000000000000(0000) GS:ff11007e7e800000(0000) knlGS:0000000000000000
    [  560.812973] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [  560.819422] CR2: 000055a04c118e68 CR3: 0000000007410005 CR4: 0000000000771ee0
    [  560.827433] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    [  560.835433] DR3: 0000000000000000 DR6: 00000000fffe07f0 DR7: 0000000000000400
    [  560.843444] PKRU: 55555554
    [  560.846480] Call Trace:
    [  560.849225]  <TASK>
    [  560.851580]  ? show_trace_log_lvl+0x1d6/0x2ea
    [  560.856488]  ? show_trace_log_lvl+0x1d6/0x2ea
    [  560.861379]  ? amdgpu_ras_do_recovery+0x1b2/0x210 [amdgpu]
    [  560.867778]  ? show_regs.part.0+0x23/0x29
    [  560.872293]  ? __die_body.cold+0x8/0xd
    [  560.876502]  ? die_addr+0x3e/0x60
    [  560.880238]  ? exc_general_protection+0x1c5/0x410
    [  560.885532]  ? asm_exc_general_protection+0x27/0x30
    [  560.891025]  ? amdgpu_device_gpu_recover.cold+0xbf1/0xcf5 [amdgpu]
    [  560.898323]  amdgpu_ras_do_recovery+0x1b2/0x210 [amdgpu]
    [  560.904520]  process_one_work+0x228/0x3d0
How:
    In RAS recovery, mode-1 reset is issued from RAS fatal error handling and expected
    all the nodes in a hive to be reset. no need to issue another mode-1 during this procedure.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('2d5328d5ad048b24506d4fa8d66281484ce25510')">
                                    <div class="issue-number">196</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="2d5328d5ad048b24506d4fa8d66281484ce25510">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

pmdomain: imx8mp-blk-ctrl: imx8mp_blk: Add fdcc clock to hdmimix domain

According to i.MX8MP RM and HDMI ADD, the fdcc clock is part of
hdmi rx verification IP that should not enable for HDMI TX.
But actually if the clock is disabled before HDMI/LCDIF probe,
LCDIF will not get pixel clock from HDMI PHY and print the error
logs:

[CRTC:39:crtc-2] vblank wait timed out
WARNING: CPU: 2 PID: 9 at drivers/gpu/drm/drm_atomic_helper.c:1634 drm_atomic_helper_wait_for_vblanks.part.0+0x23c/0x260

Add fdcc clock to LCDIF and HDMI TX power domains to fix the issue.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('bd64069dd54c35f09b5131efbe5470aaff3a0d5f')">
                                    <div class="issue-number">197</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="bd64069dd54c35f09b5131efbe5470aaff3a0d5f">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

net: phy: phy_device: Prevent nullptr exceptions on ISR

If phydev->irq is set unconditionally, check
for valid interrupt handler or fall back to polling mode to prevent
nullptr exceptions in interrupt service routine.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('db06e51fcf289b6b3e95bbd4fb32389b1c26b336')">
                                    <div class="issue-number">198</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="db06e51fcf289b6b3e95bbd4fb32389b1c26b336">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

wifi: rtw89: fix null pointer access when abort scan

During cancel scan we might use vif that weren't scanning.
Fix this by using the actual scanning vif.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('26a9370bac167ac7eb19d3be86e97ef3e336e953')">
                                    <div class="issue-number">199</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="26a9370bac167ac7eb19d3be86e97ef3e336e953">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

bcachefs: Check for journal entries overruning end of sb clean section

Fix a missing bounds check in superblock validation.

Note that we don't yet have repair code for this case - repair code for
individual items is generally low priority, since the whole superblock
is checksummed, validated prior to write, and we have backups.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('e85a759ed9831bc3063794511cee153d67d53b6c')">
                                    <div class="issue-number">200</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="e85a759ed9831bc3063794511cee153d67d53b6c">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

btrfs: make sure that WRITTEN is set on all metadata blocks

We previously would call btrfs_check_leaf() if we had the check
integrity code enabled, which meant that we could only run the extended
leaf checks if we had WRITTEN set on the header flags.

This leaves a gap in our checking, because we could end up with
corruption on disk where WRITTEN isn't set on the leaf, and then the
extended leaf checks don't get run which we rely on to validate all of
the item pointers to make sure we don't access memory outside of the
extent buffer.

However, since 732fab95abe2 ("btrfs: check-integrity: remove
CONFIG_BTRFS_FS_CHECK_INTEGRITY option") we no longer call
btrfs_check_leaf() from btrfs_mark_buffer_dirty(), which means we only
ever call it on blocks that are being written out, and thus have WRITTEN
set, or that are being read in, which should have WRITTEN set.

Add checks to make sure we have WRITTEN set appropriately, and then make
sure __btrfs_check_leaf() always does the item checking.  This will
protect us from file systems that have been corrupted and no longer have
WRITTEN set on some of the blocks.

This was hit on a crafted image tweaking the WRITTEN bit and reported by
KASAN as out-of-bound access in the eb accessors. The example is a dir
item at the end of an eb.

  [2.042] BTRFS warning (device loop1): bad eb member start: ptr 0x3fff start 30572544 member offset 16410 size 2
  [2.040] general protection fault, probably for non-canonical address 0xe0009d1000000003: 0000 [#1] PREEMPT SMP KASAN NOPTI
  [2.537] KASAN: maybe wild-memory-access in range [0x0005088000000018-0x000508800000001f]
  [2.729] CPU: 0 PID: 2587 Comm: mount Not tainted 6.8.2 #1
  [2.729] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014
  [2.621] RIP: 0010:btrfs_get_16+0x34b/0x6d0
  [2.621] RSP: 0018:ffff88810871fab8 EFLAGS: 00000206
  [2.621] RAX: 0000a11000000003 RBX: ffff888104ff8720 RCX: ffff88811b2288c0
  [2.621] RDX: dffffc0000000000 RSI: ffffffff81dd8aca RDI: ffff88810871f748
  [2.621] RBP: 000000000000401a R08: 0000000000000001 R09: ffffed10210e3ee9
  [2.621] R10: ffff88810871f74f R11: 205d323430333737 R12: 000000000000001a
  [2.621] R13: 000508800000001a R14: 1ffff110210e3f5d R15: ffffffff850011e8
  [2.621] FS:  00007f56ea275840(0000) GS:ffff88811b200000(0000) knlGS:0000000000000000
  [2.621] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
  [2.621] CR2: 00007febd13b75c0 CR3: 000000010bb50000 CR4: 00000000000006f0
  [2.621] Call Trace:
  [2.621]  <TASK>
  [2.621]  ? show_regs+0x74/0x80
  [2.621]  ? die_addr+0x46/0xc0
  [2.621]  ? exc_general_protection+0x161/0x2a0
  [2.621]  ? asm_exc_general_protection+0x26/0x30
  [2.621]  ? btrfs_get_16+0x33a/0x6d0
  [2.621]  ? btrfs_get_16+0x34b/0x6d0
  [2.621]  ? btrfs_get_16+0x33a/0x6d0
  [2.621]  ? __pfx_btrfs_get_16+0x10/0x10
  [2.621]  ? __pfx_mutex_unlock+0x10/0x10
  [2.621]  btrfs_match_dir_item_name+0x101/0x1a0
  [2.621]  btrfs_lookup_dir_item+0x1f3/0x280
  [2.621]  ? __pfx_btrfs_lookup_dir_item+0x10/0x10
  [2.621]  btrfs_get_tree+0xd25/0x1910

[ copy more details from report ]</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('d4125be26f31d69113d2604092c58c85c3bbdb6f')">
                                    <div class="issue-number">201</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="d4125be26f31d69113d2604092c58c85c3bbdb6f">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/panfrost: Fix the error path in panfrost_mmu_map_fault_addr()

Subject: [PATCH] drm/panfrost: Fix the error path in
 panfrost_mmu_map_fault_addr()

If some the pages or sgt allocation failed, we shouldn't release the
pages ref we got earlier, otherwise we will end up with unbalanced
get/put_pages() calls. We should instead leave everything in place
and let the BO release function deal with extra cleanup when the object
is destroyed, or let the fault handler try again next time it's called.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('b7c5f56e865e1a319a5827183309f9598d4b88cc')">
                                    <div class="issue-number">202</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="b7c5f56e865e1a319a5827183309f9598d4b88cc">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

btrfs: qgroup: fix qgroup prealloc rsv leak in subvolume operations

Create subvolume, create snapshot and delete subvolume all use
btrfs_subvolume_reserve_metadata() to reserve metadata for the changes
done to the parent subvolume's fs tree, which cannot be mediated in the
normal way via start_transaction. When quota groups (squota or qgroups)
are enabled, this reserves qgroup metadata of type PREALLOC. Once the
operation is associated to a transaction, we convert PREALLOC to
PERTRANS, which gets cleared in bulk at the end of the transaction.

However, the error paths of these three operations were not implementing
this lifecycle correctly. They unconditionally converted the PREALLOC to
PERTRANS in a generic cleanup step regardless of errors or whether the
operation was fully associated to a transaction or not. This resulted in
error paths occasionally converting this rsv to PERTRANS without calling
record_root_in_trans successfully, which meant that unless that root got
recorded in the transaction by some other thread, the end of the
transaction would not free that root's PERTRANS, leaking it. Ultimately,
this resulted in hitting a WARN in CONFIG_BTRFS_DEBUG builds at unmount
for the leaked reservation.

The fix is to ensure that every qgroup PREALLOC reservation observes the
following properties:

1. any failure before record_root_in_trans is called successfully
   results in freeing the PREALLOC reservation.
2. after record_root_in_trans, we convert to PERTRANS, and now the
   transaction owns freeing the reservation.

This patch enforces those properties on the three operations. Without
it, generic/269 with squotas enabled at mkfs time would fail in ~5-10
runs on my system. With this patch, it ran successfully 1000 times in a
row.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('92d073f89934d59680e1cf7ea16c9be5c394c871')">
                                    <div class="issue-number">203</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="92d073f89934d59680e1cf7ea16c9be5c394c871">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

net/mlx5: Register devlink first under devlink lock

In case device is having a non fatal FW error during probe, the
driver will report the error to user via devlink. This will trigger
a WARN_ON, since mlx5 is calling devlink_register() last.
In order to avoid the WARN_ON[1], change mlx5 to invoke devl_register()
first under devlink lock.

[1]
WARNING: CPU: 5 PID: 227 at net/devlink/health.c:483 devlink_recover_notify.constprop.0+0xb8/0xc0
CPU: 5 PID: 227 Comm: kworker/u16:3 Not tainted 6.4.0-rc5_for_upstream_min_debug_2023_06_12_12_38 #1
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014
Workqueue: mlx5_health0000:08:00.0 mlx5_fw_reporter_err_work [mlx5_core]
RIP: 0010:devlink_recover_notify.constprop.0+0xb8/0xc0
Call Trace:
 <TASK>
 ? __warn+0x79/0x120
 ? devlink_recover_notify.constprop.0+0xb8/0xc0
 ? report_bug+0x17c/0x190
 ? handle_bug+0x3c/0x60
 ? exc_invalid_op+0x14/0x70
 ? asm_exc_invalid_op+0x16/0x20
 ? devlink_recover_notify.constprop.0+0xb8/0xc0
 devlink_health_report+0x4a/0x1c0
 mlx5_fw_reporter_err_work+0xa4/0xd0 [mlx5_core]
 process_one_work+0x1bb/0x3c0
 ? process_one_work+0x3c0/0x3c0
 worker_thread+0x4d/0x3c0
 ? process_one_work+0x3c0/0x3c0
 kthread+0xc6/0xf0
 ? kthread_complete_and_exit+0x20/0x20
 ret_from_fork+0x1f/0x30
 </TASK></p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('376eeab23b8146ae92c3f4fd107ab8d545a1dd7d')">
                                    <div class="issue-number">204</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="376eeab23b8146ae92c3f4fd107ab8d545a1dd7d">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

block: fix q->blkg_list corruption during disk rebind

Multiple gendisk instances can allocated/added for single request queue
in case of disk rebind. blkg may still stay in q->blkg_list when calling
blkcg_init_disk() for rebind, then q->blkg_list becomes corrupted.

Fix the list corruption issue by:

- add blkg_init_queue() to initialize q->blkg_list & q->blkcg_mutex only
- move calling blkg_init_queue() into blk_alloc_queue()

The list corruption should be started since commit f1c006f1c685 ("blk-cgroup:
synchronize pd_free_fn() from blkg_free_workfn() and blkcg_deactivate_policy()")
which delays removing blkg from q->blkg_list into blkg_free_workfn().</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('128de6fc819437eac843b432d74fff394ddc9109')">
                                    <div class="issue-number">205</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="128de6fc819437eac843b432d74fff394ddc9109">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amdgpu: Init zone device and drm client after mode-1 reset on reload

In passthrough environment, when amdgpu is reloaded after unload, mode-1
is triggered after initializing the necessary IPs, That init does not
include KFD, and KFD init waits until the reset is completed. KFD init
is called in the reset handler, but in this case, the zone device and
drm client is not initialized, causing app to create kernel panic.

v2: Removing the init KFD condition from amdgpu_amdkfd_drm_client_create.
As the previous version has the potential of creating DRM client twice.

v3: v2 patch results in SDMA engine hung as DRM open causes VM clear to SDMA
before SDMA init. Adding the condition to in drm client creation, on top of v1,
to guard against drm client creation call multiple times.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('f4b16ca395a8aa1f69eff53ee3d9c644f8c37d69')">
                                    <div class="issue-number">206</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="f4b16ca395a8aa1f69eff53ee3d9c644f8c37d69">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Disable idle reallow as part of command/gpint execution

[Why]
Workaroud for a race condition where DMCUB is in the process of
committing to IPS1 during the handshake causing us to miss the
transition into IPS2 and touch the INBOX1 RPTR causing a HW hang.

[How]
Disable the reallow to ensure that we have enough of a gap between entry
and exit and we're not seeing back-to-back wake_and_executes.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('7d8572ce7045ad8156f802b5749e0c56c506647b')">
                                    <div class="issue-number">207</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="7d8572ce7045ad8156f802b5749e0c56c506647b">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

fpga: bridge: add owner module and take its refcount

The current implementation of the fpga bridge assumes that the low-level
module registers a driver for the parent device and uses its owner pointer
to take the module's refcount. This approach is problematic since it can
lead to a null pointer dereference while attempting to get the bridge if
the parent device does not have a driver.

To address this problem, add a module owner pointer to the fpga_bridge
struct and use it to take the module's refcount. Modify the function for
registering a bridge to take an additional owner module parameter and
rename it to avoid conflicts. Use the old function name for a helper macro
that automatically sets the module that registers the bridge as the owner.
This ensures compatibility with existing low-level control modules and
reduces the chances of registering a bridge without setting the owner.

Also, update the documentation to keep it consistent with the new interface
for registering an fpga bridge.

Other changes: opportunistically move put_device() from __fpga_bridge_get()
to fpga_bridge_get() and of_fpga_bridge_get() to improve code clarity since
the bridge device is taken in these functions.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('7880acac02b68322252abdd7f197cfcca47f504f')">
                                    <div class="issue-number">208</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="7880acac02b68322252abdd7f197cfcca47f504f">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

mm/userfaultfd: reset ptes when close() for wr-protected ones

Userfaultfd unregister includes a step to remove wr-protect bits from all
the relevant pgtable entries, but that only covered an explicit
UFFDIO_UNREGISTER ioctl, not a close() on the userfaultfd itself.  Cover
that too.  This fixes a WARN trace.

The only user visible side effect is the user can observe leftover
wr-protect bits even if the user close()ed on an userfaultfd when
releasing the last reference of it.  However hopefully that should be
harmless, and nothing bad should happen even if so.

This change is now more important after the recent page-table-check
patch we merged in mm-unstable (446dd9ad37d0 ("mm/page_table_check:
support userfault wr-protect entries")), as we'll do sanity check on
uffd-wp bits without vma context.  So it's better if we can 100%
guarantee no uffd-wp bit leftovers, to make sure each report will be
valid.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('366c1ad85251bf1f918c1ec7139af2a4aed91f32')">
                                    <div class="issue-number">209</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="366c1ad85251bf1f918c1ec7139af2a4aed91f32">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/nouveau/firmware: Fix SG_DEBUG error with nvkm_firmware_ctor()

Currently, enabling SG_DEBUG in the kernel will cause nouveau to hit a
BUG() on startup:

  kernel BUG at include/linux/scatterlist.h:187!
  invalid opcode: 0000 [#1] PREEMPT SMP NOPTI
  CPU: 7 PID: 930 Comm: (udev-worker) Not tainted 6.9.0-rc3Lyude-Test+ #30
  Hardware name: MSI MS-7A39/A320M GAMING PRO (MS-7A39), BIOS 1.I0 01/22/2019
  RIP: 0010:sg_init_one+0x85/0xa0
  Code: 69 88 32 01 83 e1 03 f6 c3 03 75 20 a8 01 75 1e 48 09 cb 41 89 54
  24 08 49 89 1c 24 41 89 6c 24 0c 5b 5d 41 5c e9 7b b9 88 00 <0f> 0b 0f 0b
  0f 0b 48 8b 05 5e 46 9a 01 eb b2 66 66 2e 0f 1f 84 00
  RSP: 0018:ffffa776017bf6a0 EFLAGS: 00010246
  RAX: 0000000000000000 RBX: ffffa77600d87000 RCX: 000000000000002b
  RDX: 0000000000000001 RSI: 0000000000000000 RDI: ffffa77680d87000
  RBP: 000000000000e000 R08: 0000000000000000 R09: 0000000000000000
  R10: ffff98f4c46aa508 R11: 0000000000000000 R12: ffff98f4c46aa508
  R13: ffff98f4c46aa008 R14: ffffa77600d4a000 R15: ffffa77600d4a018
  FS:  00007feeb5aae980(0000) GS:ffff98f5c4dc0000(0000) knlGS:0000000000000000
  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
  CR2: 00007f22cb9a4520 CR3: 00000001043ba000 CR4: 00000000003506f0
  Call Trace:
   <TASK>
   ? die+0x36/0x90
   ? do_trap+0xdd/0x100
   ? sg_init_one+0x85/0xa0
   ? do_error_trap+0x65/0x80
   ? sg_init_one+0x85/0xa0
   ? exc_invalid_op+0x50/0x70
   ? sg_init_one+0x85/0xa0
   ? asm_exc_invalid_op+0x1a/0x20
   ? sg_init_one+0x85/0xa0
   nvkm_firmware_ctor+0x14a/0x250 [nouveau]
   nvkm_falcon_fw_ctor+0x42/0x70 [nouveau]
   ga102_gsp_booter_ctor+0xb4/0x1a0 [nouveau]
   r535_gsp_oneinit+0xb3/0x15f0 [nouveau]
   ? srso_return_thunk+0x5/0x5f
   ? srso_return_thunk+0x5/0x5f
   ? nvkm_udevice_new+0x95/0x140 [nouveau]
   ? srso_return_thunk+0x5/0x5f
   ? srso_return_thunk+0x5/0x5f
   ? ktime_get+0x47/0xb0
   ? srso_return_thunk+0x5/0x5f
   nvkm_subdev_oneinit_+0x4f/0x120 [nouveau]
   nvkm_subdev_init_+0x39/0x140 [nouveau]
   ? srso_return_thunk+0x5/0x5f
   nvkm_subdev_init+0x44/0x90 [nouveau]
   nvkm_device_init+0x166/0x2e0 [nouveau]
   nvkm_udevice_init+0x47/0x70 [nouveau]
   nvkm_object_init+0x41/0x1c0 [nouveau]
   nvkm_ioctl_new+0x16a/0x290 [nouveau]
   ? __pfx_nvkm_client_child_new+0x10/0x10 [nouveau]
   ? __pfx_nvkm_udevice_new+0x10/0x10 [nouveau]
   nvkm_ioctl+0x126/0x290 [nouveau]
   nvif_object_ctor+0x112/0x190 [nouveau]
   nvif_device_ctor+0x23/0x60 [nouveau]
   nouveau_cli_init+0x164/0x640 [nouveau]
   nouveau_drm_device_init+0x97/0x9e0 [nouveau]
   ? srso_return_thunk+0x5/0x5f
   ? pci_update_current_state+0x72/0xb0
   ? srso_return_thunk+0x5/0x5f
   nouveau_drm_probe+0x12c/0x280 [nouveau]
   ? srso_return_thunk+0x5/0x5f
   local_pci_probe+0x45/0xa0
   pci_device_probe+0xc7/0x270
   really_probe+0xe6/0x3a0
   __driver_probe_device+0x87/0x160
   driver_probe_device+0x1f/0xc0
   __driver_attach+0xec/0x1f0
   ? __pfx___driver_attach+0x10/0x10
   bus_for_each_dev+0x88/0xd0
   bus_add_driver+0x116/0x220
   driver_register+0x59/0x100
   ? __pfx_nouveau_drm_init+0x10/0x10 [nouveau]
   do_one_initcall+0x5b/0x320
   do_init_module+0x60/0x250
   init_module_from_file+0x86/0xc0
   idempotent_init_module+0x120/0x2b0
   __x64_sys_finit_module+0x5e/0xb0
   do_syscall_64+0x83/0x160
   ? srso_return_thunk+0x5/0x5f
   entry_SYSCALL_64_after_hwframe+0x71/0x79
  RIP: 0033:0x7feeb5cc20cd
  Code: ff c3 66 2e 0f 1f 84 00 00 00 00 00 90 f3 0f 1e fa 48 89 f8 48 89
  f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0
  ff ff 73 01 c3 48 8b 0d 1b cd 0c 00 f7 d8 64 89 01 48
  RSP: 002b:00007ffcf220b2c8 EFLAGS: 00000246 ORIG_RAX: 0000000000000139
  RAX: ffffffffffffffda RBX: 000055fdd2916aa0 RCX: 00007feeb5cc20cd
  RDX: 0000000000000000 RSI: 000055fdd29161e0 RDI: 0000000000000035
  RBP: 00007ffcf220b380 R08: 00007feeb5d8fb20 R09: 00007ffcf220b310
  R10: 000055fdd2909dc0 R11: 0000000000000246 R12: 000055
---truncated---</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('d86a1bade68856a8fc3f9cf207963d99b6ed9739')">
                                    <div class="issue-number">210</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="d86a1bade68856a8fc3f9cf207963d99b6ed9739">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

gpiolib: cdev: Fix use after free in lineinfo_changed_notify

The use-after-free issue occurs as follows: when the GPIO chip device file
is being closed by invoking gpio_chrdev_release(), watched_lines is freed
by bitmap_free(), but the unregistration of lineinfo_changed_nb notifier
chain failed due to waiting write rwsem. Additionally, one of the GPIO
chip's lines is also in the release process and holds the notifier chain's
read rwsem. Consequently, a race condition leads to the use-after-free of
watched_lines.

Here is the typical stack when issue happened:

[free]
gpio_chrdev_release()
  --> bitmap_free(cdev->watched_lines)                  <-- freed
  --> blocking_notifier_chain_unregister()
    --> down_write(&nh->rwsem)                          <-- waiting rwsem
          --> __down_write_common()
            --> rwsem_down_write_slowpath()
                  --> schedule_preempt_disabled()
                    --> schedule()

[use]
st54spi_gpio_dev_release()
  --> gpio_free()
    --> gpiod_free()
      --> gpiod_free_commit()
        --> gpiod_line_state_notify()
          --> blocking_notifier_call_chain()
            --> down_read(&nh->rwsem);                  <-- held rwsem
            --> notifier_call_chain()
              --> lineinfo_changed_notify()
                --> test_bit(xxxx, cdev->watched_lines) <-- use after free

The side effect of the use-after-free issue is that a GPIO line event is
being generated for userspace where it shouldn't. However, since the chrdev
is being closed, userspace won't have the chance to read that event anyway.

To fix the issue, call the bitmap_free() function after the unregistration
of lineinfo_changed_nb notifier chain.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('854c1710b6359d54088f5cd96ae33aec3f8e77b2')">
                                    <div class="issue-number">211</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="854c1710b6359d54088f5cd96ae33aec3f8e77b2">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

ipv6: Fix potential uninit-value access in __ip6_make_skb()

As it was done in commit fc1092f51567 ("ipv4: Fix uninit-value access in
__ip_make_skb()") for IPv4, check FLOWI_FLAG_KNOWN_NH on fl6->flowi6_flags
instead of testing HDRINCL on the socket to avoid a race condition which
causes uninit-value access.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('b53935a89e62a34eb1bb89c65664bd6792c08f41')">
                                    <div class="issue-number">212</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="b53935a89e62a34eb1bb89c65664bd6792c08f41">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

SUNRPC: add a missing rpc_stat for TCP TLS

Commit 1548036ef120 ("nfs: make the rpc_stat per net namespace") added
functionality to specify rpc_stats function but missed adding it to the
TCP TLS functionality. As the result, mounting with xprtsec=tls lead to
the following kernel oops.

[  128.984192] Unable to handle kernel NULL pointer dereference at
virtual address 000000000000001c
[  128.985058] Mem abort info:
[  128.985372]   ESR = 0x0000000096000004
[  128.985709]   EC = 0x25: DABT (current EL), IL = 32 bits
[  128.986176]   SET = 0, FnV = 0
[  128.986521]   EA = 0, S1PTW = 0
[  128.986804]   FSC = 0x04: level 0 translation fault
[  128.987229] Data abort info:
[  128.987597]   ISV = 0, ISS = 0x00000004, ISS2 = 0x00000000
[  128.988169]   CM = 0, WnR = 0, TnD = 0, TagAccess = 0
[  128.988811]   GCS = 0, Overlay = 0, DirtyBit = 0, Xs = 0
[  128.989302] user pgtable: 4k pages, 48-bit VAs, pgdp=0000000106c84000
[  128.990048] [000000000000001c] pgd=0000000000000000, p4d=0000000000000000
[  128.990736] Internal error: Oops: 0000000096000004 [#1] SMP
[  128.991168] Modules linked in: nfs_layout_nfsv41_files
rpcsec_gss_krb5 auth_rpcgss nfsv4 dns_resolver nfs lockd grace netfs
uinput dm_mod nft_fib_inet nft_fib_ipv4 nft_fib_ipv6 nft_fib
nft_reject_inet nf_reject_ipv4 nf_reject_ipv6 nft_reject nft_ct
nft_chain_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 rfkill
ip_set nf_tables nfnetlink qrtr vsock_loopback
vmw_vsock_virtio_transport_common vmw_vsock_vmci_transport vsock
sunrpc vfat fat uvcvideo videobuf2_vmalloc videobuf2_memops uvc
videobuf2_v4l2 videodev videobuf2_common mc vmw_vmci xfs libcrc32c
e1000e crct10dif_ce ghash_ce sha2_ce vmwgfx nvme sha256_arm64
nvme_core sr_mod cdrom sha1_ce drm_ttm_helper ttm drm_kms_helper drm
sg fuse
[  128.996466] CPU: 0 PID: 179 Comm: kworker/u4:26 Kdump: loaded Not
tainted 6.8.0-rc6+ #12
[  128.997226] Hardware name: VMware, Inc. VMware20,1/VBSA, BIOS
VMW201.00V.21805430.BA64.2305221830 05/22/2023
[  128.998084] Workqueue: xprtiod xs_tcp_tls_setup_socket [sunrpc]
[  128.998701] pstate: 81400005 (Nzcv daif +PAN -UAO -TCO +DIT -SSBS BTYPE=--)
[  128.999384] pc : call_start+0x74/0x138 [sunrpc]
[  128.999809] lr : __rpc_execute+0xb8/0x3e0 [sunrpc]
[  129.000244] sp : ffff8000832b3a00
[  129.000508] x29: ffff8000832b3a00 x28: ffff800081ac79c0 x27: ffff800081ac7000
[  129.001111] x26: 0000000004248060 x25: 0000000000000000 x24: ffff800081596008
[  129.001757] x23: ffff80007b087240 x22: ffff00009a509d30 x21: 0000000000000000
[  129.002345] x20: ffff000090075600 x19: ffff00009a509d00 x18: ffffffffffffffff
[  129.002912] x17: 733d4d4554535953 x16: 42555300312d746e x15: ffff8000832b3a88
[  129.003464] x14: ffffffffffffffff x13: ffff8000832b3a7d x12: 0000000000000008
[  129.004021] x11: 0101010101010101 x10: ffff8000150cb560 x9 : ffff80007b087c00
[  129.004577] x8 : ffff00009a509de0 x7 : 0000000000000000 x6 : 00000000be8c4ee3
[  129.005026] x5 : 0000000000000000 x4 : 0000000000000000 x3 : ffff000094d56680
[  129.005425] x2 : ffff80007b0637f8 x1 : ffff000090075600 x0 : ffff00009a509d00
[  129.005824] Call trace:
[  129.005967]  call_start+0x74/0x138 [sunrpc]
[  129.006233]  __rpc_execute+0xb8/0x3e0 [sunrpc]
[  129.006506]  rpc_execute+0x160/0x1d8 [sunrpc]
[  129.006778]  rpc_run_task+0x148/0x1f8 [sunrpc]
[  129.007204]  tls_probe+0x80/0xd0 [sunrpc]
[  129.007460]  rpc_ping+0x28/0x80 [sunrpc]
[  129.007715]  rpc_create_xprt+0x134/0x1a0 [sunrpc]
[  129.007999]  rpc_create+0x128/0x2a0 [sunrpc]
[  129.008264]  xs_tcp_tls_setup_socket+0xdc/0x508 [sunrpc]
[  129.008583]  process_one_work+0x174/0x3c8
[  129.008813]  worker_thread+0x2c8/0x3e0
[  129.009033]  kthread+0x100/0x110
[  129.009225]  ret_from_fork+0x10/0x20
[  129.009432] Code: f0ffffc2 911fe042 aa1403e1 aa1303e0 (b9401c83)</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('2e8802e6cb5b9a339028351797eb9835425aad6e')">
                                    <div class="issue-number">213</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="2e8802e6cb5b9a339028351797eb9835425aad6e">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

blk-iocost: do not WARN if iocg was already offlined

In iocg_pay_debt(), warn is triggered if 'active_list' is empty, which
is intended to confirm iocg is active when it has debt. However, warn
can be triggered during a blkcg or disk removal, if iocg_waitq_timer_fn()
is run at that time:

  WARNING: CPU: 0 PID: 2344971 at block/blk-iocost.c:1402 iocg_pay_debt+0x14c/0x190
  Call trace:
  iocg_pay_debt+0x14c/0x190
  iocg_kick_waitq+0x438/0x4c0
  iocg_waitq_timer_fn+0xd8/0x130
  __run_hrtimer+0x144/0x45c
  __hrtimer_run_queues+0x16c/0x244
  hrtimer_interrupt+0x2cc/0x7b0

The warn in this situation is meaningless. Since this iocg is being
removed, the state of the 'active_list' is irrelevant, and 'waitq_timer'
is canceled after removing 'active_list' in ioc_pd_free(), which ensures
iocg is freed after iocg_waitq_timer_fn() returns.

Therefore, add the check if iocg was already offlined to avoid warn
when removing a blkcg or disk.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('69db69f901b00bc370ad994b2b3fdb6cf34bd330')">
                                    <div class="issue-number">214</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="69db69f901b00bc370ad994b2b3fdb6cf34bd330">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

hv_netvsc: Don't free decrypted memory

In CoCo VMs it is possible for the untrusted host to cause
set_memory_encrypted() or set_memory_decrypted() to fail such that an
error is returned and the resulting memory is shared. Callers need to
take care to handle these errors to avoid returning decrypted (shared)
memory to the page allocator, which could lead to functional or security
issues.

The netvsc driver could free decrypted/shared pages if
set_memory_decrypted() fails. Check the decrypted field in the gpadl
to decide whether to free the memory.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('ec6d9fe84659d746d8c63d802c262d25732f628a')">
                                    <div class="issue-number">215</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="ec6d9fe84659d746d8c63d802c262d25732f628a">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

Drivers: hv: vmbus: Leak pages if set_memory_encrypted() fails

In CoCo VMs it is possible for the untrusted host to cause
set_memory_encrypted() or set_memory_decrypted() to fail such that an
error is returned and the resulting memory is shared. Callers need to
take care to handle these errors to avoid returning decrypted (shared)
memory to the page allocator, which could lead to functional or security
issues.

VMBus code could free decrypted pages if set_memory_encrypted()/decrypted()
fails. Leak the pages if this happens.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('8d974689811917752894207a328e45393e23b312')">
                                    <div class="issue-number">216</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="8d974689811917752894207a328e45393e23b312">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

wifi: iwlwifi: mvm: guard against invalid STA ID on removal

Guard against invalid station IDs in iwl_mvm_mld_rm_sta_id as that would
result in out-of-bounds array accesses. This prevents issues should the
driver get into a bad state during error handling.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('02dcb6ea895009a2fa1824d32946e0e7dd69ce62')">
                                    <div class="issue-number">217</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="02dcb6ea895009a2fa1824d32946e0e7dd69ce62">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

wifi: iwlwifi: read txq->read_ptr under lock

If we read txq->read_ptr without lock, we can read the same
value twice, then obtain the lock, and reclaim from there
to two different places, but crucially reclaim the same
entry twice, resulting in the WARN_ONCE() a little later.
Fix that by reading txq->read_ptr under lock.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('7c87902871086c80f034b23766263bd3e6b48bfe')">
                                    <div class="issue-number">218</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="7c87902871086c80f034b23766263bd3e6b48bfe">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

ipv4: Fix uninit-value access in __ip_make_skb()

KMSAN reported uninit-value access in __ip_make_skb() [1].  __ip_make_skb()
tests HDRINCL to know if the skb has icmphdr. However, HDRINCL can cause a
race condition. If calling setsockopt(2) with IP_HDRINCL changes HDRINCL
while __ip_make_skb() is running, the function will access icmphdr in the
skb even if it is not included. This causes the issue reported by KMSAN.

Check FLOWI_FLAG_KNOWN_NH on fl4->flowi4_flags instead of testing HDRINCL
on the socket.

Also, fl4->fl4_icmp_type and fl4->fl4_icmp_code are not initialized. These
are union in struct flowi4 and are implicitly initialized by
flowi4_init_output(), but we should not rely on specific union layout.

Initialize these explicitly in raw_sendmsg().

[1]
BUG: KMSAN: uninit-value in __ip_make_skb+0x2b74/0x2d20 net/ipv4/ip_output.c:1481
 __ip_make_skb+0x2b74/0x2d20 net/ipv4/ip_output.c:1481
 ip_finish_skb include/net/ip.h:243 [inline]
 ip_push_pending_frames+0x4c/0x5c0 net/ipv4/ip_output.c:1508
 raw_sendmsg+0x2381/0x2690 net/ipv4/raw.c:654
 inet_sendmsg+0x27b/0x2a0 net/ipv4/af_inet.c:851
 sock_sendmsg_nosec net/socket.c:730 [inline]
 __sock_sendmsg+0x274/0x3c0 net/socket.c:745
 __sys_sendto+0x62c/0x7b0 net/socket.c:2191
 __do_sys_sendto net/socket.c:2203 [inline]
 __se_sys_sendto net/socket.c:2199 [inline]
 __x64_sys_sendto+0x130/0x200 net/socket.c:2199
 do_syscall_64+0xd8/0x1f0 arch/x86/entry/common.c:83
 entry_SYSCALL_64_after_hwframe+0x6d/0x75

Uninit was created at:
 slab_post_alloc_hook mm/slub.c:3804 [inline]
 slab_alloc_node mm/slub.c:3845 [inline]
 kmem_cache_alloc_node+0x5f6/0xc50 mm/slub.c:3888
 kmalloc_reserve+0x13c/0x4a0 net/core/skbuff.c:577
 __alloc_skb+0x35a/0x7c0 net/core/skbuff.c:668
 alloc_skb include/linux/skbuff.h:1318 [inline]
 __ip_append_data+0x49ab/0x68c0 net/ipv4/ip_output.c:1128
 ip_append_data+0x1e7/0x260 net/ipv4/ip_output.c:1365
 raw_sendmsg+0x22b1/0x2690 net/ipv4/raw.c:648
 inet_sendmsg+0x27b/0x2a0 net/ipv4/af_inet.c:851
 sock_sendmsg_nosec net/socket.c:730 [inline]
 __sock_sendmsg+0x274/0x3c0 net/socket.c:745
 __sys_sendto+0x62c/0x7b0 net/socket.c:2191
 __do_sys_sendto net/socket.c:2203 [inline]
 __se_sys_sendto net/socket.c:2199 [inline]
 __x64_sys_sendto+0x130/0x200 net/socket.c:2199
 do_syscall_64+0xd8/0x1f0 arch/x86/entry/common.c:83
 entry_SYSCALL_64_after_hwframe+0x6d/0x75

CPU: 1 PID: 15709 Comm: syz-executor.7 Not tainted 6.8.0-11567-gb3603fcb79b1 #25
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-1.fc39 04/01/2014</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('6aa69f38a1bb1721fbeac93b47385784b0b4adfe')">
                                    <div class="issue-number">219</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="6aa69f38a1bb1721fbeac93b47385784b0b4adfe">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

amd/amdkfd: sync all devices to wait all processes being evicted

If there are more than one device doing reset in parallel, the first
device will call kfd_suspend_all_processes() to evict all processes
on all devices, this call takes time to finish. other device will
start reset and recover without waiting. if the process has not been
evicted before doing recover, it will be restored, then caused page
fault.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('1d690331c5b28eeed14d62dd530299938003ac63')">
                                    <div class="issue-number">220</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="1d690331c5b28eeed14d62dd530299938003ac63">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amdkfd: range check cp bad op exception interrupts

Due to a CP interrupt bug, bad packet garbage exception codes are raised.
Do a range check so that the debugger and runtime do not receive garbage
codes.
Update the user api to guard exception code type checking as well.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('ad78698e85d015b5f8340d922e606324c6a86b09')">
                                    <div class="issue-number">221</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="ad78698e85d015b5f8340d922e606324c6a86b09">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

Bluetooth: L2CAP: Fix div-by-zero in l2cap_le_flowctl_init()

l2cap_le_flowctl_init() can cause both div-by-zero and an integer
overflow since hdev->le_mtu may not fall in the valid range.

Move MTU from hci_dev to hci_conn to validate MTU and stop the connection
process earlier if MTU is invalid.
Also, add a missing validation in read_buffer_size() and make it return
an error value if the validation fails.
Now hci_conn_add() returns ERR_PTR() as it can fail due to the both a
kzalloc failure and invalid MTU value.

divide error: 0000 [#1] PREEMPT SMP KASAN NOPTI
CPU: 0 PID: 67 Comm: kworker/u5:0 Tainted: G        W          6.9.0-rc5+ #20
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014
Workqueue: hci0 hci_rx_work
RIP: 0010:l2cap_le_flowctl_init+0x19e/0x3f0 net/bluetooth/l2cap_core.c:547
Code: e8 17 17 0c 00 66 41 89 9f 84 00 00 00 bf 01 00 00 00 41 b8 02 00 00 00 4c
89 fe 4c 89 e2 89 d9 e8 27 17 0c 00 44 89 f0 31 d2 <66> f7 f3 89 c3 ff c3 4d 8d
b7 88 00 00 00 4c 89 f0 48 c1 e8 03 42
RSP: 0018:ffff88810bc0f858 EFLAGS: 00010246
RAX: 00000000000002a0 RBX: 0000000000000000 RCX: dffffc0000000000
RDX: 0000000000000000 RSI: ffff88810bc0f7c0 RDI: ffffc90002dcb66f
RBP: ffff88810bc0f880 R08: aa69db2dda70ff01 R09: 0000ffaaaaaaaaaa
R10: 0084000000ffaaaa R11: 0000000000000000 R12: ffff88810d65a084
R13: dffffc0000000000 R14: 00000000000002a0 R15: ffff88810d65a000
FS:  0000000000000000(0000) GS:ffff88811ac00000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 0000000020000100 CR3: 0000000103268003 CR4: 0000000000770ef0
PKRU: 55555554
Call Trace:
 <TASK>
 l2cap_le_connect_req net/bluetooth/l2cap_core.c:4902 [inline]
 l2cap_le_sig_cmd net/bluetooth/l2cap_core.c:5420 [inline]
 l2cap_le_sig_channel net/bluetooth/l2cap_core.c:5486 [inline]
 l2cap_recv_frame+0xe59d/0x11710 net/bluetooth/l2cap_core.c:6809
 l2cap_recv_acldata+0x544/0x10a0 net/bluetooth/l2cap_core.c:7506
 hci_acldata_packet net/bluetooth/hci_core.c:3939 [inline]
 hci_rx_work+0x5e5/0xb20 net/bluetooth/hci_core.c:4176
 process_one_work kernel/workqueue.c:3254 [inline]
 process_scheduled_works+0x90f/0x1530 kernel/workqueue.c:3335
 worker_thread+0x926/0xe70 kernel/workqueue.c:3416
 kthread+0x2e3/0x380 kernel/kthread.c:388
 ret_from_fork+0x5c/0x90 arch/x86/kernel/process.c:147
 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244
 </TASK>
Modules linked in:
---[ end trace 0000000000000000 ]---</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('c67cee5270a61add88e6935f226a1da929415d1e')">
                                    <div class="issue-number">222</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="c67cee5270a61add88e6935f226a1da929415d1e">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

fpga: manager: add owner module and take its refcount

The current implementation of the fpga manager assumes that the low-level
module registers a driver for the parent device and uses its owner pointer
to take the module's refcount. This approach is problematic since it can
lead to a null pointer dereference while attempting to get the manager if
the parent device does not have a driver.

To address this problem, add a module owner pointer to the fpga_manager
struct and use it to take the module's refcount. Modify the functions for
registering the manager to take an additional owner module parameter and
rename them to avoid conflicts. Use the old function names for helper
macros that automatically set the module that registers the manager as the
owner. This ensures compatibility with existing low-level control modules
and reduces the chances of registering a manager without setting the owner.

Also, update the documentation to keep it consistent with the new interface
for registering an fpga manager.

Other changes: opportunistically move put_device() from __fpga_mgr_get() to
fpga_mgr_get() and of_fpga_mgr_get() to improve code clarity since the
manager device is taken in these functions.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('cc18325d7c9601dcd64a31c0477bef21a6fe6b35')">
                                    <div class="issue-number">223</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="cc18325d7c9601dcd64a31c0477bef21a6fe6b35">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

of: module: add buffer overflow check in of_modalias()

In of_modalias(), if the buffer happens to be too small even for the 1st
snprintf() call, the len parameter will become negative and str parameter
(if not NULL initially) will point beyond the buffer's end. Add the buffer
overflow check after the 1st snprintf() call and fix such check after the
strlen() call (accounting for the terminating NUL char).</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('f4b1773855b993ef973f8dee7d21454b997c6804')">
                                    <div class="issue-number">224</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="f4b1773855b993ef973f8dee7d21454b997c6804">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

net/mlx5: Reload only IB representors upon lag disable/enable

On lag disable, the bond IB device along with all of its
representors are destroyed, and then the slaves' representors get reloaded.

In case the slave IB representor load fails, the eswitch error flow
unloads all representors, including ethernet representors, where the
netdevs get detached and removed from lag bond. Such flow is inaccurate
as the lag driver is not responsible for loading/unloading ethernet
representors. Furthermore, the flow described above begins by holding
lag lock to prevent bond changes during disable flow. However, when
reaching the ethernet representors detachment from lag, the lag lock is
required again, triggering the following deadlock:

Call trace:
__switch_to+0xf4/0x148
__schedule+0x2c8/0x7d0
schedule+0x50/0xe0
schedule_preempt_disabled+0x18/0x28
__mutex_lock.isra.13+0x2b8/0x570
__mutex_lock_slowpath+0x1c/0x28
mutex_lock+0x4c/0x68
mlx5_lag_remove_netdev+0x3c/0x1a0 [mlx5_core]
mlx5e_uplink_rep_disable+0x70/0xa0 [mlx5_core]
mlx5e_detach_netdev+0x6c/0xb0 [mlx5_core]
mlx5e_netdev_change_profile+0x44/0x138 [mlx5_core]
mlx5e_netdev_attach_nic_profile+0x28/0x38 [mlx5_core]
mlx5e_vport_rep_unload+0x184/0x1b8 [mlx5_core]
mlx5_esw_offloads_rep_load+0xd8/0xe0 [mlx5_core]
mlx5_eswitch_reload_reps+0x74/0xd0 [mlx5_core]
mlx5_disable_lag+0x130/0x138 [mlx5_core]
mlx5_lag_disable_change+0x6c/0x70 [mlx5_core] // hold ldev->lock
mlx5_devlink_eswitch_mode_set+0xc0/0x410 [mlx5_core]
devlink_nl_cmd_eswitch_set_doit+0xdc/0x180
genl_family_rcv_msg_doit.isra.17+0xe8/0x138
genl_rcv_msg+0xe4/0x220
netlink_rcv_skb+0x44/0x108
genl_rcv+0x40/0x58
netlink_unicast+0x198/0x268
netlink_sendmsg+0x1d4/0x418
sock_sendmsg+0x54/0x60
__sys_sendto+0xf4/0x120
__arm64_sys_sendto+0x30/0x40
el0_svc_common+0x8c/0x120
do_el0_svc+0x30/0xa0
el0_svc+0x20/0x30
el0_sync_handler+0x90/0xb8
el0_sync+0x160/0x180

Thus, upon lag enable/disable, load and unload only the IB representors
of the slaves preventing the deadlock mentioned above.

While at it, refactor the mlx5_esw_offloads_rep_load() function to have
a static helper method for its internal logic, in symmetry with the
representor unload design.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('86640e9d9fcf07e12ab92c4df300b7a2dcf323ab')">
                                    <div class="issue-number">225</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="86640e9d9fcf07e12ab92c4df300b7a2dcf323ab">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

bpf: Add BPF_PROG_TYPE_CGROUP_SKB attach type enforcement in BPF_LINK_CREATE

bpf_prog_attach uses attach_type_to_prog_type to enforce proper
attach type for BPF_PROG_TYPE_CGROUP_SKB. link_create uses
bpf_prog_get and relies on bpf_prog_attach_check_attach_type
to properly verify prog_type <> attach_type association.

Add missing attach_type enforcement for the link_create case.
Otherwise, it's currently possible to attach cgroup_skb prog
types to other cgroup hooks.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('f48b4d4e72988077d853a6d80bfb8e4b877c6865')">
                                    <div class="issue-number">226</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="f48b4d4e72988077d853a6d80bfb8e4b877c6865">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

net: stmmac: move the EST lock to struct stmmac_priv

Reinitialize the whole EST structure would also reset the mutex
lock which is embedded in the EST structure, and then trigger
the following warning. To address this, move the lock to struct
stmmac_priv. We also need to reacquire the mutex lock when doing
this initialization.

DEBUG_LOCKS_WARN_ON(lock->magic != lock)
WARNING: CPU: 3 PID: 505 at kernel/locking/mutex.c:587 __mutex_lock+0xd84/0x1068
 Modules linked in:
 CPU: 3 PID: 505 Comm: tc Not tainted 6.9.0-rc6-00053-g0106679839f7-dirty #29
 Hardware name: NXP i.MX8MPlus EVK board (DT)
 pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)
 pc : __mutex_lock+0xd84/0x1068
 lr : __mutex_lock+0xd84/0x1068
 sp : ffffffc0864e3570
 x29: ffffffc0864e3570 x28: ffffffc0817bdc78 x27: 0000000000000003
 x26: ffffff80c54f1808 x25: ffffff80c9164080 x24: ffffffc080d723ac
 x23: 0000000000000000 x22: 0000000000000002 x21: 0000000000000000
 x20: 0000000000000000 x19: ffffffc083bc3000 x18: ffffffffffffffff
 x17: ffffffc08117b080 x16: 0000000000000002 x15: ffffff80d2d40000
 x14: 00000000000002da x13: ffffff80d2d404b8 x12: ffffffc082b5a5c8
 x11: ffffffc082bca680 x10: ffffffc082bb2640 x9 : ffffffc082bb2698
 x8 : 0000000000017fe8 x7 : c0000000ffffefff x6 : 0000000000000001
 x5 : ffffff8178fe0d48 x4 : 0000000000000000 x3 : 0000000000000027
 x2 : ffffff8178fe0d50 x1 : 0000000000000000 x0 : 0000000000000000
 Call trace:
  __mutex_lock+0xd84/0x1068
  mutex_lock_nested+0x28/0x34
  tc_setup_taprio+0x118/0x68c
  stmmac_setup_tc+0x50/0xf0
  taprio_change+0x868/0xc9c</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('5a2b5a44a0e5cdccacf9db0d9392202593bdd628')">
                                    <div class="issue-number">227</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="5a2b5a44a0e5cdccacf9db0d9392202593bdd628">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

net/mlx5e: Fix netif state handling

mlx5e_suspend cleans resources only if netif_device_present() returns
true. However, mlx5e_resume changes the state of netif, via
mlx5e_nic_enable, only if reg_state == NETREG_REGISTERED.
In the below case, the above leads to NULL-ptr Oops[1] and memory
leaks:

mlx5e_probe
 _mlx5e_resume
  mlx5e_attach_netdev
   mlx5e_nic_enable  <-- netdev not reg, not calling netif_device_attach()
  register_netdev <-- failed for some reason.
ERROR_FLOW:
 _mlx5e_suspend <-- netif_device_present return false, resources aren't freed :(

Hence, clean resources in this case as well.

[1]
BUG: kernel NULL pointer dereference, address: 0000000000000000
PGD 0 P4D 0
Oops: 0010 [#1] SMP
CPU: 2 PID: 9345 Comm: test-ovs-ct-gen Not tainted 6.5.0_for_upstream_min_debug_2023_09_05_16_01 #1
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014
RIP: 0010:0x0
Code: Unable to access opcode bytes at0xffffffffffffffd6.
RSP: 0018:ffff888178aaf758 EFLAGS: 00010246
Call Trace:
 <TASK>
 ? __die+0x20/0x60
 ? page_fault_oops+0x14c/0x3c0
 ? exc_page_fault+0x75/0x140
 ? asm_exc_page_fault+0x22/0x30
 notifier_call_chain+0x35/0xb0
 blocking_notifier_call_chain+0x3d/0x60
 mlx5_blocking_notifier_call_chain+0x22/0x30 [mlx5_core]
 mlx5_core_uplink_netdev_event_replay+0x3e/0x60 [mlx5_core]
 mlx5_mdev_netdev_track+0x53/0x60 [mlx5_ib]
 mlx5_ib_roce_init+0xc3/0x340 [mlx5_ib]
 __mlx5_ib_add+0x34/0xd0 [mlx5_ib]
 mlx5r_probe+0xe1/0x210 [mlx5_ib]
 ? auxiliary_match_id+0x6a/0x90
 auxiliary_bus_probe+0x38/0x80
 ? driver_sysfs_add+0x51/0x80
 really_probe+0xc9/0x3e0
 ? driver_probe_device+0x90/0x90
 __driver_probe_device+0x80/0x160
 driver_probe_device+0x1e/0x90
 __device_attach_driver+0x7d/0x100
 bus_for_each_drv+0x80/0xd0
 __device_attach+0xbc/0x1f0
 bus_probe_device+0x86/0xa0
 device_add+0x637/0x840
 __auxiliary_device_add+0x3b/0xa0
 add_adev+0xc9/0x140 [mlx5_core]
 mlx5_rescan_drivers_locked+0x22a/0x310 [mlx5_core]
 mlx5_register_device+0x53/0xa0 [mlx5_core]
 mlx5_init_one_devl_locked+0x5c4/0x9c0 [mlx5_core]
 mlx5_init_one+0x3b/0x60 [mlx5_core]
 probe_one+0x44c/0x730 [mlx5_core]
 local_pci_probe+0x3e/0x90
 pci_device_probe+0xbf/0x210
 ? kernfs_create_link+0x5d/0xa0
 ? sysfs_do_create_link_sd+0x60/0xc0
 really_probe+0xc9/0x3e0
 ? driver_probe_device+0x90/0x90
 __driver_probe_device+0x80/0x160
 driver_probe_device+0x1e/0x90
 __device_attach_driver+0x7d/0x100
 bus_for_each_drv+0x80/0xd0
 __device_attach+0xbc/0x1f0
 pci_bus_add_device+0x54/0x80
 pci_iov_add_virtfn+0x2e6/0x320
 sriov_enable+0x208/0x420
 mlx5_core_sriov_configure+0x9e/0x200 [mlx5_core]
 sriov_numvfs_store+0xae/0x1a0
 kernfs_fop_write_iter+0x10c/0x1a0
 vfs_write+0x291/0x3c0
 ksys_write+0x5f/0xe0
 do_syscall_64+0x3d/0x90
 entry_SYSCALL_64_after_hwframe+0x46/0xb0
 CR2: 0000000000000000
 ---[ end trace 0000000000000000  ]---</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('b9d1ab36615e1cf25df7cc08bec42f6e22fd8add')">
                                    <div class="issue-number">228</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="b9d1ab36615e1cf25df7cc08bec42f6e22fd8add">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

media: i2c: et8ek8: Don't strip remove function when driver is builtin

Using __exit for the remove function results in the remove callback
being discarded with CONFIG_VIDEO_ET8EK8=y. When such a device gets
unbound (e.g. using sysfs or hotplug), the driver is just removed
without the cleanup being performed. This results in resource leaks. Fix
it by compiling in the remove callback unconditionally.

This also fixes a W=1 modpost warning:

	WARNING: modpost: drivers/media/i2c/et8ek8/et8ek8: section mismatch in reference: et8ek8_i2c_driver+0x10 (section: .data) -> et8ek8_remove (section: .exit.text)</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('6ed93ec6c5b31b061a62d25a22f2c6845cb7c124')">
                                    <div class="issue-number">229</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="6ed93ec6c5b31b061a62d25a22f2c6845cb7c124">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

Bluetooth: HCI: Remove HCI_AMP support

Since BT_HS has been remove HCI_AMP controllers no longer has any use so
remove it along with the capability of creating AMP controllers.

Since we no longer need to differentiate between AMP and Primary
controllers, as only HCI_PRIMARY is left, this also remove
hdev->dev_type altogether.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('009cca2b1a9d6644c15f39928e6374ce7c0413c1')">
                                    <div class="issue-number">230</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="009cca2b1a9d6644c15f39928e6374ce7c0413c1">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/msm/dpu: Add callback function pointer check before its call

In dpu_core_irq_callback_handler() callback function pointer is compared to NULL,
but then callback function is unconditionally called by this pointer.
Fix this bug by adding conditional return.

Found by Linux Verification Center (linuxtesting.org) with SVACE.

Patchwork: https://patchwork.freedesktop.org/patch/588237/</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('24e90a191fd03ed7d9039a538b03db4d8d10d5ce')">
                                    <div class="issue-number">231</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="24e90a191fd03ed7d9039a538b03db4d8d10d5ce">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

fs/ntfs3: Check 'folio' pointer for NULL

It can be NULL if bmap is called.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('83877e435dae1d4bab0d59c95f8f1f8907d280aa')">
                                    <div class="issue-number">232</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="83877e435dae1d4bab0d59c95f8f1f8907d280aa">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

Revert "xsk: Support redirect to any socket bound to the same umem"

This reverts commit 2863d665ea41282379f108e4da6c8a2366ba66db.

This patch introduced a potential kernel crash when multiple napi instances
redirect to the same AF_XDP socket. By removing the queue_index check, it is
possible for multiple napi instances to access the Rx ring at the same time,
which will result in a corrupted ring state which can lead to a crash when
flushing the rings in __xsk_flush(). This can happen when the linked list of
sockets to flush gets corrupted by concurrent accesses. A quick and small fix
is not possible, so let us revert this for now.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('e8b1b20b5fae78f2f004cff9212897347bb45a77')">
                                    <div class="issue-number">233</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="e8b1b20b5fae78f2f004cff9212897347bb45a77">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

crypto: starfive - Do not free stack buffer

RSA text data uses variable length buffer allocated in software stack.
Calling kfree on it causes undefined behaviour in subsequent operations.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('3c53b812b046b05d41db6c7e6e701bd7a6b98558')">
                                    <div class="issue-number">234</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="3c53b812b046b05d41db6c7e6e701bd7a6b98558">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

iommu: Return right value in iommu_sva_bind_device()

iommu_sva_bind_device() should return either a sva bond handle or an
ERR_PTR value in error cases. Existing drivers (idxd and uacce) only
check the return value with IS_ERR(). This could potentially lead to
a kernel NULL pointer dereference issue if the function returns NULL
instead of an error pointer.

In reality, this doesn't cause any problems because iommu_sva_bind_device()
only returns NULL when the kernel is not configured with CONFIG_IOMMU_SVA.
In this case, iommu_dev_enable_feature(dev, IOMMU_DEV_FEAT_SVA) will
return an error, and the device drivers won't call iommu_sva_bind_device()
at all.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('94c652d989111e752581a3ca69985d23f1c5163f')">
                                    <div class="issue-number">235</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="94c652d989111e752581a3ca69985d23f1c5163f">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

i2c: lpi2c: Avoid calling clk_get_rate during transfer

Instead of repeatedly calling clk_get_rate for each transfer, lock
the clock rate and cache the value.
A deadlock has been observed while adding tlv320aic32x4 audio codec to
the system. When this clock provider adds its clock, the clk mutex is
locked already, it needs to access i2c, which in return needs the mutex
for clk_get_rate as well.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('2aaaadfeae02fe7c385761273a8c95e53c763fef')">
                                    <div class="issue-number">236</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="2aaaadfeae02fe7c385761273a8c95e53c763fef">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

f2fs: don't set RO when shutting down f2fs

Shutdown does not check the error of thaw_super due to readonly, which
causes a deadlock like below.

f2fs_ioc_shutdown(F2FS_GOING_DOWN_FULLSYNC)        issue_discard_thread
 - bdev_freeze
  - freeze_super
 - f2fs_stop_checkpoint()
  - f2fs_handle_critical_error                     - sb_start_write
    - set RO                                         - waiting
 - bdev_thaw
  - thaw_super_locked
    - return -EINVAL, if sb_rdonly()
 - f2fs_stop_discard_thread
  -> wait for kthread_stop(discard_thread);</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('fb569a25bc54c85930ed454f0ef469350ec3b06a')">
                                    <div class="issue-number">237</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="fb569a25bc54c85930ed454f0ef469350ec3b06a">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

media: mtk-vcodec: potential null pointer deference in SCP

The return value of devm_kzalloc() needs to be checked to avoid
NULL pointer deference. This is similar to CVE-2022-3113.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('d5a4173f482d3b987b06c05a706bcbeddb782207')">
                                    <div class="issue-number">238</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="d5a4173f482d3b987b06c05a706bcbeddb782207">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

platform/x86: x86-android-tablets: Unregister devices in reverse order

Not all subsystems support a device getting removed while there are
still consumers of the device with a reference to the device.

One example of this is the regulator subsystem. If a regulator gets
unregistered while there are still drivers holding a reference
a WARN() at drivers/regulator/core.c:5829 triggers, e.g.:

 WARNING: CPU: 1 PID: 1587 at drivers/regulator/core.c:5829 regulator_unregister
 Hardware name: Intel Corp. VALLEYVIEW C0 PLATFORM/BYT-T FFD8, BIOS BLADE_21.X64.0005.R00.1504101516 FFD8_X64_R_2015_04_10_1516 04/10/2015
 RIP: 0010:regulator_unregister
 Call Trace:
  <TASK>
  regulator_unregister
  devres_release_group
  i2c_device_remove
  device_release_driver_internal
  bus_remove_device
  device_del
  device_unregister
  x86_android_tablet_remove

On the Lenovo Yoga Tablet 2 series the bq24190 charger chip also provides
a 5V boost converter output for powering USB devices connected to the micro
USB port, the bq24190-charger driver exports this as a Vbus regulator.

On the 830 (8") and 1050 ("10") models this regulator is controlled by
a platform_device and x86_android_tablet_remove() removes platform_device-s
before i2c_clients so the consumer gets removed first.

But on the 1380 (13") model there is a lc824206xa micro-USB switch
connected over I2C and the extcon driver for that controls the regulator.
The bq24190 i2c-client *must* be registered first, because that creates
the regulator with the lc824206xa listed as its consumer. If the regulator
has not been registered yet the lc824206xa driver will end up getting
a dummy regulator.

Since in this case both the regulator provider and consumer are I2C
devices, the only way to ensure that the consumer is unregistered first
is to unregister the I2C devices in reverse order of in which they were
created.

For consistency and to avoid similar problems in the future change
x86_android_tablet_remove() to unregister all device types in reverse
order.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('833b36bd166d295fcbe305d2464d8cf1e34ed13f')">
                                    <div class="issue-number">239</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="833b36bd166d295fcbe305d2464d8cf1e34ed13f">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

ssb: Fix potential NULL pointer dereference in ssb_device_uevent()

The ssb_device_uevent() function first attempts to convert the 'dev' pointer
to 'struct ssb_device *'. However, it mistakenly dereferences 'dev' before
performing the NULL check, potentially leading to a NULL pointer
dereference if 'dev' is NULL.

To fix this issue, move the NULL check before dereferencing the 'dev' pointer,
ensuring that the pointer is valid before attempting to use it.

Found by Linux Verification Center (linuxtesting.org) with SVACE.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('6a86f3359b4d5a2b09aa8e85d220370397ea925f')">
                                    <div class="issue-number">240</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="6a86f3359b4d5a2b09aa8e85d220370397ea925f">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

cpufreq: amd-pstate: fix memory leak on CPU EPP exit

The cpudata memory from kzalloc() in amd_pstate_epp_cpu_init() is
not freed in the analogous exit function, so fix that.

[ rjw: Subject and changelog edits ]</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('d32a9abc47f5c747c7ce89bd2bab385e5071d8d8')">
                                    <div class="issue-number">241</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="d32a9abc47f5c747c7ce89bd2bab385e5071d8d8">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

ext4: fix uninitialized ratelimit_state->lock access in __ext4_fill_super()

In the following concurrency we will access the uninitialized rs->lock:

ext4_fill_super
  ext4_register_sysfs
   // sysfs registered msg_ratelimit_interval_ms
                             // Other processes modify rs->interval to
                             // non-zero via msg_ratelimit_interval_ms
  ext4_orphan_cleanup
    ext4_msg(sb, KERN_INFO, "Errors on filesystem, "
      __ext4_msg
        ___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state)
          if (!rs->interval)  // do nothing if interval is 0
            return 1;
          raw_spin_trylock_irqsave(&rs->lock, flags)
            raw_spin_trylock(lock)
              _raw_spin_trylock
                __raw_spin_trylock
                  spin_acquire(&lock->dep_map, 0, 1, _RET_IP_)
                    lock_acquire
                      __lock_acquire
                        register_lock_class
                          assign_lock_key
                            dump_stack();
  ratelimit_state_init(&sbi->s_msg_ratelimit_state, 5 * HZ, 10);
    raw_spin_lock_init(&rs->lock);
    // init rs->lock here

and get the following dump_stack:

=========================================================
INFO: trying to register non-static key.
The code is fine but needs lockdep annotation, or maybe
you didn't initialize this object before use?
turning off the locking correctness validator.
CPU: 12 PID: 753 Comm: mount Tainted: G E 6.7.0-rc6-next-20231222 #504
[...]
Call Trace:
 dump_stack_lvl+0xc5/0x170
 dump_stack+0x18/0x30
 register_lock_class+0x740/0x7c0
 __lock_acquire+0x69/0x13a0
 lock_acquire+0x120/0x450
 _raw_spin_trylock+0x98/0xd0
 ___ratelimit+0xf6/0x220
 __ext4_msg+0x7f/0x160 [ext4]
 ext4_orphan_cleanup+0x665/0x740 [ext4]
 __ext4_fill_super+0x21ea/0x2b10 [ext4]
 ext4_fill_super+0x14d/0x360 [ext4]
[...]
=========================================================

Normally interval is 0 until s_msg_ratelimit_state is initialized, so
___ratelimit() does nothing. But registering sysfs precedes initializing
rs->lock, so it is possible to change rs->interval to a non-zero value
via the msg_ratelimit_interval_ms interface of sysfs while rs->lock is
uninitialized, and then a call to ext4_msg triggers the problem by
accessing an uninitialized rs->lock. Therefore register sysfs after all
initializations are complete to avoid such problems.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('8bc90ea5e2f5561eaa0fa6e81c6fa37ea0064c1a')">
                                    <div class="issue-number">242</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="8bc90ea5e2f5561eaa0fa6e81c6fa37ea0064c1a">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

net: ena: Add validation for completion descriptors consistency

Validate that `first` flag is set only for the first
descriptor in multi-buffer packets.
In case of an invalid descriptor, a reset will occur.
A new reset reason for RX data corruption has been added.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('d268633c51fb712fbb3933f90c7b4e775bcf4155')">
                                    <div class="issue-number">243</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="d268633c51fb712fbb3933f90c7b4e775bcf4155">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amdgpu: change vm->task_info handling

This patch changes the handling and lifecycle of vm->task_info object.
The major changes are:
- vm->task_info is a dynamically allocated ptr now, and its uasge is
  reference counted.
- introducing two new helper funcs for task_info lifecycle management
    - amdgpu_vm_get_task_info: reference counts up task_info before
      returning this info
    - amdgpu_vm_put_task_info: reference counts down task_info
- last put to task_info() frees task_info from the vm.

This patch also does logistical changes required for existing usage
of vm->task_info.

V2: Do not block all the prints when task_info not found (Felix)

V3: Fixed review comments from Felix
   - Fix wrong indentation
   - No debug message for -ENOMEM
   - Add NULL check for task_info
   - Do not duplicate the debug messages (ti vs no ti)
   - Get first reference of task_info in vm_init(), put last
     in vm_fini()

V4: Fixed review comments from Felix
   - fix double reference increment in create_task_info
   - change amdgpu_vm_get_task_info_pasid
   - additional changes in amdgpu_gem.c while porting</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('9f6544d22702082344fa042eb7ed413f8c52a274')">
                                    <div class="issue-number">244</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="9f6544d22702082344fa042eb7ed413f8c52a274">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

xfs: add bounds checking to xlog_recover_process_data

There is a lack of verification of the space occupied by fixed members
of xlog_op_header in the xlog_recover_process_data.

We can create a crafted image to trigger an out of bounds read by
following these steps:
    1) Mount an image of xfs, and do some file operations to leave records
    2) Before umounting, copy the image for subsequent steps to simulate
       abnormal exit. Because umount will ensure that tail_blk and
       head_blk are the same, which will result in the inability to enter
       xlog_recover_process_data
    3) Write a tool to parse and modify the copied image in step 2
    4) Make the end of the xlog_op_header entries only 1 byte away from
       xlog_rec_header->h_size
    5) xlog_rec_header->h_num_logops++
    6) Modify xlog_rec_header->h_crc

Fix:
Add a check to make sure there is sufficient space to access fixed members
of xlog_op_header.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('87d5d4b41035288baf48e662d2ab1f57b44ef2bc')">
                                    <div class="issue-number">245</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="87d5d4b41035288baf48e662d2ab1f57b44ef2bc">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

sched/deadline: Fix task_struct reference leak

During the execution of the following stress test with linux-rt:

stress-ng --cyclic 30 --timeout 30 --minimize --quiet

kmemleak frequently reported a memory leak concerning the task_struct:

unreferenced object 0xffff8881305b8000 (size 16136):
  comm "stress-ng", pid 614, jiffies 4294883961 (age 286.412s)
  object hex dump (first 32 bytes):
    02 40 00 00 00 00 00 00 00 00 00 00 00 00 00 00  .@..............
    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
  debug hex dump (first 16 bytes):
    53 09 00 00 00 00 00 00 00 00 00 00 00 00 00 00  S...............
  backtrace:
    [<00000000046b6790>] dup_task_struct+0x30/0x540
    [<00000000c5ca0f0b>] copy_process+0x3d9/0x50e0
    [<00000000ced59777>] kernel_clone+0xb0/0x770
    [<00000000a50befdc>] __do_sys_clone+0xb6/0xf0
    [<000000001dbf2008>] do_syscall_64+0x5d/0xf0
    [<00000000552900ff>] entry_SYSCALL_64_after_hwframe+0x6e/0x76

The issue occurs in start_dl_timer(), which increments the task_struct
reference count and sets a timer. The timer callback, dl_task_timer,
is supposed to decrement the reference count upon expiration. However,
if enqueue_task_dl() is called before the timer expires and cancels it,
the reference count is not decremented, leading to the leak.

This patch fixes the reference leak by ensuring the task_struct
reference count is properly decremented when the timer is canceled.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('bfd2729a8286b4050fbaed967e28d9e07fe4e5d1')">
                                    <div class="issue-number">246</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="bfd2729a8286b4050fbaed967e28d9e07fe4e5d1">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

mm/filemap: skip to create PMD-sized page cache if needed

On ARM64, HPAGE_PMD_ORDER is 13 when the base page size is 64KB.  The
PMD-sized page cache can't be supported by xarray as the following error
messages indicate.

------------[ cut here ]------------
WARNING: CPU: 35 PID: 7484 at lib/xarray.c:1025 xas_split_alloc+0xf8/0x128
Modules linked in: nft_fib_inet nft_fib_ipv4 nft_fib_ipv6 nft_fib  \
nft_reject_inet nf_reject_ipv4 nf_reject_ipv6 nft_reject nft_ct    \
nft_chain_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4    \
ip_set rfkill nf_tables nfnetlink vfat fat virtio_balloon drm      \
fuse xfs libcrc32c crct10dif_ce ghash_ce sha2_ce sha256_arm64      \
sha1_ce virtio_net net_failover virtio_console virtio_blk failover \
dimlib virtio_mmio
CPU: 35 PID: 7484 Comm: test Kdump: loaded Tainted: G W 6.10.0-rc5-gavin+ #9
Hardware name: QEMU KVM Virtual Machine, BIOS edk2-20240524-1.el9 05/24/2024
pstate: 83400005 (Nzcv daif +PAN -UAO +TCO +DIT -SSBS BTYPE=--)
pc : xas_split_alloc+0xf8/0x128
lr : split_huge_page_to_list_to_order+0x1c4/0x720
sp : ffff800087a4f6c0
x29: ffff800087a4f6c0 x28: ffff800087a4f720 x27: 000000001fffffff
x26: 0000000000000c40 x25: 000000000000000d x24: ffff00010625b858
x23: ffff800087a4f720 x22: ffffffdfc0780000 x21: 0000000000000000
x20: 0000000000000000 x19: ffffffdfc0780000 x18: 000000001ff40000
x17: 00000000ffffffff x16: 0000018000000000 x15: 51ec004000000000
x14: 0000e00000000000 x13: 0000000000002000 x12: 0000000000000020
x11: 51ec000000000000 x10: 51ece1c0ffff8000 x9 : ffffbeb961a44d28
x8 : 0000000000000003 x7 : ffffffdfc0456420 x6 : ffff0000e1aa6eb8
x5 : 20bf08b4fe778fca x4 : ffffffdfc0456420 x3 : 0000000000000c40
x2 : 000000000000000d x1 : 000000000000000c x0 : 0000000000000000
Call trace:
 xas_split_alloc+0xf8/0x128
 split_huge_page_to_list_to_order+0x1c4/0x720
 truncate_inode_partial_folio+0xdc/0x160
 truncate_inode_pages_range+0x1b4/0x4a8
 truncate_pagecache_range+0x84/0xa0
 xfs_flush_unmap_range+0x70/0x90 [xfs]
 xfs_file_fallocate+0xfc/0x4d8 [xfs]
 vfs_fallocate+0x124/0x2e8
 ksys_fallocate+0x4c/0xa0
 __arm64_sys_fallocate+0x24/0x38
 invoke_syscall.constprop.0+0x7c/0xd8
 do_el0_svc+0xb4/0xd0
 el0_svc+0x44/0x1d8
 el0t_64_sync_handler+0x134/0x150
 el0t_64_sync+0x17c/0x180

Fix it by skipping to allocate PMD-sized page cache when its size is
larger than MAX_PAGECACHE_ORDER.  For this specific case, we will fall to
regular path where the readahead window is determined by BDI's sysfs file
(read_ahead_kb).</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('c71b07b2d8d491e147ceba41ccf7776efa9d8321')">
                                    <div class="issue-number">247</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="c71b07b2d8d491e147ceba41ccf7776efa9d8321">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

bpf: Defer work in bpf_timer_cancel_and_free

Currently, the same case as previous patch (two timer callbacks trying
to cancel each other) can be invoked through bpf_map_update_elem as
well, or more precisely, freeing map elements containing timers. Since
this relies on hrtimer_cancel as well, it is prone to the same deadlock
situation as the previous patch.

It would be sufficient to use hrtimer_try_to_cancel to fix this problem,
as the timer cannot be enqueued after async_cancel_and_free. Once
async_cancel_and_free has been done, the timer must be reinitialized
before it can be armed again. The callback running in parallel trying to
arm the timer will fail, and freeing bpf_hrtimer without waiting is
sufficient (given kfree_rcu), and bpf_timer_cb will return
HRTIMER_NORESTART, preventing the timer from being rearmed again.

However, there exists a UAF scenario where the callback arms the timer
before entering this function, such that if cancellation fails (due to
timer callback invoking this routine, or the target timer callback
running concurrently). In such a case, if the timer expiration is
significantly far in the future, the RCU grace period expiration
happening before it will free the bpf_hrtimer state and along with it
the struct hrtimer, that is enqueued.

Hence, it is clear cancellation needs to occur after
async_cancel_and_free, and yet it cannot be done inline due to deadlock
issues. We thus modify bpf_timer_cancel_and_free to defer work to the
global workqueue, adding a work_struct alongside rcu_head (both used at
_different_ points of time, so can share space).

Update existing code comments to reflect the new state of affairs.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('8da624de04ba5c4227842a211bb69e2779c04d62')">
                                    <div class="issue-number">248</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="8da624de04ba5c4227842a211bb69e2779c04d62">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

btrfs: scrub: handle RST lookup error correctly

[BUG]
When running btrfs/060 with forced RST feature, it would crash the
following ASSERT() inside scrub_read_endio():

	ASSERT(sector_nr < stripe->nr_sectors);

Before that, we would have tree dump from
btrfs_get_raid_extent_offset(), as we failed to find the RST entry for
the range.

[CAUSE]
Inside scrub_submit_extent_sector_read() every time we allocated a new
bbio we immediately called btrfs_map_block() to make sure there was some
RST range covering the scrub target.

But if btrfs_map_block() fails, we immediately call endio for the bbio,
while the bbio is newly allocated, it's completely empty.

Then inside scrub_read_endio(), we go through the bvecs to find
the sector number (as bi_sector is no longer reliable if the bio is
submitted to lower layers).

And since the bio is empty, such bvecs iteration would not find any
sector matching the sector, and return sector_nr == stripe->nr_sectors,
triggering the ASSERT().

[FIX]
Instead of calling btrfs_map_block() after allocating a new bbio, call
btrfs_map_block() first.

Since our only objective of calling btrfs_map_block() is only to update
stripe_len, there is really no need to do that after btrfs_alloc_bio().

This new timing would avoid the problem of handling empty bbio
completely, and in fact fixes a possible race window for the old code,
where if the submission thread is the only owner of the pending_io, the
scrub would never finish (since we didn't decrease the pending_io
counter).

Although the root cause of RST lookup failure still needs to be
addressed.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('cc2f37f1c7c6945b3a79ff90ada335f7f9d9b15c')">
                                    <div class="issue-number">249</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="cc2f37f1c7c6945b3a79ff90ada335f7f9d9b15c">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

nvme-fabrics: use reserved tag for reg read/write command

In some scenarios, if too many commands are issued by nvme command in
the same time by user tasks, this may exhaust all tags of admin_q. If
a reset (nvme reset or IO timeout) occurs before these commands finish,
reconnect routine may fail to update nvme regs due to insufficient tags,
which will cause kernel hang forever. In order to workaround this issue,
maybe we can let reg_read32()/reg_read64()/reg_write32() use reserved
tags. This maybe safe for nvmf:

1. For the disable ctrl path,  we will not issue connect command
2. For the enable ctrl / fw activate path, since connect and reg_xx()
   are called serially.

So the reserved tags may still be enough while reg_xx() use reserved tags.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('56f34aaa94f09953b1261dd893a20cad4c5c77ff')">
                                    <div class="issue-number">250</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="56f34aaa94f09953b1261dd893a20cad4c5c77ff">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Skip pipe if the pipe idx not set properly

[why]
Driver crashes when pipe idx not set properly

[how]
Add code to skip the pipe that idx not set properly</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('21bde4eaa2c6642a06ad3733aa52b4c739c495a7')">
                                    <div class="issue-number">251</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="21bde4eaa2c6642a06ad3733aa52b4c739c495a7">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

bpf: Take return from set_memory_rox() into account with bpf_jit_binary_lock_ro()

set_memory_rox() can fail, leaving memory unprotected.

Check return and bail out when bpf_jit_binary_lock_ro() returns
an error.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('ddcaa71fe133bae35e5808af25907c8b9b09caca')">
                                    <div class="issue-number">252</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="ddcaa71fe133bae35e5808af25907c8b9b09caca">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

gfs2: Fix NULL pointer dereference in gfs2_log_flush

In gfs2_jindex_free(), set sdp->sd_jdesc to NULL under the log flush
lock to provide exclusion against gfs2_log_flush().

In gfs2_log_flush(), check if sdp->sd_jdesc is non-NULL before
dereferencing it.  Otherwise, we could run into a NULL pointer
dereference when outstanding glock work races with an unmount
(glock_work_func -> run_queue -> do_xmote -> inode_go_sync ->
gfs2_log_flush).</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('7fd8d4cb5d328e813e3013979999f8778e5e5a66')">
                                    <div class="issue-number">253</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="7fd8d4cb5d328e813e3013979999f8778e5e5a66">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

ice: Don't process extts if PTP is disabled

The ice_ptp_extts_event() function can race with ice_ptp_release() and
result in a NULL pointer dereference which leads to a kernel panic.

Panic occurs because the ice_ptp_extts_event() function calls
ptp_clock_event() with a NULL pointer. The ice driver has already
released the PTP clock by the time the interrupt for the next external
timestamp event occurs.

To fix this, modify the ice_ptp_extts_event() function to check the
PTP state and bail early if PTP is not ready.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('c3de1ff57ba6ea3b5c079da8b745a5b101b98c7c')">
                                    <div class="issue-number">254</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="c3de1ff57ba6ea3b5c079da8b745a5b101b98c7c">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: ASSERT when failing to find index by plane/stream id

[WHY]
find_disp_cfg_idx_by_plane_id and find_disp_cfg_idx_by_stream_id returns
an array index and they return -1 when not found; however, -1 is not a
valid index number.

[HOW]
When this happens, call ASSERT(), and return a positive number (which is
fewer than callers' array size) instead.

This fixes 4 OVERRUN and 2 NEGATIVE_RETURNS issues reported by Coverity.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('4bf334e3ad744c8f9c6a836b1c6d654c3b4471f4')">
                                    <div class="issue-number">255</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="4bf334e3ad744c8f9c6a836b1c6d654c3b4471f4">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Do not return negative stream id for array

[WHY]
resource_stream_to_stream_idx returns an array index and it return -1
when not found; however, -1 is not a valid array index number.

[HOW]
When this happens, call ASSERT(), and return a zero instead.

This fixes an OVERRUN and an NEGATIVE_RETURNS issues reported by Coverity.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('100f0a3f4d28553c62da38bbdd442d8b3fead4b1')">
                                    <div class="issue-number">256</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="100f0a3f4d28553c62da38bbdd442d8b3fead4b1">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Add NULL pointer check for kzalloc

[Why & How]
Check return pointer of kzalloc before using it.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('4c201b69b6af34c7aac86657f41c7b5e80c295bd')">
                                    <div class="issue-number">257</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="4c201b69b6af34c7aac86657f41c7b5e80c295bd">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amdgpu: fix double free err_addr pointer warnings

In amdgpu_umc_bad_page_polling_timeout, the amdgpu_umc_handle_bad_pages
will be run many times so that double free err_addr in some special case.
So set the err_addr to NULL to avoid the warnings.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('ee3d294667158fea76da842f2f55245a16083465')">
                                    <div class="issue-number">258</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="ee3d294667158fea76da842f2f55245a16083465">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

wifi: rtw89: fw: scan offload prohibit all 6 GHz channel if no 6 GHz sband

We have some policy via BIOS to block uses of 6 GHz. In this case, 6 GHz
sband will be NULL even if it is WiFi 7 chip. So, add NULL handling here
to avoid crash.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('c512fb054f6eb23cdf6926693c7b0ba710d7c52d')">
                                    <div class="issue-number">259</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="c512fb054f6eb23cdf6926693c7b0ba710d7c52d">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

leds: an30259a: Use devm_mutex_init() for mutex initialization

In this driver LEDs are registered using devm_led_classdev_register()
so they are automatically unregistered after module's remove() is done.
led_classdev_unregister() calls module's led_set_brightness() to turn off
the LEDs and that callback uses mutex which was destroyed already
in module's remove() so use devm API instead.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('14653ea6a955fdd4f5d73fbb5a3570dcd123bb48')">
                                    <div class="issue-number">260</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="14653ea6a955fdd4f5d73fbb5a3570dcd123bb48">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

leds: mlxreg: Use devm_mutex_init() for mutex initialization

In this driver LEDs are registered using devm_led_classdev_register()
so they are automatically unregistered after module's remove() is done.
led_classdev_unregister() calls module's led_set_brightness() to turn off
the LEDs and that callback uses mutex which was destroyed already
in module's remove() so use devm API instead.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('920d758868608af889a7a49fc4b27bc12838a5a2')">
                                    <div class="issue-number">261</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="920d758868608af889a7a49fc4b27bc12838a5a2">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

virtio-pci: Check if is_avq is NULL

[bug]
In the virtio_pci_common.c function vp_del_vqs, vp_dev->is_avq is involved
to determine whether it is admin virtqueue, but this function vp_dev->is_avq
 may be empty. For installations, virtio_pci_legacy does not assign a value
 to vp_dev->is_avq.

[fix]
Check whether it is vp_dev->is_avq before use.

[test]
Test with virsh Attach device
Before this patch, the following command would crash the guest system

After applying the patch, everything seems to be working fine.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('6fd6e887f976a08be1a2718434d12e4750534006')">
                                    <div class="issue-number">262</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="6fd6e887f976a08be1a2718434d12e4750534006">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

vhost_task: Handle SIGKILL by flushing work and exiting

Instead of lingering until the device is closed, this has us handle
SIGKILL by:

1. marking the worker as killed so we no longer try to use it with
   new virtqueues and new flush operations.
2. setting the virtqueue to worker mapping so no new works are queued.
3. running all the exiting works.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('29812c31b65ee5f1f77f590c8dca2c7bbdbd6376')">
                                    <div class="issue-number">263</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="29812c31b65ee5f1f77f590c8dca2c7bbdbd6376">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

ice: Fix improper extts handling

Extts events are disabled and enabled by the application ts2phc.
However, in case where the driver is removed when the application is
running, a specific extts event remains enabled and can cause a kernel
crash.
As a side effect, when the driver is reloaded and application is started
again, remaining extts event for the channel from a previous run will
keep firing and the message "extts on unexpected channel" might be
printed to the user.

To avoid that, extts events shall be disabled when PTP is released.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('ba4de11425b019e42100de6f8ee28ffb0e41ae8d')">
                                    <div class="issue-number">264</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="ba4de11425b019e42100de6f8ee28ffb0e41ae8d">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

thermal/drivers/mediatek/lvts_thermal: Check NULL ptr on lvts_data

Verify that lvts_data is not NULL before using it.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('bdef46348cd2dd98c625ad890dd9db54febdc147')">
                                    <div class="issue-number">265</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="bdef46348cd2dd98c625ad890dd9db54febdc147">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

bpf: mark bpf_dummy_struct_ops.test_1 parameter as nullable

Test case dummy_st_ops/dummy_init_ret_value passes NULL as the first
parameter of the test_1() function. Mark this parameter as nullable to
make verifier aware of such possibility.
Otherwise, NULL check in the test_1() code:

      SEC("struct_ops/test_1")
      int BPF_PROG(test_1, struct bpf_dummy_ops_state *state)
      {
            if (!state)
                    return ...;

            ... access state ...
      }

Might be removed by verifier, thus triggering NULL pointer dereference
under certain conditions.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('03ca92701793b7bb7739b51d935f41f1766aff86')">
                                    <div class="issue-number">266</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="03ca92701793b7bb7739b51d935f41f1766aff86">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

s390/pkey: Wipe copies of clear-key structures on failure

Wipe all sensitive data from stack for all IOCTLs, which convert a
clear-key into a protected- or secure-key.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('a0d2bc5ff82e02b6cdbfd12420a932035efb81d9')">
                                    <div class="issue-number">267</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="a0d2bc5ff82e02b6cdbfd12420a932035efb81d9">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

s390/pkey: Use kfree_sensitive() to fix Coccinelle warnings

Replace memzero_explicit() and kfree() with kfree_sensitive() to fix
warnings reported by Coccinelle:

WARNING opportunity for kfree_sensitive/kvfree_sensitive (line 1506)
WARNING opportunity for kfree_sensitive/kvfree_sensitive (line 1643)
WARNING opportunity for kfree_sensitive/kvfree_sensitive (line 1770)</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('a3d7af0e82386b9c0200165ccf31e13ab0d598d3')">
                                    <div class="issue-number">268</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="a3d7af0e82386b9c0200165ccf31e13ab0d598d3">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Fix overlapping copy within dml_core_mode_programming

[WHY]
&mode_lib->mp.Watermark and &locals->Watermark are
the same address. memcpy may lead to unexpected behavior.

[HOW]
memmove should be used.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('9f18ddc4f08ef7923dead3737876eda96296dbd6')">
                                    <div class="issue-number">269</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="9f18ddc4f08ef7923dead3737876eda96296dbd6">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

bpf: Fail bpf_timer_cancel when callback is being cancelled

Given a schedule:

timer1 cb			timer2 cb

bpf_timer_cancel(timer2);	bpf_timer_cancel(timer1);

Both bpf_timer_cancel calls would wait for the other callback to finish
executing, introducing a lockup.

Add an atomic_t count named 'cancelling' in bpf_hrtimer. This keeps
track of all in-flight cancellation requests for a given BPF timer.
Whenever cancelling a BPF timer, we must check if we have outstanding
cancellation requests, and if so, we must fail the operation with an
error (-EDEADLK) since cancellation is synchronous and waits for the
callback to finish executing. This implies that we can enter a deadlock
situation involving two or more timer callbacks executing in parallel
and attempting to cancel one another.

Note that we avoid incrementing the cancelling counter for the target
timer (the one being cancelled) if bpf_timer_cancel is not invoked from
a callback, to avoid spurious errors. The whole point of detecting
cur->cancelling and returning -EDEADLK is to not enter a busy wait loop
(which may or may not lead to a lockup). This does not apply in case the
caller is in a non-callback context, the other side can continue to
cancel as it sees fit without running into errors.

Background on prior attempts:

Earlier versions of this patch used a bool 'cancelling' bit and used the
following pattern under timer->lock to publish cancellation status.

lock(t->lock);
t->cancelling = true;
mb();
if (cur->cancelling)
	return -EDEADLK;
unlock(t->lock);
hrtimer_cancel(t->timer);
t->cancelling = false;

The store outside the critical section could overwrite a parallel
requests t->cancelling assignment to true, to ensure the parallely
executing callback observes its cancellation status.

It would be necessary to clear this cancelling bit once hrtimer_cancel
is done, but lack of serialization introduced races. Another option was
explored where bpf_timer_start would clear the bit when (re)starting the
timer under timer->lock. This would ensure serialized access to the
cancelling bit, but may allow it to be cleared before in-flight
hrtimer_cancel has finished executing, such that lockups can occur
again.

Thus, we choose an atomic counter to keep track of all outstanding
cancellation requests and use it to prevent lockups in case callbacks
attempt to cancel each other while executing in parallel.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('c27e6bb52ba730882b159cc7944e097d97144e70')">
                                    <div class="issue-number">270</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="c27e6bb52ba730882b159cc7944e097d97144e70">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

mm/shmem: disable PMD-sized page cache if needed

For shmem files, it's possible that PMD-sized page cache can't be
supported by xarray.  For example, 512MB page cache on ARM64 when the base
page size is 64KB can't be supported by xarray.  It leads to errors as the
following messages indicate when this sort of xarray entry is split.

WARNING: CPU: 34 PID: 7578 at lib/xarray.c:1025 xas_split_alloc+0xf8/0x128
Modules linked in: binfmt_misc nft_fib_inet nft_fib_ipv4 nft_fib_ipv6   \
nft_fib nft_reject_inet nf_reject_ipv4 nf_reject_ipv6 nft_reject        \
nft_ct nft_chain_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4  \
ip_set rfkill nf_tables nfnetlink vfat fat virtio_balloon drm fuse xfs  \
libcrc32c crct10dif_ce ghash_ce sha2_ce sha256_arm64 sha1_ce virtio_net \
net_failover virtio_console virtio_blk failover dimlib virtio_mmio
CPU: 34 PID: 7578 Comm: test Kdump: loaded Tainted: G W 6.10.0-rc5-gavin+ #9
Hardware name: QEMU KVM Virtual Machine, BIOS edk2-20240524-1.el9 05/24/2024
pstate: 83400005 (Nzcv daif +PAN -UAO +TCO +DIT -SSBS BTYPE=--)
pc : xas_split_alloc+0xf8/0x128
lr : split_huge_page_to_list_to_order+0x1c4/0x720
sp : ffff8000882af5f0
x29: ffff8000882af5f0 x28: ffff8000882af650 x27: ffff8000882af768
x26: 0000000000000cc0 x25: 000000000000000d x24: ffff00010625b858
x23: ffff8000882af650 x22: ffffffdfc0900000 x21: 0000000000000000
x20: 0000000000000000 x19: ffffffdfc0900000 x18: 0000000000000000
x17: 0000000000000000 x16: 0000018000000000 x15: 52f8004000000000
x14: 0000e00000000000 x13: 0000000000002000 x12: 0000000000000020
x11: 52f8000000000000 x10: 52f8e1c0ffff6000 x9 : ffffbeb9619a681c
x8 : 0000000000000003 x7 : 0000000000000000 x6 : ffff00010b02ddb0
x5 : ffffbeb96395e378 x4 : 0000000000000000 x3 : 0000000000000cc0
x2 : 000000000000000d x1 : 000000000000000c x0 : 0000000000000000
Call trace:
 xas_split_alloc+0xf8/0x128
 split_huge_page_to_list_to_order+0x1c4/0x720
 truncate_inode_partial_folio+0xdc/0x160
 shmem_undo_range+0x2bc/0x6a8
 shmem_fallocate+0x134/0x430
 vfs_fallocate+0x124/0x2e8
 ksys_fallocate+0x4c/0xa0
 __arm64_sys_fallocate+0x24/0x38
 invoke_syscall.constprop.0+0x7c/0xd8
 do_el0_svc+0xb4/0xd0
 el0_svc+0x44/0x1d8
 el0t_64_sync_handler+0x134/0x150
 el0t_64_sync+0x17c/0x180

Fix it by disabling PMD-sized page cache when HPAGE_PMD_ORDER is larger
than MAX_PAGECACHE_ORDER.  As Matthew Wilcox pointed, the page cache in a
shmem file isn't represented by a multi-index entry and doesn't have this
limitation when the xarry entry is split until commit 6b24ca4a1a8d ("mm:
Use multi-index entries in the page cache").</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('fe5d7ae05ca2fd4d323fc7959b85b00a5c783ea3')">
                                    <div class="issue-number">271</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="fe5d7ae05ca2fd4d323fc7959b85b00a5c783ea3">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

mm/filemap: make MAX_PAGECACHE_ORDER acceptable to xarray

Patch series "mm/filemap: Limit page cache size to that supported by
xarray", v2.

Currently, xarray can't support arbitrary page cache size.  More details
can be found from the WARN_ON() statement in xas_split_alloc().  In our
test whose code is attached below, we hit the WARN_ON() on ARM64 system
where the base page size is 64KB and huge page size is 512MB.  The issue
was reported long time ago and some discussions on it can be found here
[1].

[1] https://www.spinics.net/lists/linux-xfs/msg75404.html

In order to fix the issue, we need to adjust MAX_PAGECACHE_ORDER to one
supported by xarray and avoid PMD-sized page cache if needed.  The code
changes are suggested by David Hildenbrand.

PATCH[1] adjusts MAX_PAGECACHE_ORDER to that supported by xarray
PATCH[2-3] avoids PMD-sized page cache in the synchronous readahead path
PATCH[4] avoids PMD-sized page cache for shmem files if needed

Test program
============
# cat test.c
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <errno.h>
#include <sys/syscall.h>
#include <sys/mman.h>

#define TEST_XFS_FILENAME	"/tmp/data"
#define TEST_SHMEM_FILENAME	"/dev/shm/data"
#define TEST_MEM_SIZE		0x20000000

int main(int argc, char **argv)
{
	const char *filename;
	int fd = 0;
	void *buf = (void *)-1, *p;
	int pgsize = getpagesize();
	int ret;

	if (pgsize != 0x10000) {
		fprintf(stderr, "64KB base page size is required\n");
		return -EPERM;
	}

	system("echo force > /sys/kernel/mm/transparent_hugepage/shmem_enabled");
	system("rm -fr /tmp/data");
	system("rm -fr /dev/shm/data");
	system("echo 1 > /proc/sys/vm/drop_caches");

	/* Open xfs or shmem file */
	filename = TEST_XFS_FILENAME;
	if (argc > 1 && !strcmp(argv[1], "shmem"))
		filename = TEST_SHMEM_FILENAME;

	fd = open(filename, O_CREAT | O_RDWR | O_TRUNC);
	if (fd < 0) {
		fprintf(stderr, "Unable to open <%s>\n", filename);
		return -EIO;
	}

	/* Extend file size */
	ret = ftruncate(fd, TEST_MEM_SIZE);
	if (ret) {
		fprintf(stderr, "Error %d to ftruncate()\n", ret);
		goto cleanup;
	}

	/* Create VMA */
	buf = mmap(NULL, TEST_MEM_SIZE,
		   PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
	if (buf == (void *)-1) {
		fprintf(stderr, "Unable to mmap <%s>\n", filename);
		goto cleanup;
	}

	fprintf(stdout, "mapped buffer at 0x%p\n", buf);
	ret = madvise(buf, TEST_MEM_SIZE, MADV_HUGEPAGE);
        if (ret) {
		fprintf(stderr, "Unable to madvise(MADV_HUGEPAGE)\n");
		goto cleanup;
	}

	/* Populate VMA */
	ret = madvise(buf, TEST_MEM_SIZE, MADV_POPULATE_WRITE);
	if (ret) {
		fprintf(stderr, "Error %d to madvise(MADV_POPULATE_WRITE)\n", ret);
		goto cleanup;
	}

	/* Punch the file to enforce xarray split */
	ret = fallocate(fd, FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE,
        		TEST_MEM_SIZE - pgsize, pgsize);
	if (ret)
		fprintf(stderr, "Error %d to fallocate()\n", ret);

cleanup:
	if (buf != (void *)-1)
		munmap(buf, TEST_MEM_SIZE);
	if (fd > 0)
		close(fd);

	return 0;
}

# gcc test.c -o test
# cat /proc/1/smaps | grep KernelPageSize | head -n 1
KernelPageSize:       64 kB
# ./test shmem
   :
------------[ cut here ]------------
WARNING: CPU: 17 PID: 5253 at lib/xarray.c:1025 xas_split_alloc+0xf8/0x128
Modules linked in: nft_fib_inet nft_fib_ipv4 nft_fib_ipv6 nft_fib  \
nft_reject_inet nf_reject_ipv4 nf_reject_ipv6 nft_reject nft_ct    \
nft_chain_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4    \
ip_set nf_tables rfkill nfnetlink vfat fat virtio_balloon          \
drm fuse xfs libcrc32c crct10dif_ce ghash_ce sha2_ce sha256_arm64  \
virtio_net sha1_ce net_failover failover virtio_console virtio_blk \
dimlib virtio_mmio
CPU: 17 PID: 5253 Comm: test Kdump: loaded Tainted: G W 6.10.0-rc5-gavin+ #12
Hardware name: QEMU KVM Virtual Machine, BIOS edk2-20240524-1.el9 05/24/2024
pstate: 83400005 (Nzcv daif +PAN -UAO +TC
---truncated---</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('84980845fa0485411a6a0175fdd63bc8f4daac79')">
                                    <div class="issue-number">272</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="84980845fa0485411a6a0175fdd63bc8f4daac79">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

closures: Change BUG_ON() to WARN_ON()

If a BUG_ON() can be hit in the wild, it shouldn't be a BUG_ON()

For reference, this has popped up once in the CI, and we'll need more
info to debug it:

03240 ------------[ cut here ]------------
03240 kernel BUG at lib/closure.c:21!
03240 kernel BUG at lib/closure.c:21!
03240 Internal error: Oops - BUG: 00000000f2000800 [#1] SMP
03240 Modules linked in:
03240 CPU: 15 PID: 40534 Comm: kworker/u80:1 Not tainted 6.10.0-rc4-ktest-ga56da69799bd #25570
03240 Hardware name: linux,dummy-virt (DT)
03240 Workqueue: btree_update btree_interior_update_work
03240 pstate: 00001005 (nzcv daif -PAN -UAO -TCO -DIT +SSBS BTYPE=--)
03240 pc : closure_put+0x224/0x2a0
03240 lr : closure_put+0x24/0x2a0
03240 sp : ffff0000d12071c0
03240 x29: ffff0000d12071c0 x28: dfff800000000000 x27: ffff0000d1207360
03240 x26: 0000000000000040 x25: 0000000000000040 x24: 0000000000000040
03240 x23: ffff0000c1f20180 x22: 0000000000000000 x21: ffff0000c1f20168
03240 x20: 0000000040000000 x19: ffff0000c1f20140 x18: 0000000000000001
03240 x17: 0000000000003aa0 x16: 0000000000003ad0 x15: 1fffe0001c326974
03240 x14: 0000000000000a1e x13: 0000000000000000 x12: 1fffe000183e402d
03240 x11: ffff6000183e402d x10: dfff800000000000 x9 : ffff6000183e402e
03240 x8 : 0000000000000001 x7 : 00009fffe7c1bfd3 x6 : ffff0000c1f2016b
03240 x5 : ffff0000c1f20168 x4 : ffff6000183e402e x3 : ffff800081391954
03240 x2 : 0000000000000001 x1 : 0000000000000000 x0 : 00000000a8000000
03240 Call trace:
03240  closure_put+0x224/0x2a0
03240  bch2_check_for_deadlock+0x910/0x1028
03240  bch2_six_check_for_deadlock+0x1c/0x30
03240  six_lock_slowpath.isra.0+0x29c/0xed0
03240  six_lock_ip_waiter+0xa8/0xf8
03240  __bch2_btree_node_lock_write+0x14c/0x298
03240  bch2_trans_lock_write+0x6d4/0xb10
03240  __bch2_trans_commit+0x135c/0x5520
03240  btree_interior_update_work+0x1248/0x1c10
03240  process_scheduled_works+0x53c/0xd90
03240  worker_thread+0x370/0x8c8
03240  kthread+0x258/0x2e8
03240  ret_from_fork+0x10/0x20
03240 Code: aa1303e0 d63f0020 a94363f7 17ffff8c (d4210000)
03240 ---[ end trace 0000000000000000 ]---
03240 Kernel panic - not syncing: Oops - BUG: Fatal exception
03240 SMP: stopping secondary CPUs
03241 SMP: failed to stop secondary CPUs 13,15
03241 Kernel Offset: disabled
03241 CPU features: 0x00,00000003,80000008,4240500b
03241 Memory Limit: none
03241 ---[ end Kernel panic - not syncing: Oops - BUG: Fatal exception ]---
03246 ========= FAILED TIMEOUT copygc_torture_no_checksum in 7200s</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('9df697e1ed13a3b4c7aac4d6a4d5cd6fbe705413')">
                                    <div class="issue-number">273</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="9df697e1ed13a3b4c7aac4d6a4d5cd6fbe705413">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

spi: microchip-core: ensure TX and RX FIFOs are empty at start of a transfer

While transmitting with rx_len == 0, the RX FIFO is not going to be
emptied in the interrupt handler. A subsequent transfer could then
read crap from the previous transfer out of the RX FIFO into the
start RX buffer. The core provides a register that will empty the RX and
TX FIFOs, so do that before each transfer.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('79c8b44354c281a39a76a2fb4d44d0357ed97451')">
                                    <div class="issue-number">274</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="79c8b44354c281a39a76a2fb4d44d0357ed97451">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

exfat: fix potential deadlock on __exfat_get_dentry_set

When accessing a file with more entries than ES_MAX_ENTRY_NUM, the bh-array
is allocated in __exfat_get_entry_set. The problem is that the bh-array is
allocated with GFP_KERNEL. It does not make sense. In the following cases,
a deadlock for sbi->s_lock between the two processes may occur.

       CPU0                CPU1
       ----                ----
  kswapd
   balance_pgdat
    lock(fs_reclaim)
                      exfat_iterate
                       lock(&sbi->s_lock)
                       exfat_readdir
                        exfat_get_uniname_from_ext_entry
                         exfat_get_dentry_set
                          __exfat_get_dentry_set
                           kmalloc_array
                            ...
                            lock(fs_reclaim)
    ...
    evict
     exfat_evict_inode
      lock(&sbi->s_lock)

To fix this, let's allocate bh-array with GFP_NOFS.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('61e8b6117f76dcd4a926bbaf5fa43365b44d7143')">
                                    <div class="issue-number">275</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="61e8b6117f76dcd4a926bbaf5fa43365b44d7143">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

mm/huge_memory: avoid PMD-size page cache if needed

xarray can't support arbitrary page cache size.  the largest and supported
page cache size is defined as MAX_PAGECACHE_ORDER by commit 099d90642a71
("mm/filemap: make MAX_PAGECACHE_ORDER acceptable to xarray").  However,
it's possible to have 512MB page cache in the huge memory's collapsing
path on ARM64 system whose base page size is 64KB.  512MB page cache is
breaking the limitation and a warning is raised when the xarray entry is
split as shown in the following example.

[root@dhcp-10-26-1-207 ~]# cat /proc/1/smaps | grep KernelPageSize
KernelPageSize:       64 kB
[root@dhcp-10-26-1-207 ~]# cat /tmp/test.c
   :
int main(int argc, char **argv)
{
	const char *filename = TEST_XFS_FILENAME;
	int fd = 0;
	void *buf = (void *)-1, *p;
	int pgsize = getpagesize();
	int ret = 0;

	if (pgsize != 0x10000) {
		fprintf(stdout, "System with 64KB base page size is required!\n");
		return -EPERM;
	}

	system("echo 0 > /sys/devices/virtual/bdi/253:0/read_ahead_kb");
	system("echo 1 > /proc/sys/vm/drop_caches");

	/* Open the xfs file */
	fd = open(filename, O_RDONLY);
	assert(fd > 0);

	/* Create VMA */
	buf = mmap(NULL, TEST_MEM_SIZE, PROT_READ, MAP_SHARED, fd, 0);
	assert(buf != (void *)-1);
	fprintf(stdout, "mapped buffer at 0x%p\n", buf);

	/* Populate VMA */
	ret = madvise(buf, TEST_MEM_SIZE, MADV_NOHUGEPAGE);
	assert(ret == 0);
	ret = madvise(buf, TEST_MEM_SIZE, MADV_POPULATE_READ);
	assert(ret == 0);

	/* Collapse VMA */
	ret = madvise(buf, TEST_MEM_SIZE, MADV_HUGEPAGE);
	assert(ret == 0);
	ret = madvise(buf, TEST_MEM_SIZE, MADV_COLLAPSE);
	if (ret) {
		fprintf(stdout, "Error %d to madvise(MADV_COLLAPSE)\n", errno);
		goto out;
	}

	/* Split xarray entry. Write permission is needed */
	munmap(buf, TEST_MEM_SIZE);
	buf = (void *)-1;
	close(fd);
	fd = open(filename, O_RDWR);
	assert(fd > 0);
	fallocate(fd, FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE,
 		  TEST_MEM_SIZE - pgsize, pgsize);
out:
	if (buf != (void *)-1)
		munmap(buf, TEST_MEM_SIZE);
	if (fd > 0)
		close(fd);

	return ret;
}

[root@dhcp-10-26-1-207 ~]# gcc /tmp/test.c -o /tmp/test
[root@dhcp-10-26-1-207 ~]# /tmp/test
 ------------[ cut here ]------------
 WARNING: CPU: 25 PID: 7560 at lib/xarray.c:1025 xas_split_alloc+0xf8/0x128
 Modules linked in: nft_fib_inet nft_fib_ipv4 nft_fib_ipv6 nft_fib    \
 nft_reject_inet nf_reject_ipv4 nf_reject_ipv6 nft_reject nft_ct      \
 nft_chain_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4      \
 ip_set rfkill nf_tables nfnetlink vfat fat virtio_balloon drm fuse   \
 xfs libcrc32c crct10dif_ce ghash_ce sha2_ce sha256_arm64 virtio_net  \
 sha1_ce net_failover virtio_blk virtio_console failover dimlib virtio_mmio
 CPU: 25 PID: 7560 Comm: test Kdump: loaded Not tainted 6.10.0-rc7-gavin+ #9
 Hardware name: QEMU KVM Virtual Machine, BIOS edk2-20240524-1.el9 05/24/2024
 pstate: 83400005 (Nzcv daif +PAN -UAO +TCO +DIT -SSBS BTYPE=--)
 pc : xas_split_alloc+0xf8/0x128
 lr : split_huge_page_to_list_to_order+0x1c4/0x780
 sp : ffff8000ac32f660
 x29: ffff8000ac32f660 x28: ffff0000e0969eb0 x27: ffff8000ac32f6c0
 x26: 0000000000000c40 x25: ffff0000e0969eb0 x24: 000000000000000d
 x23: ffff8000ac32f6c0 x22: ffffffdfc0700000 x21: 0000000000000000
 x20: 0000000000000000 x19: ffffffdfc0700000 x18: 0000000000000000
 x17: 0000000000000000 x16: ffffd5f3708ffc70 x15: 0000000000000000
 x14: 0000000000000000 x13: 0000000000000000 x12: 0000000000000000
 x11: ffffffffffffffc0 x10: 0000000000000040 x9 : ffffd5f3708e692c
 x8 : 0000000000000003 x7 : 0000000000000000 x6 : ffff0000e0969eb8
 x5 : ffffd5f37289e378 x4 : 0000000000000000 x3 : 0000000000000c40
 x2 : 000000000000000d x1 : 000000000000000c x0 : 0000000000000000
 Call trace:
  xas_split_alloc+0xf8/0x128
  split_huge_page_to_list_to_order+0x1c4/0x780
  truncate_inode_partial_folio+0xdc/0x160
  truncate_inode_pages_range+0x1b4/0x4a8
  truncate_pagecache_range+0x84/0xa
---truncated---</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('c24bddddb73810831c99171ab57d9f440ec782c1')">
                                    <div class="issue-number">276</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="c24bddddb73810831c99171ab57d9f440ec782c1">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

mailbox: mtk-cmdq: Move devm_mbox_controller_register() after devm_pm_runtime_enable()

When mtk-cmdq unbinds, a WARN_ON message with condition
pm_runtime_get_sync() < 0 occurs.

According to the call tracei below:
  cmdq_mbox_shutdown
  mbox_free_channel
  mbox_controller_unregister
  __devm_mbox_controller_unregister
  ...

The root cause can be deduced to be calling pm_runtime_get_sync() after
calling pm_runtime_disable() as observed below:
1. CMDQ driver uses devm_mbox_controller_register() in cmdq_probe()
   to bind the cmdq device to the mbox_controller, so
   devm_mbox_controller_unregister() will automatically unregister
   the device bound to the mailbox controller when the device-managed
   resource is removed. That means devm_mbox_controller_unregister()
   and cmdq_mbox_shoutdown() will be called after cmdq_remove().
2. CMDQ driver also uses devm_pm_runtime_enable() in cmdq_probe() after
   devm_mbox_controller_register(), so that devm_pm_runtime_disable()
   will be called after cmdq_remove(), but before
   devm_mbox_controller_unregister().

To fix this problem, cmdq_probe() needs to move
devm_mbox_controller_register() after devm_pm_runtime_enable() to make
devm_pm_runtime_disable() be called after
devm_mbox_controller_unregister().</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('6432e971997a25f181f5c931aa48246ee2374e9e')">
                                    <div class="issue-number">277</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="6432e971997a25f181f5c931aa48246ee2374e9e">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

kvm: s390: Reject memory region operations for ucontrol VMs

This change rejects the KVM_SET_USER_MEMORY_REGION and
KVM_SET_USER_MEMORY_REGION2 ioctls when called on a ucontrol VM.
This is necessary since ucontrol VMs have kvm->arch.gmap set to 0 and
would thus result in a null pointer dereference further in.
Memory management needs to be performed in userspace and using the
ioctls KVM_S390_UCAS_MAP and KVM_S390_UCAS_UNMAP.

Also improve s390 specific documentation for KVM_SET_USER_MEMORY_REGION
and KVM_SET_USER_MEMORY_REGION2.

[frankja@linux.ibm.com: commit message spelling fix, subject prefix fix]</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('0d8c487aba61235c72627b91bdf69825687ffd0d')">
                                    <div class="issue-number">278</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="0d8c487aba61235c72627b91bdf69825687ffd0d">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

PCI: endpoint: pci-epf-test: Make use of cached 'epc_features' in pci_epf_test_core_init()

Instead of getting the epc_features from pci_epc_get_features() API, use
the cached pci_epf_test::epc_features value to avoid the NULL check. Since
the NULL check is already performed in pci_epf_test_bind(), having one more
check in pci_epf_test_core_init() is redundant and it is not possible to
hit the NULL pointer dereference.

Also with commit a01e7214bef9 ("PCI: endpoint: Remove "core_init_notifier"
flag"), 'epc_features' got dereferenced without the NULL check, leading to
the following false positive Smatch warning:

  drivers/pci/endpoint/functions/pci-epf-test.c:784 pci_epf_test_core_init() error: we previously assumed 'epc_features' could be null (see line 747)

Thus, remove the redundant NULL check and also use the epc_features::
{msix_capable/msi_capable} flags directly to avoid local variables.

[kwilczynski: commit log]</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('5bd9f9b6344dcf25ea678df44286441e37241c92')">
                                    <div class="issue-number">279</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="5bd9f9b6344dcf25ea678df44286441e37241c92">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

media: mediatek: vcodec: Handle invalid decoder vsi

Handle an invalid decoder vsi in vpu_dec_init to ensure the decoder vsi
is valid for future use.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('ec4e8c20e8357011a1e183c3890d1397cc4dbb1a')">
                                    <div class="issue-number">280</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="ec4e8c20e8357011a1e183c3890d1397cc4dbb1a">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

bpf, arm64: Fix trampoline for BPF_TRAMP_F_CALL_ORIG

When BPF_TRAMP_F_CALL_ORIG is set, the trampoline calls
__bpf_tramp_enter() and __bpf_tramp_exit() functions, passing them
the struct bpf_tramp_image *im pointer as an argument in R0.

The trampoline generation code uses emit_addr_mov_i64() to emit
instructions for moving the bpf_tramp_image address into R0, but
emit_addr_mov_i64() assumes the address to be in the vmalloc() space
and uses only 48 bits. Because bpf_tramp_image is allocated using
kzalloc(), its address can use more than 48-bits, in this case the
trampoline will pass an invalid address to __bpf_tramp_enter/exit()
causing a kernel crash.

Fix this by using emit_a64_mov_i64() in place of emit_addr_mov_i64()
as it can work with addresses that are greater than 48-bits.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('10749cf0ab983fd69cf311cd244bcdff421a984c')">
                                    <div class="issue-number">281</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="10749cf0ab983fd69cf311cd244bcdff421a984c">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

soc: qcom: icc-bwmon: Fix refcount imbalance seen during bwmon_remove

The following warning is seen during bwmon_remove due to refcount
imbalance, fix this by releasing the OPPs after use.

Logs:
WARNING: at drivers/opp/core.c:1640 _opp_table_kref_release+0x150/0x158
Hardware name: Qualcomm Technologies, Inc. X1E80100 CRD (DT)
...
Call trace:
_opp_table_kref_release+0x150/0x158
dev_pm_opp_remove_table+0x100/0x1b4
devm_pm_opp_of_table_release+0x10/0x1c
devm_action_release+0x14/0x20
devres_release_all+0xa4/0x104
device_unbind_cleanup+0x18/0x60
device_release_driver_internal+0x1ec/0x228
driver_detach+0x50/0x98
bus_remove_driver+0x6c/0xbc
driver_unregister+0x30/0x60
platform_driver_unregister+0x14/0x20
bwmon_driver_exit+0x18/0x524 [icc_bwmon]
__arm64_sys_delete_module+0x184/0x264
invoke_syscall+0x48/0x118
el0_svc_common.constprop.0+0xc8/0xe8
do_el0_svc+0x20/0x2c
el0_svc+0x34/0xdc
el0t_64_sync_handler+0x13c/0x158
el0t_64_sync+0x190/0x194
--[ end trace 0000000000000000 ]---</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('1c888760a12e85b9827fbe562d7f3dfe9834ad2f')">
                                    <div class="issue-number">282</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="1c888760a12e85b9827fbe562d7f3dfe9834ad2f">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

RDMA/hns: Fix soft lockup under heavy CEQE load

CEQEs are handled in interrupt handler currently. This may cause the
CPU core staying in interrupt context too long and lead to soft lockup
under heavy load.

Handle CEQEs in BH workqueue and set an upper limit for the number of
CEQE handled by a single call of work handler.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('3d18a9c3c7d7008104069ad8db85ca4652eec3ba')">
                                    <div class="issue-number">283</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="3d18a9c3c7d7008104069ad8db85ca4652eec3ba">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Add null check in resource_log_pipe_topology_update

[WHY]
When switching from "Extend" to "Second Display Only" we sometimes
call resource_get_otg_master_for_stream on a stream for the eDP,
which is disconnected. This leads to a null pointer dereference.

[HOW]
Added a null check in dc_resource.c/resource_log_pipe_topology_update.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('118036988e0cc96013dae29d73f293206cc15cac')">
                                    <div class="issue-number">284</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="118036988e0cc96013dae29d73f293206cc15cac">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Fix null pointer deref in dcn20_resource.c

Fixes a hang thats triggered when MPV is run on a DCN401 dGPU:

mpv --hwdec=vaapi --vo=gpu --hwdec-codecs=all

and then enabling fullscreen playback (double click on the video)

The following calltrace will be seen:

[  181.843989] BUG: kernel NULL pointer dereference, address: 0000000000000000
[  181.843997] #PF: supervisor instruction fetch in kernel mode
[  181.844003] #PF: error_code(0x0010) - not-present page
[  181.844009] PGD 0 P4D 0
[  181.844020] Oops: 0010 [#1] PREEMPT SMP NOPTI
[  181.844028] CPU: 6 PID: 1892 Comm: gnome-shell Tainted: G        W  OE      6.5.0-41-generic #41~22.04.2-Ubuntu
[  181.844038] Hardware name: System manufacturer System Product Name/CROSSHAIR VI HERO, BIOS 6302 10/23/2018
[  181.844044] RIP: 0010:0x0
[  181.844079] Code: Unable to access opcode bytes at 0xffffffffffffffd6.
[  181.844084] RSP: 0018:ffffb593c2b8f7b0 EFLAGS: 00010246
[  181.844093] RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000004
[  181.844099] RDX: ffffb593c2b8f804 RSI: ffffb593c2b8f7e0 RDI: ffff9e3c8e758400
[  181.844105] RBP: ffffb593c2b8f7b8 R08: ffffb593c2b8f9c8 R09: ffffb593c2b8f96c
[  181.844110] R10: 0000000000000000 R11: 0000000000000000 R12: ffffb593c2b8f9c8
[  181.844115] R13: 0000000000000001 R14: ffff9e3c88000000 R15: 0000000000000005
[  181.844121] FS:  00007c6e323bb5c0(0000) GS:ffff9e3f85f80000(0000) knlGS:0000000000000000
[  181.844128] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[  181.844134] CR2: ffffffffffffffd6 CR3: 0000000140fbe000 CR4: 00000000003506e0
[  181.844141] Call Trace:
[  181.844146]  <TASK>
[  181.844153]  ? show_regs+0x6d/0x80
[  181.844167]  ? __die+0x24/0x80
[  181.844179]  ? page_fault_oops+0x99/0x1b0
[  181.844192]  ? do_user_addr_fault+0x31d/0x6b0
[  181.844204]  ? exc_page_fault+0x83/0x1b0
[  181.844216]  ? asm_exc_page_fault+0x27/0x30
[  181.844237]  dcn20_get_dcc_compression_cap+0x23/0x30 [amdgpu]
[  181.845115]  amdgpu_dm_plane_validate_dcc.constprop.0+0xe5/0x180 [amdgpu]
[  181.845985]  amdgpu_dm_plane_fill_plane_buffer_attributes+0x300/0x580 [amdgpu]
[  181.846848]  fill_dc_plane_info_and_addr+0x258/0x350 [amdgpu]
[  181.847734]  fill_dc_plane_attributes+0x162/0x350 [amdgpu]
[  181.848748]  dm_update_plane_state.constprop.0+0x4e3/0x6b0 [amdgpu]
[  181.849791]  ? dm_update_plane_state.constprop.0+0x4e3/0x6b0 [amdgpu]
[  181.850840]  amdgpu_dm_atomic_check+0xdfe/0x1760 [amdgpu]</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('f4fbbe63ff54d111d70f8f533c3b4e0c123151f2')">
                                    <div class="issue-number">285</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="f4fbbe63ff54d111d70f8f533c3b4e0c123151f2">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Fix NULL pointer dereference for DTN log in DCN401

When users run the command:

cat /sys/kernel/debug/dri/0/amdgpu_dm_dtn_log

The following NULL pointer dereference happens:

[  +0.000003] BUG: kernel NULL pointer dereference, address: NULL
[  +0.000005] #PF: supervisor instruction fetch in kernel mode
[  +0.000002] #PF: error_code(0x0010) - not-present page
[  +0.000002] PGD 0 P4D 0
[  +0.000004] Oops: 0010 [#1] PREEMPT SMP NOPTI
[  +0.000003] RIP: 0010:0x0
[  +0.000008] Code: Unable to access opcode bytes at 0xffffffffffffffd6.
[...]
[  +0.000002] PKRU: 55555554
[  +0.000002] Call Trace:
[  +0.000002]  <TASK>
[  +0.000003]  ? show_regs+0x65/0x70
[  +0.000006]  ? __die+0x24/0x70
[  +0.000004]  ? page_fault_oops+0x160/0x470
[  +0.000006]  ? do_user_addr_fault+0x2b5/0x690
[  +0.000003]  ? prb_read_valid+0x1c/0x30
[  +0.000005]  ? exc_page_fault+0x8c/0x1a0
[  +0.000005]  ? asm_exc_page_fault+0x27/0x30
[  +0.000012]  dcn10_log_color_state+0xf9/0x510 [amdgpu]
[  +0.000306]  ? srso_alias_return_thunk+0x5/0xfbef5
[  +0.000003]  ? vsnprintf+0x2fb/0x600
[  +0.000009]  dcn10_log_hw_state+0xfd0/0xfe0 [amdgpu]
[  +0.000218]  ? __mod_memcg_lruvec_state+0xe8/0x170
[  +0.000008]  ? srso_alias_return_thunk+0x5/0xfbef5
[  +0.000002]  ? debug_smp_processor_id+0x17/0x20
[  +0.000003]  ? srso_alias_return_thunk+0x5/0xfbef5
[  +0.000002]  ? srso_alias_return_thunk+0x5/0xfbef5
[  +0.000002]  ? set_ptes.isra.0+0x2b/0x90
[  +0.000004]  ? srso_alias_return_thunk+0x5/0xfbef5
[  +0.000002]  ? _raw_spin_unlock+0x19/0x40
[  +0.000004]  ? srso_alias_return_thunk+0x5/0xfbef5
[  +0.000002]  ? do_anonymous_page+0x337/0x700
[  +0.000004]  dtn_log_read+0x82/0x120 [amdgpu]
[  +0.000207]  full_proxy_read+0x66/0x90
[  +0.000007]  vfs_read+0xb0/0x340
[  +0.000005]  ? __count_memcg_events+0x79/0xe0
[  +0.000002]  ? srso_alias_return_thunk+0x5/0xfbef5
[  +0.000003]  ? count_memcg_events.constprop.0+0x1e/0x40
[  +0.000003]  ? handle_mm_fault+0xb2/0x370
[  +0.000003]  ksys_read+0x6b/0xf0
[  +0.000004]  __x64_sys_read+0x19/0x20
[  +0.000003]  do_syscall_64+0x60/0x130
[  +0.000004]  entry_SYSCALL_64_after_hwframe+0x6e/0x76
[  +0.000003] RIP: 0033:0x7fdf32f147e2
[...]

This error happens when the color log tries to read the gamut remap
information from DCN401 which is not initialized in the dcn401_dpp_funcs
which leads to a null pointer dereference. This commit addresses this
issue by adding a proper guard to access the gamut_remap callback in
case the specific ASIC did not implement this function.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('2be9b8b1ccc257d2d3954122df22ebbfb607a9fb')">
                                    <div class="issue-number">286</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="2be9b8b1ccc257d2d3954122df22ebbfb607a9fb">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/admgpu: fix dereferencing null pointer context

When user space sets an invalid ta type, the pointer context will be empty.
So it need to check the pointer context before using it</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('57627e64c11d9bc3a13c327de31f7585ea42b8b5')">
                                    <div class="issue-number">287</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="57627e64c11d9bc3a13c327de31f7585ea42b8b5">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

nvme: apple: fix device reference counting

Drivers must call nvme_uninit_ctrl after a successful nvme_init_ctrl.
Split the allocation side out to make the error handling boundary easier
to navigate. The apple driver had been doing this wrong, leaking the
controller device memory on a tagset failure.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('110972274795d1083f4c5ab133da01aee1cf5bc7')">
                                    <div class="issue-number">288</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="110972274795d1083f4c5ab133da01aee1cf5bc7">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

serial: sc16is7xx: fix invalid FIFO access with special register set

When enabling access to the special register set, Receiver time-out and
RHR interrupts can happen. In this case, the IRQ handler will try to read
from the FIFO thru the RHR register at address 0x00, but address 0x00 is
mapped to DLL register, resulting in erroneous FIFO reading.

Call graph example:
    sc16is7xx_startup(): entry
    sc16is7xx_ms_proc(): entry
    sc16is7xx_set_termios(): entry
    sc16is7xx_set_baud(): DLH/DLL = $009C --> access special register set
    sc16is7xx_port_irq() entry            --> IIR is 0x0C
    sc16is7xx_handle_rx() entry
    sc16is7xx_fifo_read(): --> unable to access FIFO (RHR) because it is
                               mapped to DLL (LCR=LCR_CONF_MODE_A)
    sc16is7xx_set_baud(): exit --> Restore access to general register set

Fix the problem by claiming the efr_lock mutex when accessing the Special
register set.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('d90e673ac7c62afa5fdb8e50bf85291c25ab4f79')">
                                    <div class="issue-number">289</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="d90e673ac7c62afa5fdb8e50bf85291c25ab4f79">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Don't refer to dc_sink in is_dsc_need_re_compute

[Why]
When unplug one of monitors connected after mst hub, encounter null pointer dereference.

It's due to dc_sink get released immediately in early_unregister() or detect_ctx(). When
commit new state which directly referring to info stored in dc_sink will cause null pointer
dereference.

[how]
Remove redundant checking condition. Relevant condition should already be covered by checking
if dsc_aux is null or not. Also reset dsc_aux to NULL when the connector is disconnected.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('d283d379be6fac54c665ee6d7139f6ee16b003cd')">
                                    <div class="issue-number">290</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="d283d379be6fac54c665ee6d7139f6ee16b003cd">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

xen: privcmd: Switch from mutex to spinlock for irqfds

irqfd_wakeup() gets EPOLLHUP, when it is called by
eventfd_release() by way of wake_up_poll(&ctx->wqh, EPOLLHUP), which
gets called under spin_lock_irqsave(). We can't use a mutex here as it
will lead to a deadlock.

Fix it by switching over to a spin lock.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('6e7b8c9136527d468b239228abeedd8ee75c6e17')">
                                    <div class="issue-number">291</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="6e7b8c9136527d468b239228abeedd8ee75c6e17">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amdgpu: Forward soft recovery errors to userspace

As we discussed before[1], soft recovery should be
forwarded to userspace, or we can get into a really
bad state where apps will keep submitting hanging
command buffers cascading us to a hard reset.

1: https://lore.kernel.org/all/bf23d5ed-9a6b-43e7-84ee-8cbfd0d60f18@froggi.es/
(cherry picked from commit 434967aadbbbe3ad9103cc29e9a327de20fdba01)</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('c68ce3db5d2eb65c7c76587510b6b7fe189cd9bb')">
                                    <div class="issue-number">292</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="c68ce3db5d2eb65c7c76587510b6b7fe189cd9bb">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

Bluetooth: btnxpuart: Shutdown timer and prevent rearming when driver unloading

When unload the btnxpuart driver, its associated timer will be deleted.
If the timer happens to be modified at this moment, it leads to the
kernel call this timer even after the driver unloaded, resulting in
kernel panic.
Use timer_shutdown_sync() instead of del_timer_sync() to prevent rearming.

panic log:
  Internal error: Oops: 0000000086000007 [#1] PREEMPT SMP
  Modules linked in: algif_hash algif_skcipher af_alg moal(O) mlan(O) crct10dif_ce polyval_ce polyval_generic   snd_soc_imx_card snd_soc_fsl_asoc_card snd_soc_imx_audmux mxc_jpeg_encdec v4l2_jpeg snd_soc_wm8962 snd_soc_fsl_micfil   snd_soc_fsl_sai flexcan snd_soc_fsl_utils ap130x rpmsg_ctrl imx_pcm_dma can_dev rpmsg_char pwm_fan fuse [last unloaded:   btnxpuart]
  CPU: 5 PID: 723 Comm: memtester Tainted: G           O       6.6.23-lts-next-06207-g4aef2658ac28 #1
  Hardware name: NXP i.MX95 19X19 board (DT)
  pstate: 20400009 (nzCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)
  pc : 0xffff80007a2cf464
  lr : call_timer_fn.isra.0+0x24/0x80
...
  Call trace:
   0xffff80007a2cf464
   __run_timers+0x234/0x280
   run_timer_softirq+0x20/0x40
   __do_softirq+0x100/0x26c
   ____do_softirq+0x10/0x1c
   call_on_irq_stack+0x24/0x4c
   do_softirq_own_stack+0x1c/0x2c
   irq_exit_rcu+0xc0/0xdc
   el0_interrupt+0x54/0xd8
   __el0_irq_handler_common+0x18/0x24
   el0t_64_irq_handler+0x10/0x1c
   el0t_64_irq+0x190/0x194
  Code: ???????? ???????? ???????? ???????? (????????)
  ---[ end trace 0000000000000000 ]---
  Kernel panic - not syncing: Oops: Fatal exception in interrupt
  SMP: stopping secondary CPUs
  Kernel Offset: disabled
  CPU features: 0x0,c0000000,40028143,1000721b
  Memory Limit: none
  ---[ end Kernel panic - not syncing: Oops: Fatal exception in interrupt ]---</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('9287b880121ef60ddf6fd7995972b3d6dd1eda67')">
                                    <div class="issue-number">293</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="9287b880121ef60ddf6fd7995972b3d6dd1eda67">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

btrfs: do not BUG_ON() when freeing tree block after error

When freeing a tree block, at btrfs_free_tree_block(), if we fail to
create a delayed reference we don't deal with the error and just do a
BUG_ON(). The error most likely to happen is -ENOMEM, and we have a
comment mentioning that only -ENOMEM can happen, but that is not true,
because in case qgroups are enabled any error returned from
btrfs_qgroup_trace_extent_post() (can be -EUCLEAN or anything returned
from btrfs_search_slot() for example) can be propagated back to
btrfs_free_tree_block().

So stop doing a BUG_ON() and return the error to the callers and make
them abort the transaction to prevent leaking space. Syzbot was
triggering this, likely due to memory allocation failure injection.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('b75e35c7d0814ac65f9e2d6096a040b699c17f3f')">
                                    <div class="issue-number">294</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="b75e35c7d0814ac65f9e2d6096a040b699c17f3f">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

btrfs: do not clear page dirty inside extent_write_locked_range()

[BUG]
For subpage + zoned case, the following workload can lead to rsv data
leak at unmount time:

  # mkfs.btrfs -f -s 4k $dev
  # mount $dev $mnt
  # fsstress -w -n 8 -d $mnt -s 1709539240
  0/0: fiemap - no filename
  0/1: copyrange read - no filename
  0/2: write - no filename
  0/3: rename - no source filename
  0/4: creat f0 x:0 0 0
  0/4: creat add id=0,parent=-1
  0/5: writev f0[259 1 0 0 0 0] [778052,113,965] 0
  0/6: ioctl(FIEMAP) f0[259 1 0 0 224 887097] [1294220,2291618343991484791,0x10000] -1
  0/7: dwrite - xfsctl(XFS_IOC_DIOINFO) f0[259 1 0 0 224 887097] return 25, fallback to stat()
  0/7: dwrite f0[259 1 0 0 224 887097] [696320,102400] 0
  # umount $mnt

The dmesg includes the following rsv leak detection warning (all call
trace skipped):

  ------------[ cut here ]------------
  WARNING: CPU: 2 PID: 4528 at fs/btrfs/inode.c:8653 btrfs_destroy_inode+0x1e0/0x200 [btrfs]
  ---[ end trace 0000000000000000 ]---
  ------------[ cut here ]------------
  WARNING: CPU: 2 PID: 4528 at fs/btrfs/inode.c:8654 btrfs_destroy_inode+0x1a8/0x200 [btrfs]
  ---[ end trace 0000000000000000 ]---
  ------------[ cut here ]------------
  WARNING: CPU: 2 PID: 4528 at fs/btrfs/inode.c:8660 btrfs_destroy_inode+0x1a0/0x200 [btrfs]
  ---[ end trace 0000000000000000 ]---
  BTRFS info (device sda): last unmount of filesystem 1b4abba9-de34-4f07-9e7f-157cf12a18d6
  ------------[ cut here ]------------
  WARNING: CPU: 3 PID: 4528 at fs/btrfs/block-group.c:4434 btrfs_free_block_groups+0x338/0x500 [btrfs]
  ---[ end trace 0000000000000000 ]---
  BTRFS info (device sda): space_info DATA has 268218368 free, is not full
  BTRFS info (device sda): space_info total=268435456, used=204800, pinned=0, reserved=0, may_use=12288, readonly=0 zone_unusable=0
  BTRFS info (device sda): global_block_rsv: size 0 reserved 0
  BTRFS info (device sda): trans_block_rsv: size 0 reserved 0
  BTRFS info (device sda): chunk_block_rsv: size 0 reserved 0
  BTRFS info (device sda): delayed_block_rsv: size 0 reserved 0
  BTRFS info (device sda): delayed_refs_rsv: size 0 reserved 0
  ------------[ cut here ]------------
  WARNING: CPU: 3 PID: 4528 at fs/btrfs/block-group.c:4434 btrfs_free_block_groups+0x338/0x500 [btrfs]
  ---[ end trace 0000000000000000 ]---
  BTRFS info (device sda): space_info METADATA has 267796480 free, is not full
  BTRFS info (device sda): space_info total=268435456, used=131072, pinned=0, reserved=0, may_use=262144, readonly=0 zone_unusable=245760
  BTRFS info (device sda): global_block_rsv: size 0 reserved 0
  BTRFS info (device sda): trans_block_rsv: size 0 reserved 0
  BTRFS info (device sda): chunk_block_rsv: size 0 reserved 0
  BTRFS info (device sda): delayed_block_rsv: size 0 reserved 0
  BTRFS info (device sda): delayed_refs_rsv: size 0 reserved 0

Above $dev is a tcmu-runner emulated zoned HDD, which has a max zone
append size of 64K, and the system has 64K page size.

[CAUSE]
I have added several trace_printk() to show the events (header skipped):

  > btrfs_dirty_pages: r/i=5/259 dirty start=774144 len=114688
  > btrfs_dirty_pages: r/i=5/259 dirty part of page=720896 off_in_page=53248 len_in_page=12288
  > btrfs_dirty_pages: r/i=5/259 dirty part of page=786432 off_in_page=0 len_in_page=65536
  > btrfs_dirty_pages: r/i=5/259 dirty part of page=851968 off_in_page=0 len_in_page=36864

The above lines show our buffered write has dirtied 3 pages of inode
259 of root 5:

  704K             768K              832K              896K
  I           |////I/////////////////I///////////|     I
              756K                               868K

  |///| is the dirtied range using subpage bitmaps. and 'I' is the page
  boundary.

  Meanwhile all three pages (704K, 768K, 832K) have their PageDirty
  flag set.

  > btrfs_direct_write: r/i=5/259 start dio filepos=696320 len=102400

Then direct IO writ
---truncated---</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('24263550ebe6ac0f54551f1c705afdeabe982859')">
                                    <div class="issue-number">295</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="24263550ebe6ac0f54551f1c705afdeabe982859">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/msm/dpu: move dpu_encoder's connector assignment to atomic_enable()

For cases where the crtc's connectors_changed was set without enable/active
getting toggled , there is an atomic_enable() call followed by an
atomic_disable() but without an atomic_mode_set().

This results in a NULL ptr access for the dpu_encoder_get_drm_fmt() call in
the atomic_enable() as the dpu_encoder's connector was cleared in the
atomic_disable() but not re-assigned as there was no atomic_mode_set() call.

Fix the NULL ptr access by moving the assignment for atomic_enable() and also
use drm_atomic_get_new_connector_for_encoder() to get the connector from
the atomic_state.

Patchwork: https://patchwork.freedesktop.org/patch/606729/</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('586f92f9d482bf692194366252e3f635ecdbaa37')">
                                    <div class="issue-number">296</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="586f92f9d482bf692194366252e3f635ecdbaa37">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

bonding: change ipsec_lock from spin lock to mutex

In the cited commit, bond->ipsec_lock is added to protect ipsec_list,
hence xdo_dev_state_add and xdo_dev_state_delete are called inside
this lock. As ipsec_lock is a spin lock and such xfrmdev ops may sleep,
"scheduling while atomic" will be triggered when changing bond's
active slave.

[  101.055189] BUG: scheduling while atomic: bash/902/0x00000200
[  101.055726] Modules linked in:
[  101.058211] CPU: 3 PID: 902 Comm: bash Not tainted 6.9.0-rc4+ #1
[  101.058760] Hardware name:
[  101.059434] Call Trace:
[  101.059436]  <TASK>
[  101.060873]  dump_stack_lvl+0x51/0x60
[  101.061275]  __schedule_bug+0x4e/0x60
[  101.061682]  __schedule+0x612/0x7c0
[  101.062078]  ? __mod_timer+0x25c/0x370
[  101.062486]  schedule+0x25/0xd0
[  101.062845]  schedule_timeout+0x77/0xf0
[  101.063265]  ? asm_common_interrupt+0x22/0x40
[  101.063724]  ? __bpf_trace_itimer_state+0x10/0x10
[  101.064215]  __wait_for_common+0x87/0x190
[  101.064648]  ? usleep_range_state+0x90/0x90
[  101.065091]  cmd_exec+0x437/0xb20 [mlx5_core]
[  101.065569]  mlx5_cmd_do+0x1e/0x40 [mlx5_core]
[  101.066051]  mlx5_cmd_exec+0x18/0x30 [mlx5_core]
[  101.066552]  mlx5_crypto_create_dek_key+0xea/0x120 [mlx5_core]
[  101.067163]  ? bonding_sysfs_store_option+0x4d/0x80 [bonding]
[  101.067738]  ? kmalloc_trace+0x4d/0x350
[  101.068156]  mlx5_ipsec_create_sa_ctx+0x33/0x100 [mlx5_core]
[  101.068747]  mlx5e_xfrm_add_state+0x47b/0xaa0 [mlx5_core]
[  101.069312]  bond_change_active_slave+0x392/0x900 [bonding]
[  101.069868]  bond_option_active_slave_set+0x1c2/0x240 [bonding]
[  101.070454]  __bond_opt_set+0xa6/0x430 [bonding]
[  101.070935]  __bond_opt_set_notify+0x2f/0x90 [bonding]
[  101.071453]  bond_opt_tryset_rtnl+0x72/0xb0 [bonding]
[  101.071965]  bonding_sysfs_store_option+0x4d/0x80 [bonding]
[  101.072567]  kernfs_fop_write_iter+0x10c/0x1a0
[  101.073033]  vfs_write+0x2d8/0x400
[  101.073416]  ? alloc_fd+0x48/0x180
[  101.073798]  ksys_write+0x5f/0xe0
[  101.074175]  do_syscall_64+0x52/0x110
[  101.074576]  entry_SYSCALL_64_after_hwframe+0x4b/0x53

As bond_ipsec_add_sa_all and bond_ipsec_del_sa_all are only called
from bond_change_active_slave, which requires holding the RTNL lock.
And bond_ipsec_add_sa and bond_ipsec_del_sa are xfrm state
xdo_dev_state_add and xdo_dev_state_delete APIs, which are in user
context. So ipsec_lock doesn't have to be spin lock, change it to
mutex, and thus the above issue can be resolved.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('892d26a15132201c26aecb77a245898101c35f83')">
                                    <div class="issue-number">297</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="892d26a15132201c26aecb77a245898101c35f83">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

pktgen: use cpus_read_lock() in pg_net_init()

I have seen the WARN_ON(smp_processor_id() != cpu) firing
in pktgen_thread_worker() during tests.

We must use cpus_read_lock()/cpus_read_unlock()
around the for_each_online_cpu(cpu) loop.

While we are at it use WARN_ON_ONCE() to avoid a possible syslog flood.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('834621ceb1c8c414b2d0d3f805f2380c85dc8f98')">
                                    <div class="issue-number">298</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="834621ceb1c8c414b2d0d3f805f2380c85dc8f98">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

video/aperture: optionally match the device in sysfb_disable()

In aperture_remove_conflicting_pci_devices(), we currently only
call sysfb_disable() on vga class devices.  This leads to the
following problem when the pimary device is not VGA compatible:

1. A PCI device with a non-VGA class is the boot display
2. That device is probed first and it is not a VGA device so
   sysfb_disable() is not called, but the device resources
   are freed by aperture_detach_platform_device()
3. Non-primary GPU has a VGA class and it ends up calling sysfb_disable()
4. NULL pointer dereference via sysfb_disable() since the resources
   have already been freed by aperture_detach_platform_device() when
   it was called by the other device.

Fix this by passing a device pointer to sysfb_disable() and checking
the device to determine if we should execute it or not.

v2: Fix build when CONFIG_SCREEN_INFO is not set
v3: Move device check into the mutex
    Drop primary variable in aperture_remove_conflicting_pci_devices()
    Drop __init on pci sysfb_pci_dev_is_enabled()</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('28db4f627e1f3acf388fed1133aa85ea7628c702')">
                                    <div class="issue-number">299</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="28db4f627e1f3acf388fed1133aa85ea7628c702">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Add otg_master NULL check within resource_log_pipe_topology_update

[Why]
Coverity reports NULL_RETURN warning.

[How]
Add otg_master NULL check.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('9c02ce0ab8f17d0e090f02c2245fcc8fcd849d57')">
                                    <div class="issue-number">300</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="9c02ce0ab8f17d0e090f02c2245fcc8fcd849d57">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Check index for aux_rd_interval before using

aux_rd_interval has size of 7 and should be checked.

This fixes 3 OVERRUN and 1 INTEGER_OVERFLOW issues reported by Coverity.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('264c29ec9087d8e7a8e761755de76b753d3936c4')">
                                    <div class="issue-number">301</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="264c29ec9087d8e7a8e761755de76b753d3936c4">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Fix incorrect size calculation for loop

[WHY]
fe_clk_en has size of 5 but sizeof(fe_clk_en) has byte size 20 which is
lager than the array size.

[HOW]
Divide byte size 20 by its element size.

This fixes 2 OVERRUN issues reported by Coverity.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('52e6e5b87ea29c0d937632a1ef789e592c89b668')">
                                    <div class="issue-number">302</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="52e6e5b87ea29c0d937632a1ef789e592c89b668">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Ensure array index tg_inst won't be -1

[WHY & HOW]
tg_inst will be a negative if timing_generator_count equals 0, which
should be checked before used.

This fixes 2 OVERRUN issues reported by Coverity.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('f2fdd674cb03349da707ae9aa56ea18695fcae51')">
                                    <div class="issue-number">303</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="f2fdd674cb03349da707ae9aa56ea18695fcae51">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

btrfs: fix qgroup reserve leaks in cow_file_range

In the buffered write path, the dirty page owns the qgroup reserve until
it creates an ordered_extent.

Therefore, any errors that occur before the ordered_extent is created
must free that reservation, or else the space is leaked. The fstest
generic/475 exercises various IO error paths, and is able to trigger
errors in cow_file_range where we fail to get to allocating the ordered
extent. Note that because we *do* clear delalloc, we are likely to
remove the inode from the delalloc list, so the inodes/pages to not have
invalidate/launder called on them in the commit abort path.

This results in failures at the unmount stage of the test that look like:

  BTRFS: error (device dm-8 state EA) in cleanup_transaction:2018: errno=-5 IO failure
  BTRFS: error (device dm-8 state EA) in btrfs_replace_file_extents:2416: errno=-5 IO failure
  BTRFS warning (device dm-8 state EA): qgroup 0/5 has unreleased space, type 0 rsv 28672
  ------------[ cut here ]------------
  WARNING: CPU: 3 PID: 22588 at fs/btrfs/disk-io.c:4333 close_ctree+0x222/0x4d0 [btrfs]
  Modules linked in: btrfs blake2b_generic libcrc32c xor zstd_compress raid6_pq
  CPU: 3 PID: 22588 Comm: umount Kdump: loaded Tainted: G W          6.10.0-rc7-gab56fde445b8 #21
  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Arch Linux 1.16.3-1-1 04/01/2014
  RIP: 0010:close_ctree+0x222/0x4d0 [btrfs]
  RSP: 0018:ffffb4465283be00 EFLAGS: 00010202
  RAX: 0000000000000001 RBX: ffffa1a1818e1000 RCX: 0000000000000001
  RDX: 0000000000000000 RSI: ffffb4465283bbe0 RDI: ffffa1a19374fcb8
  RBP: ffffa1a1818e13c0 R08: 0000000100028b16 R09: 0000000000000000
  R10: 0000000000000003 R11: 0000000000000003 R12: ffffa1a18ad7972c
  R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000
  FS:  00007f9168312b80(0000) GS:ffffa1a4afcc0000(0000) knlGS:0000000000000000
  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
  CR2: 00007f91683c9140 CR3: 000000010acaa000 CR4: 00000000000006f0
  Call Trace:
   <TASK>
   ? close_ctree+0x222/0x4d0 [btrfs]
   ? __warn.cold+0x8e/0xea
   ? close_ctree+0x222/0x4d0 [btrfs]
   ? report_bug+0xff/0x140
   ? handle_bug+0x3b/0x70
   ? exc_invalid_op+0x17/0x70
   ? asm_exc_invalid_op+0x1a/0x20
   ? close_ctree+0x222/0x4d0 [btrfs]
   generic_shutdown_super+0x70/0x160
   kill_anon_super+0x11/0x40
   btrfs_kill_super+0x11/0x20 [btrfs]
   deactivate_locked_super+0x2e/0xa0
   cleanup_mnt+0xb5/0x150
   task_work_run+0x57/0x80
   syscall_exit_to_user_mode+0x121/0x130
   do_syscall_64+0xab/0x1a0
   entry_SYSCALL_64_after_hwframe+0x77/0x7f
  RIP: 0033:0x7f916847a887
  ---[ end trace 0000000000000000 ]---
  BTRFS error (device dm-8 state EA): qgroup reserved space leaked

Cases 2 and 3 in the out_reserve path both pertain to this type of leak
and must free the reserved qgroup data. Because it is already an error
path, I opted not to handle the possible errors in
btrfs_free_qgroup_data.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('195ad5bbb99cd0772d14007f56f3945cdb2c6728')">
                                    <div class="issue-number">304</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="195ad5bbb99cd0772d14007f56f3945cdb2c6728">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

smb/server: fix potential null-ptr-deref of lease_ctx_info in smb2_open()

null-ptr-deref will occur when (req_op_level == SMB2_OPLOCK_LEVEL_LEASE)
and parse_lease_state() return NULL.

Fix this by check if 'lease_ctx_info' is NULL.

Additionally, remove the redundant parentheses in
parse_durable_handle_context().</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('1ac2bedb07c5d59ddff75c696d5d075fa7d96195')">
                                    <div class="issue-number">305</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="1ac2bedb07c5d59ddff75c696d5d075fa7d96195">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

cachefiles: Set the max subreq size for cache writes to MAX_RW_COUNT

Set the maximum size of a subrequest that writes to cachefiles to be
MAX_RW_COUNT so that we don't overrun the maximum write we can make to the
backing filesystem.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('ddd17552e0bcf11c550465e0db4c32b7decd2534')">
                                    <div class="issue-number">306</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="ddd17552e0bcf11c550465e0db4c32b7decd2534">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

Bluetooth: btnxpuart: Fix Null pointer dereference in btnxpuart_flush()

This adds a check before freeing the rx->skb in flush and close
functions to handle the kernel crash seen while removing driver after FW
download fails or before FW download completes.

dmesg log:
[   54.634586] Unable to handle kernel NULL pointer dereference at virtual address 0000000000000080
[   54.643398] Mem abort info:
[   54.646204]   ESR = 0x0000000096000004
[   54.649964]   EC = 0x25: DABT (current EL), IL = 32 bits
[   54.655286]   SET = 0, FnV = 0
[   54.658348]   EA = 0, S1PTW = 0
[   54.661498]   FSC = 0x04: level 0 translation fault
[   54.666391] Data abort info:
[   54.669273]   ISV = 0, ISS = 0x00000004, ISS2 = 0x00000000
[   54.674768]   CM = 0, WnR = 0, TnD = 0, TagAccess = 0
[   54.674771]   GCS = 0, Overlay = 0, DirtyBit = 0, Xs = 0
[   54.674775] user pgtable: 4k pages, 48-bit VAs, pgdp=0000000048860000
[   54.674780] [0000000000000080] pgd=0000000000000000, p4d=0000000000000000
[   54.703880] Internal error: Oops: 0000000096000004 [#1] PREEMPT SMP
[   54.710152] Modules linked in: btnxpuart(-) overlay fsl_jr_uio caam_jr caamkeyblob_desc caamhash_desc caamalg_desc crypto_engine authenc libdes crct10dif_ce polyval_ce polyval_generic snd_soc_imx_spdif snd_soc_imx_card snd_soc_ak5558 snd_soc_ak4458 caam secvio error snd_soc_fsl_micfil snd_soc_fsl_spdif snd_soc_fsl_sai snd_soc_fsl_utils imx_pcm_dma gpio_ir_recv rc_core sch_fq_codel fuse
[   54.744357] CPU: 3 PID: 72 Comm: kworker/u9:0 Not tainted 6.6.3-otbr-g128004619037 #2
[   54.744364] Hardware name: FSL i.MX8MM EVK board (DT)
[   54.744368] Workqueue: hci0 hci_power_on
[   54.757244] pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)
[   54.757249] pc : kfree_skb_reason+0x18/0xb0
[   54.772299] lr : btnxpuart_flush+0x40/0x58 [btnxpuart]
[   54.782921] sp : ffff8000805ebca0
[   54.782923] x29: ffff8000805ebca0 x28: ffffa5c6cf1869c0 x27: ffffa5c6cf186000
[   54.782931] x26: ffff377b84852400 x25: ffff377b848523c0 x24: ffff377b845e7230
[   54.782938] x23: ffffa5c6ce8dbe08 x22: ffffa5c6ceb65410 x21: 00000000ffffff92
[   54.782945] x20: ffffa5c6ce8dbe98 x19: ffffffffffffffac x18: ffffffffffffffff
[   54.807651] x17: 0000000000000000 x16: ffffa5c6ce2824ec x15: ffff8001005eb857
[   54.821917] x14: 0000000000000000 x13: ffffa5c6cf1a02e0 x12: 0000000000000642
[   54.821924] x11: 0000000000000040 x10: ffffa5c6cf19d690 x9 : ffffa5c6cf19d688
[   54.821931] x8 : ffff377b86000028 x7 : 0000000000000000 x6 : 0000000000000000
[   54.821938] x5 : ffff377b86000000 x4 : 0000000000000000 x3 : 0000000000000000
[   54.843331] x2 : 0000000000000000 x1 : 0000000000000002 x0 : ffffffffffffffac
[   54.857599] Call trace:
[   54.857601]  kfree_skb_reason+0x18/0xb0
[   54.863878]  btnxpuart_flush+0x40/0x58 [btnxpuart]
[   54.863888]  hci_dev_open_sync+0x3a8/0xa04
[   54.872773]  hci_power_on+0x54/0x2e4
[   54.881832]  process_one_work+0x138/0x260
[   54.881842]  worker_thread+0x32c/0x438
[   54.881847]  kthread+0x118/0x11c
[   54.881853]  ret_from_fork+0x10/0x20
[   54.896406] Code: a9be7bfd 910003fd f9000bf3 aa0003f3 (b940d400)
[   54.896410] ---[ end trace 0000000000000000 ]---</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('ff31a1628a0c443fe31973ec10e06a145c8dd209')">
                                    <div class="issue-number">307</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="ff31a1628a0c443fe31973ec10e06a145c8dd209">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

btrfs: don't BUG_ON() when 0 reference count at btrfs_lookup_extent_info()

Instead of doing a BUG_ON() handle the error by returning -EUCLEAN,
aborting the transaction and logging an error message.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('1776c209cb9ede8e6c211dbe2a31dbf1297fbb4e')">
                                    <div class="issue-number">308</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="1776c209cb9ede8e6c211dbe2a31dbf1297fbb4e">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

btrfs: handle errors from btrfs_dec_ref() properly

In walk_up_proc() we BUG_ON(ret) from btrfs_dec_ref().  This is
incorrect, we have proper error handling here, return the error.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('d9d7e7e4e0e11a6617c023f0d749e3a2bfbf9580')">
                                    <div class="issue-number">309</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="d9d7e7e4e0e11a6617c023f0d749e3a2bfbf9580">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

bpf: Remove tst_run from lwt_seg6local_prog_ops.

The syzbot reported that the lwt_seg6 related BPF ops can be invoked
via bpf_test_run() without without entering input_action_end_bpf()
first.

Martin KaFai Lau said that self test for BPF_PROG_TYPE_LWT_SEG6LOCAL
probably didn't work since it was introduced in commit 04d4b274e2a
("ipv6: sr: Add seg6local action End.BPF"). The reason is that the
per-CPU variable seg6_bpf_srh_states::srh is never assigned in the self
test case but each BPF function expects it.

Remove test_run for BPF_PROG_TYPE_LWT_SEG6LOCAL.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('07432d24e6c504bf3c3140993775a2ab1805e577')">
                                    <div class="issue-number">310</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="07432d24e6c504bf3c3140993775a2ab1805e577">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

wifi: rtw88: usb: schedule rx work after everything is set up

Right now it's possible to hit NULL pointer dereference in
rtw_rx_fill_rx_status on hw object and/or its fields because
initialization routine can start getting USB replies before
rtw_dev is fully setup.

The stack trace looks like this:

rtw_rx_fill_rx_status
rtw8821c_query_rx_desc
rtw_usb_rx_handler
...
queue_work
rtw_usb_read_port_complete
...
usb_submit_urb
rtw_usb_rx_resubmit
rtw_usb_init_rx
rtw_usb_probe

So while we do the async stuff rtw_usb_probe continues and calls
rtw_register_hw, which does all kinds of initialization (e.g.
via ieee80211_register_hw) that rtw_rx_fill_rx_status relies on.

Fix this by moving the first usb_submit_urb after everything
is set up.

For me, this bug manifested as:
[    8.893177] rtw_8821cu 1-1:1.2: band wrong, packet dropped
[    8.910904] rtw_8821cu 1-1:1.2: hw->conf.chandef.chan NULL in rtw_rx_fill_rx_status
because I'm using Larry's backport of rtw88 driver with the NULL
checks in rtw_rx_fill_rx_status.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('ae740c2a2d0adce6f086fb7bfe82a06fb7326851')">
                                    <div class="issue-number">311</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="ae740c2a2d0adce6f086fb7bfe82a06fb7326851">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

xen: privcmd: Fix possible access to a freed kirqfd instance

Nothing prevents simultaneous ioctl calls to privcmd_irqfd_assign() and
privcmd_irqfd_deassign(). If that happens, it is possible that a kirqfd
created and added to the irqfds_list by privcmd_irqfd_assign() may get
removed by another thread executing privcmd_irqfd_deassign(), while the
former is still using it after dropping the locks.

This can lead to a situation where an already freed kirqfd instance may
be accessed and cause kernel oops.

Use SRCU locking to prevent the same, as is done for the KVM
implementation for irqfds.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('6ad24335f4aa3916a683d73359f18d864ce1615c')">
                                    <div class="issue-number">312</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="6ad24335f4aa3916a683d73359f18d864ce1615c">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

ice: protect XDP configuration with a mutex

The main threat to data consistency in ice_xdp() is a possible asynchronous
PF reset. It can be triggered by a user or by TX timeout handler.

XDP setup and PF reset code access the same resources in the following
sections:
* ice_vsi_close() in ice_prepare_for_reset() - already rtnl-locked
* ice_vsi_rebuild() for the PF VSI - not protected
* ice_vsi_open() - already rtnl-locked

With an unfortunate timing, such accesses can result in a crash such as the
one below:

[ +1.999878] ice 0000:b1:00.0: Registered XDP mem model MEM_TYPE_XSK_BUFF_POOL on Rx ring 14
[ +2.002992] ice 0000:b1:00.0: Registered XDP mem model MEM_TYPE_XSK_BUFF_POOL on Rx ring 18
[Mar15 18:17] ice 0000:b1:00.0 ens801f0np0: NETDEV WATCHDOG: CPU: 38: transmit queue 14 timed out 80692736 ms
[ +0.000093] ice 0000:b1:00.0 ens801f0np0: tx_timeout: VSI_num: 6, Q 14, NTC: 0x0, HW_HEAD: 0x0, NTU: 0x0, INT: 0x4000001
[ +0.000012] ice 0000:b1:00.0 ens801f0np0: tx_timeout recovery level 1, txqueue 14
[ +0.394718] ice 0000:b1:00.0: PTP reset successful
[ +0.006184] BUG: kernel NULL pointer dereference, address: 0000000000000098
[ +0.000045] #PF: supervisor read access in kernel mode
[ +0.000023] #PF: error_code(0x0000) - not-present page
[ +0.000023] PGD 0 P4D 0
[ +0.000018] Oops: 0000 [#1] PREEMPT SMP NOPTI
[ +0.000023] CPU: 38 PID: 7540 Comm: kworker/38:1 Not tainted 6.8.0-rc7 #1
[ +0.000031] Hardware name: Intel Corporation S2600WFT/S2600WFT, BIOS SE5C620.86B.02.01.0014.082620210524 08/26/2021
[ +0.000036] Workqueue: ice ice_service_task [ice]
[ +0.000183] RIP: 0010:ice_clean_tx_ring+0xa/0xd0 [ice]
[...]
[ +0.000013] Call Trace:
[ +0.000016] <TASK>
[ +0.000014] ? __die+0x1f/0x70
[ +0.000029] ? page_fault_oops+0x171/0x4f0
[ +0.000029] ? schedule+0x3b/0xd0
[ +0.000027] ? exc_page_fault+0x7b/0x180
[ +0.000022] ? asm_exc_page_fault+0x22/0x30
[ +0.000031] ? ice_clean_tx_ring+0xa/0xd0 [ice]
[ +0.000194] ice_free_tx_ring+0xe/0x60 [ice]
[ +0.000186] ice_destroy_xdp_rings+0x157/0x310 [ice]
[ +0.000151] ice_vsi_decfg+0x53/0xe0 [ice]
[ +0.000180] ice_vsi_rebuild+0x239/0x540 [ice]
[ +0.000186] ice_vsi_rebuild_by_type+0x76/0x180 [ice]
[ +0.000145] ice_rebuild+0x18c/0x840 [ice]
[ +0.000145] ? delay_tsc+0x4a/0xc0
[ +0.000022] ? delay_tsc+0x92/0xc0
[ +0.000020] ice_do_reset+0x140/0x180 [ice]
[ +0.000886] ice_service_task+0x404/0x1030 [ice]
[ +0.000824] process_one_work+0x171/0x340
[ +0.000685] worker_thread+0x277/0x3a0
[ +0.000675] ? preempt_count_add+0x6a/0xa0
[ +0.000677] ? _raw_spin_lock_irqsave+0x23/0x50
[ +0.000679] ? __pfx_worker_thread+0x10/0x10
[ +0.000653] kthread+0xf0/0x120
[ +0.000635] ? __pfx_kthread+0x10/0x10
[ +0.000616] ret_from_fork+0x2d/0x50
[ +0.000612] ? __pfx_kthread+0x10/0x10
[ +0.000604] ret_from_fork_asm+0x1b/0x30
[ +0.000604] </TASK>

The previous way of handling this through returning -EBUSY is not viable,
particularly when destroying AF_XDP socket, because the kernel proceeds
with removal anyway.

There is plenty of code between those calls and there is no need to create
a large critical section that covers all of them, same as there is no need
to protect ice_vsi_rebuild() with rtnl_lock().

Add xdp_state_lock mutex to protect ice_vsi_rebuild() and ice_xdp().

Leaving unprotected sections in between would result in two states that
have to be considered:
1. when the VSI is closed, but not yet rebuild
2. when VSI is already rebuild, but not yet open

The latter case is actually already handled through !netif_running() case,
we just need to adjust flag checking a little. The former one is not as
trivial, because between ice_vsi_close() and ice_vsi_rebuild(), a lot of
hardware interaction happens, this can make adding/deleting rings exit
with an error. Luckily, VSI rebuild is pending and can apply new
configuration for us in a managed fashion.

Therefore, add an additional VSI state flag ICE_VSI_REBUILD_PENDING to
indicate that ice_x
---truncated---</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('6c616477e8980871283b01738d5da0391b4598e2')">
                                    <div class="issue-number">313</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="6c616477e8980871283b01738d5da0391b4598e2">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Check denominator crb_pipes before used

[WHAT & HOW]
A denominator cannot be 0, and is checked before used.

This fixes 2 DIVIDE_BY_ZERO issues reported by Coverity.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('73cbe458c8c8bb4c1eacfa5bad6cb792039356de')">
                                    <div class="issue-number">314</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="73cbe458c8c8bb4c1eacfa5bad6cb792039356de">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Validate function returns

[WHAT & HOW]
Function return values must be checked before data can be used
in subsequent functions.

This fixes 4 CHECKED_RETURN issues reported by Coverity.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('373231c33e0437191154409fac4dfcdd31e2428e')">
                                    <div class="issue-number">315</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="373231c33e0437191154409fac4dfcdd31e2428e">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Run DC_LOG_DC after checking link->link_enc

[WHAT]
The DC_LOG_DC should be run after link->link_enc is checked, not before.

This fixes 1 REVERSE_INULL issue reported by Coverity.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('4b80dc8c51585af0c08c6acb44b9aa2946de4ada')">
                                    <div class="issue-number">316</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="4b80dc8c51585af0c08c6acb44b9aa2946de4ada">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Check UnboundedRequestEnabled's value

CalculateSwathAndDETConfiguration_params_st's UnboundedRequestEnabled
is a pointer (i.e. dml_bool_t *UnboundedRequestEnabled), and thus
if (p->UnboundedRequestEnabled) checks its address, not bool value.

This fixes 1 REVERSE_INULL issue reported by Coverity.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('ce226109a277a4b98080f55ecb4926abb56a2066')">
                                    <div class="issue-number">317</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="ce226109a277a4b98080f55ecb4926abb56a2066">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

userfaultfd: fix checks for huge PMDs

Patch series "userfaultfd: fix races around pmd_trans_huge() check", v2.

The pmd_trans_huge() code in mfill_atomic() is wrong in three different
ways depending on kernel version:

1. The pmd_trans_huge() check is racy and can lead to a BUG_ON() (if you hit
   the right two race windows) - I've tested this in a kernel build with
   some extra mdelay() calls. See the commit message for a description
   of the race scenario.
   On older kernels (before 6.5), I think the same bug can even
   theoretically lead to accessing transhuge page contents as a page table
   if you hit the right 5 narrow race windows (I haven't tested this case).
2. As pointed out by Qi Zheng, pmd_trans_huge() is not sufficient for
   detecting PMDs that don't point to page tables.
   On older kernels (before 6.5), you'd just have to win a single fairly
   wide race to hit this.
   I've tested this on 6.1 stable by racing migration (with a mdelay()
   patched into try_to_migrate()) against UFFDIO_ZEROPAGE - on my x86
   VM, that causes a kernel oops in ptlock_ptr().
3. On newer kernels (>=6.5), for shmem mappings, khugepaged is allowed
   to yank page tables out from under us (though I haven't tested that),
   so I think the BUG_ON() checks in mfill_atomic() are just wrong.

I decided to write two separate fixes for these (one fix for bugs 1+2, one
fix for bug 3), so that the first fix can be backported to kernels
affected by bugs 1+2.


This patch (of 2):

This fixes two issues.

I discovered that the following race can occur:

  mfill_atomic                other thread
  ============                ============
                              <zap PMD>
  pmdp_get_lockless() [reads none pmd]
  <bail if trans_huge>
  <if none:>
                              <pagefault creates transhuge zeropage>
    __pte_alloc [no-op]
                              <zap PMD>
  <bail if pmd_trans_huge(*dst_pmd)>
  BUG_ON(pmd_none(*dst_pmd))

I have experimentally verified this in a kernel with extra mdelay() calls;
the BUG_ON(pmd_none(*dst_pmd)) triggers.

On kernels newer than commit 0d940a9b270b ("mm/pgtable: allow
pte_offset_map[_lock]() to fail"), this can't lead to anything worse than
a BUG_ON(), since the page table access helpers are actually designed to
deal with page tables concurrently disappearing; but on older kernels
(<=6.4), I think we could probably theoretically race past the two
BUG_ON() checks and end up treating a hugepage as a page table.

The second issue is that, as Qi Zheng pointed out, there are other types
of huge PMDs that pmd_trans_huge() can't catch: devmap PMDs and swap PMDs
(in particular, migration PMDs).

On <=6.4, this is worse than the first issue: If mfill_atomic() runs on a
PMD that contains a migration entry (which just requires winning a single,
fairly wide race), it will pass the PMD to pte_offset_map_lock(), which
assumes that the PMD points to a page table.

Breakage follows: First, the kernel tries to take the PTE lock (which will
crash or maybe worse if there is no "struct page" for the address bits in
the migration entry PMD - I think at least on X86 there usually is no
corresponding "struct page" thanks to the PTE inversion mitigation, amd64
looks different).

If that didn't crash, the kernel would next try to write a PTE into what
it wrongly thinks is a page table.

As part of fixing these issues, get rid of the check for pmd_trans_huge()
before __pte_alloc() - that's redundant, we're going to have to check for
that after the __pte_alloc() anyway.

Backport note: pmdp_get_lockless() is pmd_read_atomic() in older kernels.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('af74b7af99ed425863251b11784b0784e8ab4077')">
                                    <div class="issue-number">318</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="af74b7af99ed425863251b11784b0784e8ab4077">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amdkfd: Check debug trap enable before write dbg_ev_file

In interrupt context, write dbg_ev_file will be run by work queue. It
will cause write dbg_ev_file execution after debug_trap_disable, which
will cause NULL pointer access.
v2: cancel work "debug_event_workarea" before set dbg_ev_file as NULL.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('48c1c914de215890c0dbb0568c9c0623487bd414')">
                                    <div class="issue-number">319</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="48c1c914de215890c0dbb0568c9c0623487bd414">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amdgpu: Fix the warning division or modulo by zero

Checks the partition mode and returns an error for an invalid mode.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('7645c0d9ea149ca57c1c2ffbae3b6020ea1e8da7')">
                                    <div class="issue-number">320</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="7645c0d9ea149ca57c1c2ffbae3b6020ea1e8da7">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Add missing NULL pointer check within dpcd_extend_address_range

[Why & How]
ASSERT if return NULL from kcalloc.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('f9814e2b6ce0a6439957a84ec1ad185965120bb0')">
                                    <div class="issue-number">321</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="f9814e2b6ce0a6439957a84ec1ad185965120bb0">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Check BIOS images before it is used

BIOS images may fail to load and null checks are added before they are
used.

This fixes 6 NULL_RETURNS issues reported by Coverity.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('e2ba3c39d32e4ed6991b35e6365361a512cbd63e')">
                                    <div class="issue-number">322</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="e2ba3c39d32e4ed6991b35e6365361a512cbd63e">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Stop amdgpu_dm initialize when link nums greater than max_links

[Why]
Coverity report OVERRUN warning. There are
only max_links elements within dc->links. link
count could up to AMDGPU_DM_MAX_DISPLAY_INDEX 31.

[How]
Make sure link count less than max_links.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('5ac372effae53131a60166c68083afff4fc7227a')">
                                    <div class="issue-number">323</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="5ac372effae53131a60166c68083afff4fc7227a">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

kunit/overflow: Fix UB in overflow_allocation_test

The 'device_name' array doesn't exist out of the
'overflow_allocation_test' function scope. However, it is being used as
a driver name when calling 'kunit_driver_create' from
'kunit_device_register'. It produces the kernel panic with KASAN
enabled.

Since this variable is used in one place only, remove it and pass the
device name into kunit_device_register directly as an ascii string.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('376d14754c99c8b1741ad8245a0895e29bf98425')">
                                    <div class="issue-number">324</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="376d14754c99c8b1741ad8245a0895e29bf98425">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

wifi: iwlwifi: mvm: use IWL_FW_CHECK for link ID check

The lookup function iwl_mvm_rcu_fw_link_id_to_link_conf() is
normally called with input from the firmware, so it should use
IWL_FW_CHECK() instead of WARN_ON().</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('0ebdb47ff08817d6ca4e5375189c5efd510dbde5')">
                                    <div class="issue-number">325</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="0ebdb47ff08817d6ca4e5375189c5efd510dbde5">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

ethtool: fail closed if we can't get max channel used in indirection tables

Commit 0d1b7d6c9274 ("bnxt: fix crashes when reducing ring count with
active RSS contexts") proves that allowing indirection table to contain
channels with out of bounds IDs may lead to crashes. Currently the
max channel check in the core gets skipped if driver can't fetch
the indirection table or when we can't allocate memory.

Both of those conditions should be extremely rare but if they do
happen we should try to be safe and fail the channel change.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('e47d75c98ac3c7091a372bfc4ee1af131ded9b4e')">
                                    <div class="issue-number">326</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="e47d75c98ac3c7091a372bfc4ee1af131ded9b4e">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

btrfs: don't BUG_ON on ENOMEM from btrfs_lookup_extent_info() in walk_down_proc()

We handle errors here properly, ENOMEM isn't fatal, return the error.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('e975d6e5bbac0974948e4ed5c35744fe675c7c33')">
                                    <div class="issue-number">327</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="e975d6e5bbac0974948e4ed5c35744fe675c7c33">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

scsi: lpfc: Handle mailbox timeouts in lpfc_get_sfp_info

The MBX_TIMEOUT return code is not handled in lpfc_get_sfp_info and the
routine unconditionally frees submitted mailbox commands regardless of
return status.  The issue is that for MBX_TIMEOUT cases, when firmware
returns SFP information at a later time, that same mailbox memory region
references previously freed memory in its cmpl routine.

Fix by adding checks for the MBX_TIMEOUT return code.  During mailbox
resource cleanup, check the mbox flag to make sure that the wait did not
timeout.  If the MBOX_WAKE flag is not set, then do not free the resources
because it will be freed when firmware completes the mailbox at a later
time in its cmpl routine.

Also, increase the timeout from 30 to 60 seconds to accommodate boot
scripts requiring longer timeouts.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('c31780225e2017eec61a4fda9e8ff954e04de720')">
                                    <div class="issue-number">328</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="c31780225e2017eec61a4fda9e8ff954e04de720">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

scsi: ufs: core: Remove SCSI host only if added

If host tries to remove ufshcd driver from a UFS device it would cause a
kernel panic if ufshcd_async_scan fails during ufshcd_probe_hba before
adding a SCSI host with scsi_add_host and MCQ is enabled since SCSI host
has been defered after MCQ configuration introduced by commit 0cab4023ec7b
("scsi: ufs: core: Defer adding host to SCSI if MCQ is supported").

To guarantee that SCSI host is removed only if it has been added, set the
scsi_host_added flag to true after adding a SCSI host and check whether it
is set or not before removing it.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('28f8fce1f0e5429d0a015fe47f84d4b7265b4564')">
                                    <div class="issue-number">329</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="28f8fce1f0e5429d0a015fe47f84d4b7265b4564">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

wifi: mt76: mt7921: fix NULL pointer access in mt7921_ipv6_addr_change

When disabling wifi mt7921_ipv6_addr_change() is called as a notifier.
At this point mvif->phy is already NULL so we cannot use it here.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('7b2c716de3d1e296ddbd80700f83542d5001a78c')">
                                    <div class="issue-number">330</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="7b2c716de3d1e296ddbd80700f83542d5001a78c">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

usbnet: ipheth: do not stop RX on failing RX callback

RX callbacks can fail for multiple reasons:

* Payload too short
* Payload formatted incorrecly (e.g. bad NCM framing)
* Lack of memory

None of these should cause the driver to seize up.

Make such failures non-critical and continue processing further
incoming URBs.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('8725de4a3653e268fc144f47f4719bcd72e11945')">
                                    <div class="issue-number">331</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="8725de4a3653e268fc144f47f4719bcd72e11945">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Disable DMCUB timeout for DCN35

[Why]
DMCUB can intermittently take longer than expected to process commands.

Old ASIC policy was to continue while logging a diagnostic error - which
works fine for ASIC without IPS, but with IPS this could lead to a race
condition where we attempt to access DCN state while it's inaccessible,
leading to a system hang when the NIU port is not disabled or register
accesses that timeout and the display configuration in an undefined
state.

[How]
We need to investigate why these accesses take longer than expected, but
for now we should disable the timeout on DCN35 to avoid this race
condition. Since the waits happen only at lower interrupt levels the
risk of taking too long at higher IRQ and causing a system watchdog
timeout are minimal.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('4cf6fe48791d134ed42d969ee16de004fa5ddcd2')">
                                    <div class="issue-number">332</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="4cf6fe48791d134ed42d969ee16de004fa5ddcd2">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

crypto: stm32/cryp - call finalize with bh disabled

The finalize operation in interrupt mode produce a produces a spinlock
recursion warning. The reason is the fact that BH must be disabled
during this process.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('4fb3a918a062bde5c734f76d012aeacc88566c01')">
                                    <div class="issue-number">333</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="4fb3a918a062bde5c734f76d012aeacc88566c01">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Avoid overflow from uint32_t to uint8_t

[WHAT & HOW]
dmub_rb_cmd's ramping_boundary has size of uint8_t and it is assigned
0xFFFF. Fix it by changing it to uint8_t with value of 0xFF.

This fixes 2 INTEGER_OVERFLOW issues reported by Coverity.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('3ed7c0485c49a1fbe49cb59dea666d5d8c19bed4')">
                                    <div class="issue-number">334</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="3ed7c0485c49a1fbe49cb59dea666d5d8c19bed4">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Remove register from DCN35 DMCUB diagnostic collection

[Why]
These registers should not be read from driver and triggering the
security violation when DMCUB work times out and diagnostics are
collected blocks Z8 entry.

[How]
Remove the register read from DCN35.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('551976725342615302c9c23445aac40c34ad6760')">
                                    <div class="issue-number">335</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="551976725342615302c9c23445aac40c34ad6760">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

spi: hisi-kunpeng: Add verification for the max_frequency provided by the firmware

If the value of max_speed_hz is 0, it may cause a division by zero
error in hisi_calc_effective_speed().
The value of max_speed_hz is provided by firmware.
Firmware is generally considered as a trusted domain. However, as
division by zero errors can cause system failure, for defense measure,
the value of max_speed is validated here. So 0 is regarded as invalid
and an error code is returned.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('75ff4bbd004e854f80bc720cee1e186fabde6192')">
                                    <div class="issue-number">336</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="75ff4bbd004e854f80bc720cee1e186fabde6192">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

scsi: pm80xx: Set phy->enable_completion only when we wait for it

pm8001_phy_control() populates the enable_completion pointer with a stack
address, sends a PHY_LINK_RESET / PHY_HARD_RESET, waits 300 ms, and
returns. The problem arises when a phy control response comes late.  After
300 ms the pm8001_phy_control() function returns and the passed
enable_completion stack address is no longer valid. Late phy control
response invokes complete() on a dangling enable_completion pointer which
leads to a kernel crash.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('68c67c01af6f4e7bc3526ad7f379e8a1e8643660')">
                                    <div class="issue-number">337</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="68c67c01af6f4e7bc3526ad7f379e8a1e8643660">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

bpf, lsm: Add check for BPF LSM return value

A bpf prog returning a positive number attached to file_alloc_security
hook makes kernel panic.

This happens because file system can not filter out the positive number
returned by the LSM prog using IS_ERR, and misinterprets this positive
number as a file pointer.

Given that hook file_alloc_security never returned positive number
before the introduction of BPF LSM, and other BPF LSM hooks may
encounter similar issues, this patch adds LSM return value check
in verifier, to ensure no unexpected value is returned.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('fd499a4ea3bea85fa12da0d10fd532fccbcb9a3b')">
                                    <div class="issue-number">338</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="fd499a4ea3bea85fa12da0d10fd532fccbcb9a3b">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Check link_res->hpo_dp_link_enc before using it

[WHAT & HOW]
Functions dp_enable_link_phy and dp_disable_link_phy can pass link_res
without initializing hpo_dp_link_enc and it is necessary to check for
null before dereferencing.

This fixes 2 FORWARD_NULL issues reported by Coverity.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('cc322bad1b31e138ad2f612643abc754777fe0c7')">
                                    <div class="issue-number">339</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="cc322bad1b31e138ad2f612643abc754777fe0c7">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

f2fs: fix to wait dio completion

It should wait all existing dio write IOs before block removal,
otherwise, previous direct write IO may overwrite data in the
block which may be reused by other inode.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('a3f8a1eb4519ba6f8aef5d336a4cfb17a596b122')">
                                    <div class="issue-number">340</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="a3f8a1eb4519ba6f8aef5d336a4cfb17a596b122">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

erofs: handle overlapped pclusters out of crafted images properly

syzbot reported a task hang issue due to a deadlock case where it is
waiting for the folio lock of a cached folio that will be used for
cache I/Os.

After looking into the crafted fuzzed image, I found it's formed with
several overlapped big pclusters as below:

 Ext:   logical offset   |  length :     physical offset    |  length
   0:        0..   16384 |   16384 :     151552..    167936 |   16384
   1:    16384..   32768 |   16384 :     155648..    172032 |   16384
   2:    32768..   49152 |   16384 :  537223168.. 537239552 |   16384
...

Here, extent 0/1 are physically overlapped although it's entirely
_impossible_ for normal filesystem images generated by mkfs.

First, managed folios containing compressed data will be marked as
up-to-date and then unlocked immediately (unlike in-place folios) when
compressed I/Os are complete.  If physical blocks are not submitted in
the incremental order, there should be separate BIOs to avoid dependency
issues.  However, the current code mis-arranges z_erofs_fill_bio_vec()
and BIO submission which causes unexpected BIO waits.

Second, managed folios will be connected to their own pclusters for
efficient inter-queries.  However, this is somewhat hard to implement
easily if overlapped big pclusters exist.  Again, these only appear in
fuzzed images so let's simply fall back to temporary short-lived pages
for correctness.

Additionally, it justifies that referenced managed folios cannot be
truncated for now and reverts part of commit 2080ca1ed3e4 ("erofs: tidy
up `struct z_erofs_bvec`") for simplicity although it shouldn't be any
difference.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('c91bfe40c91e3e43b5ef63e3c6e2c393936def5c')">
                                    <div class="issue-number">341</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="c91bfe40c91e3e43b5ef63e3c6e2c393936def5c">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

media: mediatek: vcodec: Fix H264 stateless decoder smatch warning

Fix a smatch static checker warning on vdec_h264_req_if.c.
Which leads to a kernel crash when fb is NULL.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('e0d539227641f7db746efe2cae3d57213f793765')">
                                    <div class="issue-number">342</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="e0d539227641f7db746efe2cae3d57213f793765">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

media: mediatek: vcodec: Fix VP8 stateless decoder smatch warning

Fix a smatch static checker warning on vdec_vp8_req_if.c.
Which leads to a kernel crash when fb is NULL.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('df0c92135b786b2928a19e3f729af326436bc48f')">
                                    <div class="issue-number">343</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="df0c92135b786b2928a19e3f729af326436bc48f">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

media: mediatek: vcodec: Fix H264 multi stateless decoder smatch warning

Fix a smatch static checker warning on vdec_h264_req_multi_if.c.
Which leads to a kernel crash when fb is NULL.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('e4eb648fb4ef12a9577dc82a0b710ba402008201')">
                                    <div class="issue-number">344</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="e4eb648fb4ef12a9577dc82a0b710ba402008201">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

scsi: lpfc: Validate hdwq pointers before dereferencing in reset/errata paths

When the HBA is undergoing a reset or is handling an errata event, NULL ptr
dereference crashes may occur in routines such as
lpfc_sli_flush_io_rings(), lpfc_dev_loss_tmo_callbk(), or
lpfc_abort_handler().

Add NULL ptr checks before dereferencing hdwq pointers that may have been
freed due to operations colliding with a reset or errata event handler.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('967451f59e8bcc4a9c4cf1512adb11c0494b2a83')">
                                    <div class="issue-number">345</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="967451f59e8bcc4a9c4cf1512adb11c0494b2a83">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Check stream_status before it is used

[WHAT & HOW]
dc_state_get_stream_status can return null, and therefore null must be
checked before stream_status is used.

This fixes 1 NULL_RETURNS issue reported by Coverity.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('65e3ed11df0c78d66e7876ed6840f5f2f2ac2e09')">
                                    <div class="issue-number">346</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="65e3ed11df0c78d66e7876ed6840f5f2f2ac2e09">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Check phantom_stream before it is used

dcn32_enable_phantom_stream can return null, so returned value
must be checked before used.

This fixes 1 NULL_RETURNS issue reported by Coverity.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('827bd5cc83eed16fd81d5c9afa121d597e9511ce')">
                                    <div class="issue-number">347</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="827bd5cc83eed16fd81d5c9afa121d597e9511ce">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Check null-initialized variables

[WHAT & HOW]
drr_timing and subvp_pipe are initialized to null and they are not
always assigned new values. It is necessary to check for null before
dereferencing.

This fixes 2 FORWARD_NULL issues reported by Coverity.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('8f60618b9dca28662730bfd755da5e066cb28b99')">
                                    <div class="issue-number">348</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="8f60618b9dca28662730bfd755da5e066cb28b99">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Initialize denominators' default to 1

[WHAT & HOW]
Variables used as denominators and maybe not assigned to other values,
should not be 0. Change their default to 1 so they are never 0.

This fixes 10 DIVIDE_BY_ZERO issues reported by Coverity.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('aa153192018af798025774cd76097cba7e8978ef')">
                                    <div class="issue-number">349</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="aa153192018af798025774cd76097cba7e8978ef">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/msm/adreno: Assign msm_gpu->pdev earlier to avoid nullptrs

There are some cases, such as the one uncovered by Commit 46d4efcccc68
("drm/msm/a6xx: Avoid a nullptr dereference when speedbin setting fails")
where

msm_gpu_cleanup() : platform_set_drvdata(gpu->pdev, NULL);

is called on gpu->pdev == NULL, as the GPU device has not been fully
initialized yet.

Turns out that there's more than just the aforementioned path that
causes this to happen (e.g. the case when there's speedbin data in the
catalog, but opp-supported-hw is missing in DT).

Assigning msm_gpu->pdev earlier seems like the least painful solution
to this, therefore do so.

Patchwork: https://patchwork.freedesktop.org/patch/602742/</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('ad7ba691ed43a14b632dfda54fdd04b822e0ca60')">
                                    <div class="issue-number">350</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="ad7ba691ed43a14b632dfda54fdd04b822e0ca60">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amdgpu: add list empty check to avoid null pointer issue

Add list empty check to avoid null pointer issues in some corner cases.
- list_for_each_entry_safe()</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('3ca271fbb9d5fa8cbb39d95b366e0346939c32d8')">
                                    <div class="issue-number">351</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="3ca271fbb9d5fa8cbb39d95b366e0346939c32d8">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Check null pointer before try to access it

[why & how]
Change the order of the pipe_ctx->plane_state check to ensure that
plane_state is not null before accessing it.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('566c01b6e1bad8ff3045159747fa58ecba5dbb0d')">
                                    <div class="issue-number">352</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="566c01b6e1bad8ff3045159747fa58ecba5dbb0d">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Add null check for 'afb' in amdgpu_dm_update_cursor (v2)

This commit adds a null check for the 'afb' variable in the
amdgpu_dm_update_cursor function. Previously, 'afb' was assumed to be
null at line 8388, but was used later in the code without a null check.
This could potentially lead to a null pointer dereference.

Changes since v1:
- Moved the null check for 'afb' to the line where 'afb' is used. (Alex)

Fixes the below:
drivers/gpu/drm/amd/amdgpu/../display/amdgpu_dm/amdgpu_dm.c:8433 amdgpu_dm_update_cursor()
	error: we previously assumed 'afb' could be null (see line 8388)</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('a192b0643b9a6e642c83cca7f8019e7a61f191e0')">
                                    <div class="issue-number">353</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="a192b0643b9a6e642c83cca7f8019e7a61f191e0">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Add NULL check for function pointer in dcn32_set_output_transfer_func

This commit adds a null check for the set_output_gamma function pointer
in the dcn32_set_output_transfer_func function. Previously,
set_output_gamma was being checked for null, but then it was being
dereferenced without any null check. This could lead to a null pointer
dereference if set_output_gamma is null.

To fix this, we now ensure that set_output_gamma is not null before
dereferencing it. We do this by adding a null check for set_output_gamma
before the call to set_output_gamma.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('6cba034965ba202e6f818ada5a9b85a2d6a1d2c8')">
                                    <div class="issue-number">354</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="6cba034965ba202e6f818ada5a9b85a2d6a1d2c8">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Add NULL check for function pointer in dcn401_set_output_transfer_func

This commit adds a null check for the set_output_gamma function pointer
in the dcn401_set_output_transfer_func function. Previously,
set_output_gamma was being checked for null, but then it was being
dereferenced without any null check. This could lead to a null pointer
dereference if set_output_gamma is null.

To fix this, we now ensure that set_output_gamma is not null before
dereferencing it. We do this by adding a null check for set_output_gamma
before the call to set_output_gamma.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('0a49c84a627b7b387d57dd0d223f05d6dfc11b52')">
                                    <div class="issue-number">355</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="0a49c84a627b7b387d57dd0d223f05d6dfc11b52">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Add NULL check for function pointer in dcn20_set_output_transfer_func

This commit adds a null check for the set_output_gamma function pointer
in the dcn20_set_output_transfer_func function. Previously,
set_output_gamma was being checked for null at line 1030, but then it
was being dereferenced without any null check at line 1048. This could
potentially lead to a null pointer dereference error if set_output_gamma
is null.

To fix this, we now ensure that set_output_gamma is not null before
dereferencing it. We do this by adding a null check for set_output_gamma
before the call to set_output_gamma at line 1048.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('95a08065f168cfd3eea289d0a7c5b713e9bda6f4')">
                                    <div class="issue-number">356</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="95a08065f168cfd3eea289d0a7c5b713e9bda6f4">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Add null check for pipe_ctx->plane_state in dcn20_program_pipe

This commit addresses a null pointer dereference issue in the
`dcn20_program_pipe` function. The issue could occur when
`pipe_ctx->plane_state` is null.

The fix adds a check to ensure `pipe_ctx->plane_state` is not null
before accessing. This prevents a null pointer dereference.

Reported by smatch:
drivers/gpu/drm/amd/amdgpu/../display/dc/hwss/dcn20/dcn20_hwseq.c:1925 dcn20_program_pipe() error: we previously assumed 'pipe_ctx->plane_state' could be null (see line 1877)</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('39057081407a95832891d6c627b3b9d9354e70dc')">
                                    <div class="issue-number">357</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="39057081407a95832891d6c627b3b9d9354e70dc">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Add NULL check for clk_mgr in dcn32_init_hw

This commit addresses a potential null pointer dereference issue in the
`dcn32_init_hw` function. The issue could occur when `dc->clk_mgr` is
null.

The fix adds a check to ensure `dc->clk_mgr` is not null before
accessing its functions. This prevents a potential null pointer
dereference.

Reported by smatch:
drivers/gpu/drm/amd/amdgpu/../display/dc/hwss/dcn32/dcn32_hwseq.c:961 dcn32_init_hw() error: we previously assumed 'dc->clk_mgr' could be null (see line 782)</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('14335b131c45f6e295a6f1320766826d8cb22fd2')">
                                    <div class="issue-number">358</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="14335b131c45f6e295a6f1320766826d8cb22fd2">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Add NULL check for clk_mgr and clk_mgr->funcs in dcn401_init_hw

This commit addresses a potential null pointer dereference issue in the
`dcn401_init_hw` function. The issue could occur when `dc->clk_mgr` or
`dc->clk_mgr->funcs` is null.

The fix adds a check to ensure `dc->clk_mgr` and `dc->clk_mgr->funcs` is
not null before accessing its functions. This prevents a potential null
pointer dereference.

Reported by smatch:
drivers/gpu/drm/amd/amdgpu/../display/dc/hwss/dcn401/dcn401_hwseq.c:416 dcn401_init_hw() error: we previously assumed 'dc->clk_mgr' could be null (see line 225)</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('4ed2a2468cd779905f29002ae48d2fa96a7d8db2')">
                                    <div class="issue-number">359</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="4ed2a2468cd779905f29002ae48d2fa96a7d8db2">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Add NULL check for clk_mgr and clk_mgr->funcs in dcn30_init_hw

This commit addresses a potential null pointer dereference issue in the
`dcn30_init_hw` function. The issue could occur when `dc->clk_mgr` or
`dc->clk_mgr->funcs` is null.

The fix adds a check to ensure `dc->clk_mgr` and `dc->clk_mgr->funcs` is
not null before accessing its functions. This prevents a potential null
pointer dereference.

Reported by smatch:
drivers/gpu/drm/amd/amdgpu/../display/dc/hwss/dcn30/dcn30_hwseq.c:789 dcn30_init_hw() error: we previously assumed 'dc->clk_mgr' could be null (see line 628)</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('0b3f97c42561988b7686d114d2b9165ac3be064f')">
                                    <div class="issue-number">360</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="0b3f97c42561988b7686d114d2b9165ac3be064f">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Add null check for head_pipe in dcn32_acquire_idle_pipe_for_head_pipe_in_layer

This commit addresses a potential null pointer dereference issue in the
`dcn32_acquire_idle_pipe_for_head_pipe_in_layer` function. The issue
could occur when `head_pipe` is null.

The fix adds a check to ensure `head_pipe` is not null before asserting
it. If `head_pipe` is null, the function returns NULL to prevent a
potential null pointer dereference.

Reported by smatch:
drivers/gpu/drm/amd/amdgpu/../display/dc/resource/dcn32/dcn32_resource.c:2690 dcn32_acquire_idle_pipe_for_head_pipe_in_layer() error: we previously assumed 'head_pipe' could be null (see line 2681)</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('58e886ca7187df7e1be776a5b34eea63a0a0fe74')">
                                    <div class="issue-number">361</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="58e886ca7187df7e1be776a5b34eea63a0a0fe74">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Add null check for head_pipe in dcn201_acquire_free_pipe_for_layer

This commit addresses a potential null pointer dereference issue in the
`dcn201_acquire_free_pipe_for_layer` function. The issue could occur
when `head_pipe` is null.

The fix adds a check to ensure `head_pipe` is not null before asserting
it. If `head_pipe` is null, the function returns NULL to prevent a
potential null pointer dereference.

Reported by smatch:
drivers/gpu/drm/amd/amdgpu/../display/dc/resource/dcn201/dcn201_resource.c:1016 dcn201_acquire_free_pipe_for_layer() error: we previously assumed 'head_pipe' could be null (see line 1010)</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('062606e42dd13bcfe75bfebea1305ea1b09ce605')">
                                    <div class="issue-number">362</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="062606e42dd13bcfe75bfebea1305ea1b09ce605">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Check null pointers before multiple uses

[WHAT & HOW]
Poniters, such as stream_enc and dc->bw_vbios, are null checked previously
in the same function, so Coverity warns "implies that stream_enc and
dc->bw_vbios might be null". They are used multiple times in the
subsequent code and need to be checked.

This fixes 10 FORWARD_NULL issues reported by Coverity.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('892417450bce8691d7811e415a219a31f648cea8')">
                                    <div class="issue-number">363</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="892417450bce8691d7811e415a219a31f648cea8">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Check null pointers before used

[WHAT & HOW]
Poniters, such as dc->clk_mgr, are null checked previously in the same
function, so Coverity warns "implies that "dc->clk_mgr" might be null".
As a result, these pointers need to be checked when used again.

This fixes 10 FORWARD_NULL issues reported by Coverity.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('6eb8d2c825b39b73370a2e5d56d94005cf00ab8f')">
                                    <div class="issue-number">364</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="6eb8d2c825b39b73370a2e5d56d94005cf00ab8f">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Check null pointers before using them

[WHAT & HOW]
These pointers are null checked previously in the same function,
indicating they might be null as reported by Coverity. As a result,
they need to be checked when used again.

This fixes 3 FORWARD_NULL issue reported by Coverity.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('6991cd8e9ac98b9d1c882b56643978dd9bacf3d5')">
                                    <div class="issue-number">365</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="6991cd8e9ac98b9d1c882b56643978dd9bacf3d5">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Pass non-null to dcn20_validate_apply_pipe_split_flags

[WHAT & HOW]
"dcn20_validate_apply_pipe_split_flags" dereferences merge, and thus it
cannot be a null pointer. Let's pass a valid pointer to avoid null
dereference.

This fixes 2 FORWARD_NULL issues reported by Coverity.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('1481e422209b8663fa5e811af2804f76f6245e73')">
                                    <div class="issue-number">366</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="1481e422209b8663fa5e811af2804f76f6245e73">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

fbdev: efifb: Register sysfs groups through driver core

The driver core can register and cleanup sysfs groups already.
Make use of that functionality to simplify the error handling and
cleanup.

Also avoid a UAF race during unregistering where the sysctl attributes
were usable after the info struct was freed.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('b053fd2d2e45e78e736ec79c87c94d3d3fefa074')">
                                    <div class="issue-number">367</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="b053fd2d2e45e78e736ec79c87c94d3d3fefa074">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

rcu-tasks: Fix access non-existent percpu rtpcp variable in rcu_tasks_need_gpcb()

For kernels built with CONFIG_FORCE_NR_CPUS=y, the nr_cpu_ids is
defined as NR_CPUS instead of the number of possible cpus, this
will cause the following system panic:

smpboot: Allowing 4 CPUs, 0 hotplug CPUs
...
setup_percpu: NR_CPUS:512 nr_cpumask_bits:512 nr_cpu_ids:512 nr_node_ids:1
...
BUG: unable to handle page fault for address: ffffffff9911c8c8
Oops: 0000 [#1] PREEMPT SMP PTI
CPU: 0 PID: 15 Comm: rcu_tasks_trace Tainted: G W
6.6.21 #1 5dc7acf91a5e8e9ac9dcfc35bee0245691283ea6
RIP: 0010:rcu_tasks_need_gpcb+0x25d/0x2c0
RSP: 0018:ffffa371c00a3e60 EFLAGS: 00010082
CR2: ffffffff9911c8c8 CR3: 000000040fa20005 CR4: 00000000001706f0
Call Trace:
<TASK>
? __die+0x23/0x80
? page_fault_oops+0xa4/0x180
? exc_page_fault+0x152/0x180
? asm_exc_page_fault+0x26/0x40
? rcu_tasks_need_gpcb+0x25d/0x2c0
? __pfx_rcu_tasks_kthread+0x40/0x40
rcu_tasks_one_gp+0x69/0x180
rcu_tasks_kthread+0x94/0xc0
kthread+0xe8/0x140
? __pfx_kthread+0x40/0x40
ret_from_fork+0x34/0x80
? __pfx_kthread+0x40/0x40
ret_from_fork_asm+0x1b/0x80
</TASK>

Considering that there may be holes in the CPU numbers, use the
maximum possible cpu number, instead of nr_cpu_ids, for configuring
enqueue and dequeue limits.

[ neeraj.upadhyay: Fix htmldocs build error reported by Stephen Rothwell ]</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('d0ded53ed90041827077091a1db49ecb836cd473')">
                                    <div class="issue-number">368</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="d0ded53ed90041827077091a1db49ecb836cd473">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

wifi: iwlwifi: mvm: avoid NULL pointer dereference

iwl_mvm_tx_skb_sta() and iwl_mvm_tx_mpdu() verify that the mvmvsta
pointer is not NULL.
It retrieves this pointer using iwl_mvm_sta_from_mac80211, which is
dereferencing the ieee80211_sta pointer.
If sta is NULL, iwl_mvm_sta_from_mac80211 will dereference a NULL
pointer.
Fix this by checking the sta pointer before retrieving the mvmsta
from it. If sta is not NULL, then mvmsta isn't either.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('2f541b543b6e1b4942faf95fd950431006dd6301')">
                                    <div class="issue-number">369</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="2f541b543b6e1b4942faf95fd950431006dd6301">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

btrfs: don't readahead the relocation inode on RST

On relocation we're doing readahead on the relocation inode, but if the
filesystem is backed by a RAID stripe tree we can get ENOENT (e.g. due to
preallocated extents not being mapped in the RST) from the lookup.

But readahead doesn't handle the error and submits invalid reads to the
device, causing an assertion in the scatter-gather list code:

  BTRFS info (device nvme1n1): balance: start -d -m -s
  BTRFS info (device nvme1n1): relocating block group 6480920576 flags data|raid0
  BTRFS error (device nvme1n1): cannot find raid-stripe for logical [6481928192, 6481969152] devid 2, profile raid0
  ------------[ cut here ]------------
  kernel BUG at include/linux/scatterlist.h:115!
  Oops: invalid opcode: 0000 [#1] PREEMPT SMP PTI
  CPU: 0 PID: 1012 Comm: btrfs Not tainted 6.10.0-rc7+ #567
  RIP: 0010:__blk_rq_map_sg+0x339/0x4a0
  RSP: 0018:ffffc90001a43820 EFLAGS: 00010202
  RAX: 0000000000000000 RBX: 0000000000000000 RCX: ffffea00045d4802
  RDX: 0000000117520000 RSI: 0000000000000000 RDI: ffff8881027d1000
  RBP: 0000000000003000 R08: ffffea00045d4902 R09: 0000000000000000
  R10: 0000000000000000 R11: 0000000000001000 R12: ffff8881003d10b8
  R13: ffffc90001a438f0 R14: 0000000000000000 R15: 0000000000003000
  FS:  00007fcc048a6900(0000) GS:ffff88813bc00000(0000) knlGS:0000000000000000
  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
  CR2: 000000002cd11000 CR3: 00000001109ea001 CR4: 0000000000370eb0
  Call Trace:
   <TASK>
   ? __die_body.cold+0x14/0x25
   ? die+0x2e/0x50
   ? do_trap+0xca/0x110
   ? do_error_trap+0x65/0x80
   ? __blk_rq_map_sg+0x339/0x4a0
   ? exc_invalid_op+0x50/0x70
   ? __blk_rq_map_sg+0x339/0x4a0
   ? asm_exc_invalid_op+0x1a/0x20
   ? __blk_rq_map_sg+0x339/0x4a0
   nvme_prep_rq.part.0+0x9d/0x770
   nvme_queue_rq+0x7d/0x1e0
   __blk_mq_issue_directly+0x2a/0x90
   ? blk_mq_get_budget_and_tag+0x61/0x90
   blk_mq_try_issue_list_directly+0x56/0xf0
   blk_mq_flush_plug_list.part.0+0x52b/0x5d0
   __blk_flush_plug+0xc6/0x110
   blk_finish_plug+0x28/0x40
   read_pages+0x160/0x1c0
   page_cache_ra_unbounded+0x109/0x180
   relocate_file_extent_cluster+0x611/0x6a0
   ? btrfs_search_slot+0xba4/0xd20
   ? balance_dirty_pages_ratelimited_flags+0x26/0xb00
   relocate_data_extent.constprop.0+0x134/0x160
   relocate_block_group+0x3f2/0x500
   btrfs_relocate_block_group+0x250/0x430
   btrfs_relocate_chunk+0x3f/0x130
   btrfs_balance+0x71b/0xef0
   ? kmalloc_trace_noprof+0x13b/0x280
   btrfs_ioctl+0x2c2e/0x3030
   ? kvfree_call_rcu+0x1e6/0x340
   ? list_lru_add_obj+0x66/0x80
   ? mntput_no_expire+0x3a/0x220
   __x64_sys_ioctl+0x96/0xc0
   do_syscall_64+0x54/0x110
   entry_SYSCALL_64_after_hwframe+0x76/0x7e
  RIP: 0033:0x7fcc04514f9b
  Code: Unable to access opcode bytes at 0x7fcc04514f71.
  RSP: 002b:00007ffeba923370 EFLAGS: 00000246 ORIG_RAX: 0000000000000010
  RAX: ffffffffffffffda RBX: 0000000000000003 RCX: 00007fcc04514f9b
  RDX: 00007ffeba923460 RSI: 00000000c4009420 RDI: 0000000000000003
  RBP: 0000000000000000 R08: 0000000000000013 R09: 0000000000000001
  R10: 00007fcc043fbba8 R11: 0000000000000246 R12: 00007ffeba924fc5
  R13: 00007ffeba923460 R14: 0000000000000002 R15: 00000000004d4bb0
   </TASK>
  Modules linked in:
  ---[ end trace 0000000000000000 ]---
  RIP: 0010:__blk_rq_map_sg+0x339/0x4a0
  RSP: 0018:ffffc90001a43820 EFLAGS: 00010202
  RAX: 0000000000000000 RBX: 0000000000000000 RCX: ffffea00045d4802
  RDX: 0000000117520000 RSI: 0000000000000000 RDI: ffff8881027d1000
  RBP: 0000000000003000 R08: ffffea00045d4902 R09: 0000000000000000
  R10: 0000000000000000 R11: 0000000000001000 R12: ffff8881003d10b8
  R13: ffffc90001a438f0 R14: 0000000000000000 R15: 0000000000003000
  FS:  00007fcc048a6900(0000) GS:ffff88813bc00000(0000) knlGS:0000000000000000
  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
  CR2: 00007fcc04514f71 CR3: 00000001109ea001 CR4: 0000000000370eb0
  Kernel p
---truncated---</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('1de3fa8cc8c11f68f208026575939f0ec0eb8424')">
                                    <div class="issue-number">370</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="1de3fa8cc8c11f68f208026575939f0ec0eb8424">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

fs/inode: Prevent dump_mapping() accessing invalid dentry.d_name.name

It's observed that a crash occurs during hot-remove a memory device,
in which user is accessing the hugetlb. See calltrace as following:

------------[ cut here ]------------
WARNING: CPU: 1 PID: 14045 at arch/x86/mm/fault.c:1278 do_user_addr_fault+0x2a0/0x790
Modules linked in: kmem device_dax cxl_mem cxl_pmem cxl_port cxl_pci dax_hmem dax_pmem nd_pmem cxl_acpi nd_btt cxl_core crc32c_intel nvme virtiofs fuse nvme_core nfit libnvdimm dm_multipath scsi_dh_rdac scsi_dh_emc s
mirror dm_region_hash dm_log dm_mod
CPU: 1 PID: 14045 Comm: daxctl Not tainted 6.10.0-rc2-lizhijian+ #492
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org 04/01/2014
RIP: 0010:do_user_addr_fault+0x2a0/0x790
Code: 48 8b 00 a8 04 0f 84 b5 fe ff ff e9 1c ff ff ff 4c 89 e9 4c 89 e2 be 01 00 00 00 bf 02 00 00 00 e8 b5 ef 24 00 e9 42 fe ff ff <0f> 0b 48 83 c4 08 4c 89 ea 48 89 ee 4c 89 e7 5b 5d 41 5c 41 5d 41
RSP: 0000:ffffc90000a575f0 EFLAGS: 00010046
RAX: ffff88800c303600 RBX: 0000000000000000 RCX: 0000000000000000
RDX: 0000000000001000 RSI: ffffffff82504162 RDI: ffffffff824b2c36
RBP: 0000000000000000 R08: 0000000000000000 R09: 0000000000000000
R10: 0000000000000000 R11: 0000000000000000 R12: ffffc90000a57658
R13: 0000000000001000 R14: ffff88800bc2e040 R15: 0000000000000000
FS:  00007f51cb57d880(0000) GS:ffff88807fd00000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 0000000000001000 CR3: 00000000072e2004 CR4: 00000000001706f0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
Call Trace:
 <TASK>
 ? __warn+0x8d/0x190
 ? do_user_addr_fault+0x2a0/0x790
 ? report_bug+0x1c3/0x1d0
 ? handle_bug+0x3c/0x70
 ? exc_invalid_op+0x14/0x70
 ? asm_exc_invalid_op+0x16/0x20
 ? do_user_addr_fault+0x2a0/0x790
 ? exc_page_fault+0x31/0x200
 exc_page_fault+0x68/0x200
<...snip...>
BUG: unable to handle page fault for address: 0000000000001000
 #PF: supervisor read access in kernel mode
 #PF: error_code(0x0000) - not-present page
 PGD 800000000ad92067 P4D 800000000ad92067 PUD 7677067 PMD 0
 Oops: Oops: 0000 [#1] PREEMPT SMP PTI
 ---[ end trace 0000000000000000 ]---
 BUG: unable to handle page fault for address: 0000000000001000
 #PF: supervisor read access in kernel mode
 #PF: error_code(0x0000) - not-present page
 PGD 800000000ad92067 P4D 800000000ad92067 PUD 7677067 PMD 0
 Oops: Oops: 0000 [#1] PREEMPT SMP PTI
 CPU: 1 PID: 14045 Comm: daxctl Kdump: loaded Tainted: G        W          6.10.0-rc2-lizhijian+ #492
 Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org 04/01/2014
 RIP: 0010:dentry_name+0x1f4/0x440
<...snip...>
? dentry_name+0x2fa/0x440
vsnprintf+0x1f3/0x4f0
vprintk_store+0x23a/0x540
vprintk_emit+0x6d/0x330
_printk+0x58/0x80
dump_mapping+0x10b/0x1a0
? __pfx_free_object_rcu+0x10/0x10
__dump_page+0x26b/0x3e0
? vprintk_emit+0xe0/0x330
? _printk+0x58/0x80
? dump_page+0x17/0x50
dump_page+0x17/0x50
do_migrate_range+0x2f7/0x7f0
? do_migrate_range+0x42/0x7f0
? offline_pages+0x2f4/0x8c0
offline_pages+0x60a/0x8c0
memory_subsys_offline+0x9f/0x1c0
? lockdep_hardirqs_on+0x77/0x100
? _raw_spin_unlock_irqrestore+0x38/0x60
device_offline+0xe3/0x110
state_store+0x6e/0xc0
kernfs_fop_write_iter+0x143/0x200
vfs_write+0x39f/0x560
ksys_write+0x65/0xf0
do_syscall_64+0x62/0x130

Previously, some sanity check have been done in dump_mapping() before
the print facility parsing '%pd' though, it's still possible to run into
an invalid dentry.d_name.name.

Since dump_mapping() only needs to dump the filename only, retrieve it
by itself in a safer way to prevent an unnecessary crash.

Note that either retrieving the filename with '%pd' or
strncpy_from_kernel_nofault(), the filename could be unreliable.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('945ef09a42642c4d2eba82ce82c2a260347b26b7')">
                                    <div class="issue-number">371</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="945ef09a42642c4d2eba82ce82c2a260347b26b7">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

wifi: rtw89: avoid to add interface to list twice when SER

If SER L2 occurs during the WoWLAN resume flow, the add interface flow
is triggered by ieee80211_reconfig(). However, due to
rtw89_wow_resume() return failure, it will cause the add interface flow
to be executed again, resulting in a double add list and causing a kernel
panic. Therefore, we have added a check to prevent double adding of the
list.

list_add double add: new=ffff99d6992e2010, prev=ffff99d6992e2010, next=ffff99d695302628.
------------[ cut here ]------------
kernel BUG at lib/list_debug.c:37!
invalid opcode: 0000 [#1] PREEMPT SMP NOPTI
CPU: 0 PID: 9 Comm: kworker/0:1 Tainted: G        W  O       6.6.30-02659-gc18865c4dfbd #1 770df2933251a0e3c888ba69d1053a817a6376a7
Hardware name: HP Grunt/Grunt, BIOS Google_Grunt.11031.169.0 06/24/2021
Workqueue: events_freezable ieee80211_restart_work [mac80211]
RIP: 0010:__list_add_valid_or_report+0x5e/0xb0
Code: c7 74 18 48 39 ce 74 13 b0 01 59 5a 5e 5f 41 58 41 59 41 5a 5d e9 e2 d6 03 00 cc 48 c7 c7 8d 4f 17 83 48 89 c2 e8 02 c0 00 00 <0f> 0b 48 c7 c7 aa 8c 1c 83 e8 f4 bf 00 00 0f 0b 48 c7 c7 c8 bc 12
RSP: 0018:ffffa91b8007bc50 EFLAGS: 00010246
RAX: 0000000000000058 RBX: ffff99d6992e0900 RCX: a014d76c70ef3900
RDX: ffffa91b8007bae8 RSI: 00000000ffffdfff RDI: 0000000000000001
RBP: ffffa91b8007bc88 R08: 0000000000000000 R09: ffffa91b8007bae0
R10: 00000000ffffdfff R11: ffffffff83a79800 R12: ffff99d695302060
R13: ffff99d695300900 R14: ffff99d6992e1be0 R15: ffff99d6992e2010
FS:  0000000000000000(0000) GS:ffff99d6aac00000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 000078fbdba43480 CR3: 000000010e464000 CR4: 00000000001506f0
Call Trace:
 <TASK>
 ? __die_body+0x1f/0x70
 ? die+0x3d/0x60
 ? do_trap+0xa4/0x110
 ? __list_add_valid_or_report+0x5e/0xb0
 ? do_error_trap+0x6d/0x90
 ? __list_add_valid_or_report+0x5e/0xb0
 ? handle_invalid_op+0x30/0x40
 ? __list_add_valid_or_report+0x5e/0xb0
 ? exc_invalid_op+0x3c/0x50
 ? asm_exc_invalid_op+0x16/0x20
 ? __list_add_valid_or_report+0x5e/0xb0
 rtw89_ops_add_interface+0x309/0x310 [rtw89_core 7c32b1ee6854761c0321027c8a58c5160e41f48f]
 drv_add_interface+0x5c/0x130 [mac80211 83e989e6e616bd5b4b8a2b0a9f9352a2c385a3bc]
 ieee80211_reconfig+0x241/0x13d0 [mac80211 83e989e6e616bd5b4b8a2b0a9f9352a2c385a3bc]
 ? finish_wait+0x3e/0x90
 ? synchronize_rcu_expedited+0x174/0x260
 ? sync_rcu_exp_done_unlocked+0x50/0x50
 ? wake_bit_function+0x40/0x40
 ieee80211_restart_work+0xf0/0x140 [mac80211 83e989e6e616bd5b4b8a2b0a9f9352a2c385a3bc]
 process_scheduled_works+0x1e5/0x480
 worker_thread+0xea/0x1e0
 kthread+0xdb/0x110
 ? move_linked_works+0x90/0x90
 ? kthread_associate_blkcg+0xa0/0xa0
 ret_from_fork+0x3b/0x50
 ? kthread_associate_blkcg+0xa0/0xa0
 ret_from_fork_asm+0x11/0x20
 </TASK>
Modules linked in: dm_integrity async_xor xor async_tx lz4 lz4_compress zstd zstd_compress zram zsmalloc rfcomm cmac uinput algif_hash algif_skcipher af_alg btusb btrtl iio_trig_hrtimer industrialio_sw_trigger btmtk industrialio_configfs btbcm btintel uvcvideo videobuf2_vmalloc iio_trig_sysfs videobuf2_memops videobuf2_v4l2 videobuf2_common uvc snd_hda_codec_hdmi veth snd_hda_intel snd_intel_dspcfg acpi_als snd_hda_codec industrialio_triggered_buffer kfifo_buf snd_hwdep industrialio i2c_piix4 snd_hda_core designware_i2s ip6table_nat snd_soc_max98357a xt_MASQUERADE xt_cgroup snd_soc_acp_rt5682_mach fuse rtw89_8922ae(O) rtw89_8922a(O) rtw89_pci(O) rtw89_core(O) 8021q mac80211(O) bluetooth ecdh_generic ecc cfg80211 r8152 mii joydev
gsmi: Log Shutdown Reason 0x03
---[ end trace 0000000000000000 ]---</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('79a2331af0708495dfc18d0e3648949dae2dca98')">
                                    <div class="issue-number">372</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="79a2331af0708495dfc18d0e3648949dae2dca98">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

l2tp: prevent possible tunnel refcount underflow

When a session is created, it sets a backpointer to its tunnel. When
the session refcount drops to 0, l2tp_session_free drops the tunnel
refcount if session->tunnel is non-NULL. However, session->tunnel is
set in l2tp_session_create, before the tunnel refcount is incremented
by l2tp_session_register, which leaves a small window where
session->tunnel is non-NULL when the tunnel refcount hasn't been
bumped.

Moving the assignment to l2tp_session_register is trivial but
l2tp_session_create calls l2tp_session_set_header_len which uses
session->tunnel to get the tunnel's encap. Add an encap arg to
l2tp_session_set_header_len to avoid using session->tunnel.

If l2tpv3 sessions have colliding IDs, it is possible for
l2tp_v3_session_get to race with l2tp_session_register and fetch a
session which doesn't yet have session->tunnel set. Add a check for
this case.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('5a77331c519b72fedd43cc57cc42c8bfe567a84d')">
                                    <div class="issue-number">373</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="5a77331c519b72fedd43cc57cc42c8bfe567a84d">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

net/ncsi: Disable the ncsi work before freeing the associated structure

The work function can run after the ncsi device is freed, resulting
in use-after-free bugs or kernel panic.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('08691ea1ecf20e6659ab249f8a48e5d199879496')">
                                    <div class="issue-number">374</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="08691ea1ecf20e6659ab249f8a48e5d199879496">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

Bluetooth: MGMT: Fix possible crash on mgmt_index_removed

If mgmt_index_removed is called while there are commands queued on
cmd_sync it could lead to crashes like the bellow trace:

0x0000053D: __list_del_entry_valid_or_report+0x98/0xdc
0x0000053D: mgmt_pending_remove+0x18/0x58 [bluetooth]
0x0000053E: mgmt_remove_adv_monitor_complete+0x80/0x108 [bluetooth]
0x0000053E: hci_cmd_sync_work+0xbc/0x164 [bluetooth]

So while handling mgmt_index_removed this attempts to dequeue
commands passed as user_data to cmd_sync.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('4da562f23f96b0291f91ffe2595c766e9938ca2f')">
                                    <div class="issue-number">375</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="4da562f23f96b0291f91ffe2595c766e9938ca2f">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

ext4: filesystems without casefold feature cannot be mounted with siphash

When mounting the ext4 filesystem, if the default hash version is set to
DX_HASH_SIPHASH but the casefold feature is not set, exit the mounting.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('c6889167ac41d281a2ba32c048e1112215b32b46')">
                                    <div class="issue-number">376</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="c6889167ac41d281a2ba32c048e1112215b32b46">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Implement bounds check for stream encoder creation in DCN401

'stream_enc_regs' array is an array of dcn10_stream_enc_registers
structures. The array is initialized with four elements, corresponding
to the four calls to stream_enc_regs() in the array initializer. This
means that valid indices for this array are 0, 1, 2, and 3.

The error message 'stream_enc_regs' 4 <= 5 below, is indicating that
there is an attempt to access this array with an index of 5, which is
out of bounds. This could lead to undefined behavior

Here, eng_id is used as an index to access the stream_enc_regs array. If
eng_id is 5, this would result in an out-of-bounds access on the
stream_enc_regs array.

Thus fixing Buffer overflow error in dcn401_stream_encoder_create

Found by smatch:
drivers/gpu/drm/amd/amdgpu/../display/dc/resource/dcn401/dcn401_resource.c:1209 dcn401_stream_encoder_create() error: buffer overflow 'stream_enc_regs' 4 <= 5</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('569698a8f86252b29f3cf773191af7fb27ad9743')">
                                    <div class="issue-number">377</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="569698a8f86252b29f3cf773191af7fb27ad9743">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Increase array size of dummy_boolean

[WHY]
dml2_core_shared_mode_support and dml_core_mode_support access the third
element of dummy_boolean, i.e. hw_debug5 = &s->dummy_boolean[2], when
dummy_boolean has size of 2. Any assignment to hw_debug5 causes an
OVERRUN.

[HOW]
Increase dummy_boolean's array size to 3.

This fixes 2 OVERRUN issues reported by Coverity.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('e9c91ce9e63814754ef245f21a977968e1d7e76e')">
                                    <div class="issue-number">378</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="e9c91ce9e63814754ef245f21a977968e1d7e76e">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Deallocate DML memory if allocation fails

[Why]
When DC state create DML memory allocation fails, memory is not
deallocated subsequently, resulting in uninitialized structure
that is not NULL.

[How]
Deallocate memory if DML memory allocation fails.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('6bb0731cd1b4e4b87fde6964bfa1614f6281aca1')">
                                    <div class="issue-number">379</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="6bb0731cd1b4e4b87fde6964bfa1614f6281aca1">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

bpftool: Fix undefined behavior in qsort(NULL, 0, ...)

When netfilter has no entry to display, qsort is called with
qsort(NULL, 0, ...). This results in undefined behavior, as UBSan
reports:

net.c:827:2: runtime error: null pointer passed as argument 1, which is declared to never be null

Although the C standard does not explicitly state whether calling qsort
with a NULL pointer when the size is 0 constitutes undefined behavior,
Section 7.1.4 of the C standard (Use of library functions) mentions:

"Each of the following statements applies unless explicitly stated
otherwise in the detailed descriptions that follow: If an argument to a
function has an invalid value (such as a value outside the domain of
the function, or a pointer outside the address space of the program, or
a null pointer, or a pointer to non-modifiable storage when the
corresponding parameter is not const-qualified) or a type (after
promotion) not expected by a function with variable number of
arguments, the behavior is undefined."

To avoid this, add an early return when nf_link_info is NULL to prevent
calling qsort with a NULL pointer.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('ac6217fd3de21132de21d6dc18bc1f902090489c')">
                                    <div class="issue-number">380</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="ac6217fd3de21132de21d6dc18bc1f902090489c">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

ksmbd: add refcnt to ksmbd_conn struct

When sending an oplock break request, opinfo->conn is used,
But freed ->conn can be used on multichannel.
This patch add a reference count to the ksmbd_conn struct
so that it can be freed when it is no longer used.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('828cc4e648d40e5aadb5827d5dbe474b2794889d')">
                                    <div class="issue-number">381</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="828cc4e648d40e5aadb5827d5dbe474b2794889d">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

block: fix integer overflow in BLKSECDISCARD

I independently rediscovered

	commit 22d24a544b0d49bbcbd61c8c0eaf77d3c9297155
	block: fix overflow in blk_ioctl_discard()

but for secure erase.

Same problem:

	uint64_t r[2] = {512, 18446744073709551104ULL};
	ioctl(fd, BLKSECDISCARD, r);

will enter near infinite loop inside blkdev_issue_secure_erase():

	a.out: attempt to access beyond end of device
	loop0: rw=5, sector=3399043073, nr_sectors = 1024 limit=2048
	bio_check_eod: 3286214 callbacks suppressed</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('496f66758cbcfef6e172c5cacf11d9daf7b06039')">
                                    <div class="issue-number">382</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="496f66758cbcfef6e172c5cacf11d9daf7b06039">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

net: dsa: improve shutdown sequence

Alexander Sverdlin presents 2 problems during shutdown with the
lan9303 driver. One is specific to lan9303 and the other just happens
to reproduce there.

The first problem is that lan9303 is unique among DSA drivers in that it
calls dev_get_drvdata() at "arbitrary runtime" (not probe, not shutdown,
not remove):

phy_state_machine()
-> ...
   -> dsa_user_phy_read()
      -> ds->ops->phy_read()
         -> lan9303_phy_read()
            -> chip->ops->phy_read()
               -> lan9303_mdio_phy_read()
                  -> dev_get_drvdata()

But we never stop the phy_state_machine(), so it may continue to run
after dsa_switch_shutdown(). Our common pattern in all DSA drivers is
to set drvdata to NULL to suppress the remove() method that may come
afterwards. But in this case it will result in an NPD.

The second problem is that the way in which we set
dp->conduit->dsa_ptr = NULL; is concurrent with receive packet
processing. dsa_switch_rcv() checks once whether dev->dsa_ptr is NULL,
but afterwards, rather than continuing to use that non-NULL value,
dev->dsa_ptr is dereferenced again and again without NULL checks:
dsa_conduit_find_user() and many other places. In between dereferences,
there is no locking to ensure that what was valid once continues to be
valid.

Both problems have the common aspect that closing the conduit interface
solves them.

In the first case, dev_close(conduit) triggers the NETDEV_GOING_DOWN
event in dsa_user_netdevice_event() which closes user ports as well.
dsa_port_disable_rt() calls phylink_stop(), which synchronously stops
the phylink state machine, and ds->ops->phy_read() will thus no longer
call into the driver after this point.

In the second case, dev_close(conduit) should do this, as per
Documentation/networking/driver.rst:

| Quiescence
| ----------
|
| After the ndo_stop routine has been called, the hardware must
| not receive or transmit any data.  All in flight packets must
| be aborted. If necessary, poll or wait for completion of
| any reset commands.

So it should be sufficient to ensure that later, when we zeroize
conduit->dsa_ptr, there will be no concurrent dsa_switch_rcv() call
on this conduit.

The addition of the netif_device_detach() function is to ensure that
ioctls, rtnetlinks and ethtool requests on the user ports no longer
propagate down to the driver - we're no longer prepared to handle them.

The race condition actually did not exist when commit 0650bf52b31f
("net: dsa: be compatible with masters which unregister on shutdown")
first introduced dsa_switch_shutdown(). It was created later, when we
stopped unregistering the user interfaces from a bad spot, and we just
replaced that sequence with a racy zeroization of conduit->dsa_ptr
(one which doesn't ensure that the interfaces aren't up).</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('82682f63bc7c8ab26dffe1255f137932d5599b38')">
                                    <div class="issue-number">383</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="82682f63bc7c8ab26dffe1255f137932d5599b38">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: update DML2 policy EnhancedPrefetchScheduleAccelerationFinal DCN35

[WHY & HOW]
Mismatch in DCN35 DML2 cause bw validation failed to acquire unexpected DPP pipe to cause
grey screen and system hang. Remove EnhancedPrefetchScheduleAccelerationFinal value override
to match HW spec.

(cherry picked from commit 9dad21f910fcea2bdcff4af46159101d7f9cd8ba)</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('9665fd803f2b9aec741c58abc25bdddb245ca003')">
                                    <div class="issue-number">384</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="9665fd803f2b9aec741c58abc25bdddb245ca003">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

cpufreq: amd-pstate: add check for cpufreq_cpu_get's return value

cpufreq_cpu_get may return NULL. To avoid NULL-dereference check it
and return in case of error.

Found by Linux Verification Center (linuxtesting.org) with SVACE.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('f17916ff28d96ca93fac99eb223b4826f4e557f7')">
                                    <div class="issue-number">385</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="f17916ff28d96ca93fac99eb223b4826f4e557f7">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

ext4: fix access to uninitialised lock in fc replay path

The following kernel trace can be triggered with fstest generic/629 when
executed against a filesystem with fast-commit feature enabled:

INFO: trying to register non-static key.
The code is fine but needs lockdep annotation, or maybe
you didn't initialize this object before use?
turning off the locking correctness validator.
CPU: 0 PID: 866 Comm: mount Not tainted 6.10.0+ #11
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.2-3-gd478f380-prebuilt.qemu.org 04/01/2014
Call Trace:
 <TASK>
 dump_stack_lvl+0x66/0x90
 register_lock_class+0x759/0x7d0
 __lock_acquire+0x85/0x2630
 ? __find_get_block+0xb4/0x380
 lock_acquire+0xd1/0x2d0
 ? __ext4_journal_get_write_access+0xd5/0x160
 _raw_spin_lock+0x33/0x40
 ? __ext4_journal_get_write_access+0xd5/0x160
 __ext4_journal_get_write_access+0xd5/0x160
 ext4_reserve_inode_write+0x61/0xb0
 __ext4_mark_inode_dirty+0x79/0x270
 ? ext4_ext_replay_set_iblocks+0x2f8/0x450
 ext4_ext_replay_set_iblocks+0x330/0x450
 ext4_fc_replay+0x14c8/0x1540
 ? jread+0x88/0x2e0
 ? rcu_is_watching+0x11/0x40
 do_one_pass+0x447/0xd00
 jbd2_journal_recover+0x139/0x1b0
 jbd2_journal_load+0x96/0x390
 ext4_load_and_init_journal+0x253/0xd40
 ext4_fill_super+0x2cc6/0x3180
...

In the replay path there's an attempt to lock sbi->s_bdev_wb_lock in
function ext4_check_bdev_write_error().  Unfortunately, at this point this
spinlock has not been initialized yet.  Moving it's initialization to an
earlier point in __ext4_fill_super() fixes this splat.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('011fba9ea4fd90621e74550cb48d09c9257cdead')">
                                    <div class="issue-number">386</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="011fba9ea4fd90621e74550cb48d09c9257cdead">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Avoid overflow assignment in link_dp_cts

sampling_rate is an uint8_t but is assigned an unsigned int, and thus it
can overflow. As a result, sampling_rate is changed to uint32_t.

Similarly, LINK_QUAL_PATTERN_SET has a size of 2 bits, and it should
only be assigned to a value less or equal than 4.

This fixes 2 INTEGER_OVERFLOW issues reported by Coverity.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('67632e9a5836661bb3c318481cc3c80c9ebb438d')">
                                    <div class="issue-number">387</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="67632e9a5836661bb3c318481cc3c80c9ebb438d">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

x86/mm/ident_map: Use gbpages only where full GB page should be mapped.

When ident_pud_init() uses only GB pages to create identity maps, large
ranges of addresses not actually requested can be included in the resulting
table; a 4K request will map a full GB.  This can include a lot of extra
address space past that requested, including areas marked reserved by the
BIOS.  That allows processor speculation into reserved regions, that on UV
systems can cause system halts.

Only use GB pages when map creation requests include the full GB page of
space.  Fall back to using smaller 2M pages when only portions of a GB page
are included in the request.

No attempt is made to coalesce mapping requests. If a request requires a
map entry at the 2M (pmd) level, subsequent mapping requests within the
same 1G region will also be at the pmd level, even if adjacent or
overlapping such requests could have been combined to map a full GB page.
Existing usage starts with larger regions and then adds smaller regions, so
this should not have any great consequence.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('6eb00784af815cf2e37bf09bb7e6ab33afa12edd')">
                                    <div class="issue-number">388</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="6eb00784af815cf2e37bf09bb7e6ab33afa12edd">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

net: napi: Prevent overflow of napi_defer_hard_irqs

In commit 6f8b12d661d0 ("net: napi: add hard irqs deferral feature")
napi_defer_irqs was added to net_device and napi_defer_irqs_count was
added to napi_struct, both as type int.

This value never goes below zero, so there is not reason for it to be a
signed int. Change the type for both from int to u32, and add an
overflow check to sysfs to limit the value to S32_MAX.

The limit of S32_MAX was chosen because the practical limit before this
patch was S32_MAX (anything larger was an overflow) and thus there are
no behavioral changes introduced. If the extra bit is needed in the
future, the limit can be raised.

Before this patch:

$ sudo bash -c 'echo 2147483649 > /sys/class/net/eth4/napi_defer_hard_irqs'
$ cat /sys/class/net/eth4/napi_defer_hard_irqs
-2147483647

After this patch:

$ sudo bash -c 'echo 2147483649 > /sys/class/net/eth4/napi_defer_hard_irqs'
bash: line 0: echo: write error: Numerical result out of range

Similarly, /sys/class/net/XXXXX/tx_queue_len is defined as unsigned:

include/linux/netdevice.h:      unsigned int            tx_queue_len;

And has an overflow check:

dev_change_tx_queue_len(..., unsigned long new_len):

  if (new_len != (unsigned int)new_len)
          return -ERANGE;</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('75e9bc45f17c06bcc234a5e4693606c092d5edeb')">
                                    <div class="issue-number">389</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="75e9bc45f17c06bcc234a5e4693606c092d5edeb">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

thermal: core: Reference count the zone in thermal_zone_get_by_id()

There are places in the thermal netlink code where nothing prevents
the thermal zone object from going away while being accessed after it
has been returned by thermal_zone_get_by_id().

To address this, make thermal_zone_get_by_id() get a reference on the
thermal zone device object to be returned with the help of get_device(),
under thermal_list_lock, and adjust all of its callers to this change
with the help of the cleanup.h infrastructure.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('2830b19d1c256d829dfc80dcc781fa9250f8a988')">
                                    <div class="issue-number">390</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="2830b19d1c256d829dfc80dcc781fa9250f8a988">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

rcu/nocb: Fix rcuog wake-up from offline softirq

After a CPU has set itself offline and before it eventually calls
rcutree_report_cpu_dead(), there are still opportunities for callbacks
to be enqueued, for example from a softirq. When that happens on NOCB,
the rcuog wake-up is deferred through an IPI to an online CPU in order
not to call into the scheduler and risk arming the RT-bandwidth after
hrtimers have been migrated out and disabled.

But performing a synchronized IPI from a softirq is buggy as reported in
the following scenario:

        WARNING: CPU: 1 PID: 26 at kernel/smp.c:633 smp_call_function_single
        Modules linked in: rcutorture torture
        CPU: 1 UID: 0 PID: 26 Comm: migration/1 Not tainted 6.11.0-rc1-00012-g9139f93209d1 #1
        Stopper: multi_cpu_stop+0x0/0x320 <- __stop_cpus+0xd0/0x120
        RIP: 0010:smp_call_function_single
        <IRQ>
        swake_up_one_online
        __call_rcu_nocb_wake
        __call_rcu_common
        ? rcu_torture_one_read
        call_timer_fn
        __run_timers
        run_timer_softirq
        handle_softirqs
        irq_exit_rcu
        ? tick_handle_periodic
        sysvec_apic_timer_interrupt
        </IRQ>

Fix this with forcing deferred rcuog wake up through the NOCB timer when
the CPU is offline. The actual wake up will happen from
rcutree_report_cpu_dead().</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('6c2d84a34a28ae5002c00794609fa3c733dc1b62')">
                                    <div class="issue-number">391</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="6c2d84a34a28ae5002c00794609fa3c733dc1b62">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

usb: gadget: uvc: Fix ERR_PTR dereference in uvc_v4l2.c

Fix potential dereferencing of ERR_PTR() in find_format_by_pix()
and uvc_v4l2_enum_format().

Fix the following smatch errors:

drivers/usb/gadget/function/uvc_v4l2.c:124 find_format_by_pix()
error: 'fmtdesc' dereferencing possible ERR_PTR()

drivers/usb/gadget/function/uvc_v4l2.c:392 uvc_v4l2_enum_format()
error: 'fmtdesc' dereferencing possible ERR_PTR()

Also, fix similar issue in uvc_v4l2_try_format() for potential
dereferencing of ERR_PTR().</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('60cbeb0df9366b8a8a411ab9208a40cafe9ccded')">
                                    <div class="issue-number">392</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="60cbeb0df9366b8a8a411ab9208a40cafe9ccded">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

dm vdo: don't refer to dedupe_context after releasing it

Clear the dedupe_context pointer in a data_vio whenever ownership of
the context is lost, so that vdo can't examine it accidentally.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('fc931140934f44258a395e51d3203d0773908ade')">
                                    <div class="issue-number">393</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="fc931140934f44258a395e51d3203d0773908ade">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

LoongArch: Enable IRQ if do_ale() triggered in irq-enabled context

Unaligned access exception can be triggered in irq-enabled context such
as user mode, in this case do_ale() may call get_user() which may cause
sleep. Then we will get:

 BUG: sleeping function called from invalid context at arch/loongarch/kernel/access-helper.h:7
 in_atomic(): 0, irqs_disabled(): 1, non_block: 0, pid: 129, name: modprobe
 preempt_count: 0, expected: 0
 RCU nest depth: 0, expected: 0
 CPU: 0 UID: 0 PID: 129 Comm: modprobe Tainted: G        W          6.12.0-rc1+ #1723
 Tainted: [W]=WARN
 Stack : 9000000105e0bd48 0000000000000000 9000000003803944 9000000105e08000
         9000000105e0bc70 9000000105e0bc78 0000000000000000 0000000000000000
         9000000105e0bc78 0000000000000001 9000000185e0ba07 9000000105e0b890
         ffffffffffffffff 9000000105e0bc78 73924b81763be05b 9000000100194500
         000000000000020c 000000000000000a 0000000000000000 0000000000000003
         00000000000023f0 00000000000e1401 00000000072f8000 0000007ffbb0e260
         0000000000000000 0000000000000000 9000000005437650 90000000055d5000
         0000000000000000 0000000000000003 0000007ffbb0e1f0 0000000000000000
         0000005567b00490 0000000000000000 9000000003803964 0000007ffbb0dfec
         00000000000000b0 0000000000000007 0000000000000003 0000000000071c1d
         ...
 Call Trace:
 [<9000000003803964>] show_stack+0x64/0x1a0
 [<9000000004c57464>] dump_stack_lvl+0x74/0xb0
 [<9000000003861ab4>] __might_resched+0x154/0x1a0
 [<900000000380c96c>] emulate_load_store_insn+0x6c/0xf60
 [<9000000004c58118>] do_ale+0x78/0x180
 [<9000000003801bc8>] handle_ale+0x128/0x1e0

So enable IRQ if unaligned access exception is triggered in irq-enabled
context to fix it.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('b3101f8b9117a77af7ef199081453b0d3fddaeb7')">
                                    <div class="issue-number">394</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="b3101f8b9117a77af7ef199081453b0d3fddaeb7">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

nvme-pci: fix race condition between reset and nvme_dev_disable()

nvme_dev_disable() modifies the dev->online_queues field, therefore
nvme_pci_update_nr_queues() should avoid racing against it, otherwise
we could end up passing invalid values to blk_mq_update_nr_hw_queues().

 WARNING: CPU: 39 PID: 61303 at drivers/pci/msi/api.c:347
          pci_irq_get_affinity+0x187/0x210
 Workqueue: nvme-reset-wq nvme_reset_work [nvme]
 RIP: 0010:pci_irq_get_affinity+0x187/0x210
 Call Trace:
  <TASK>
  ? blk_mq_pci_map_queues+0x87/0x3c0
  ? pci_irq_get_affinity+0x187/0x210
  blk_mq_pci_map_queues+0x87/0x3c0
  nvme_pci_map_queues+0x189/0x460 [nvme]
  blk_mq_update_nr_hw_queues+0x2a/0x40
  nvme_reset_work+0x1be/0x2a0 [nvme]

Fix the bug by locking the shutdown_lock mutex before using
dev->online_queues. Give up if nvme_dev_disable() is running or if
it has been executed already.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('fa88d5d77629c52112f8a6944e5b0ab84bd7abcd')">
                                    <div class="issue-number">395</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="fa88d5d77629c52112f8a6944e5b0ab84bd7abcd">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

net/mlx5e: Don't call cleanup on profile rollback failure

When profile rollback fails in mlx5e_netdev_change_profile, the netdev
profile var is left set to NULL. Avoid a crash when unloading the driver
by not calling profile->cleanup in such a case.

This was encountered while testing, with the original trigger that
the wq rescuer thread creation got interrupted (presumably due to
Ctrl+C-ing modprobe), which gets converted to ENOMEM (-12) by
mlx5e_priv_init, the profile rollback also fails for the same reason
(signal still active) so the profile is left as NULL, leading to a crash
later in _mlx5e_remove.

 [  732.473932] mlx5_core 0000:08:00.1: E-Switch: Unload vfs: mode(OFFLOADS), nvfs(2), necvfs(0), active vports(2)
 [  734.525513] workqueue: Failed to create a rescuer kthread for wq "mlx5e": -EINTR
 [  734.557372] mlx5_core 0000:08:00.1: mlx5e_netdev_init_profile:6235:(pid 6086): mlx5e_priv_init failed, err=-12
 [  734.559187] mlx5_core 0000:08:00.1 eth3: mlx5e_netdev_change_profile: new profile init failed, -12
 [  734.560153] workqueue: Failed to create a rescuer kthread for wq "mlx5e": -EINTR
 [  734.589378] mlx5_core 0000:08:00.1: mlx5e_netdev_init_profile:6235:(pid 6086): mlx5e_priv_init failed, err=-12
 [  734.591136] mlx5_core 0000:08:00.1 eth3: mlx5e_netdev_change_profile: failed to rollback to orig profile, -12
 [  745.537492] BUG: kernel NULL pointer dereference, address: 0000000000000008
 [  745.538222] #PF: supervisor read access in kernel mode
<snipped>
 [  745.551290] Call Trace:
 [  745.551590]  <TASK>
 [  745.551866]  ? __die+0x20/0x60
 [  745.552218]  ? page_fault_oops+0x150/0x400
 [  745.555307]  ? exc_page_fault+0x79/0x240
 [  745.555729]  ? asm_exc_page_fault+0x22/0x30
 [  745.556166]  ? mlx5e_remove+0x6b/0xb0 [mlx5_core]
 [  745.556698]  auxiliary_bus_remove+0x18/0x30
 [  745.557134]  device_release_driver_internal+0x1df/0x240
 [  745.557654]  bus_remove_device+0xd7/0x140
 [  745.558075]  device_del+0x15b/0x3c0
 [  745.558456]  mlx5_rescan_drivers_locked.part.0+0xb1/0x2f0 [mlx5_core]
 [  745.559112]  mlx5_unregister_device+0x34/0x50 [mlx5_core]
 [  745.559686]  mlx5_uninit_one+0x46/0xf0 [mlx5_core]
 [  745.560203]  remove_one+0x4e/0xd0 [mlx5_core]
 [  745.560694]  pci_device_remove+0x39/0xa0
 [  745.561112]  device_release_driver_internal+0x1df/0x240
 [  745.561631]  driver_detach+0x47/0x90
 [  745.562022]  bus_remove_driver+0x84/0x100
 [  745.562444]  pci_unregister_driver+0x3b/0x90
 [  745.562890]  mlx5_cleanup+0xc/0x1b [mlx5_core]
 [  745.563415]  __x64_sys_delete_module+0x14d/0x2f0
 [  745.563886]  ? kmem_cache_free+0x1b0/0x460
 [  745.564313]  ? lockdep_hardirqs_on_prepare+0xe2/0x190
 [  745.564825]  do_syscall_64+0x6d/0x140
 [  745.565223]  entry_SYSCALL_64_after_hwframe+0x4b/0x53
 [  745.565725] RIP: 0033:0x7f1579b1288b</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('197b5c034574966814d5932a75dff59601ec7263')">
                                    <div class="issue-number">396</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="197b5c034574966814d5932a75dff59601ec7263">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

fsl/fman: Fix refcount handling of fman-related devices

In mac_probe() there are multiple calls to of_find_device_by_node(),
fman_bind() and fman_port_bind() which takes references to of_dev->dev.
Not all references taken by these calls are released later on error path
in mac_probe() and in mac_remove() which lead to reference leaks.

Add references release.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('6aaa2d9d1735b186bf7e807c9065f8af5a5b3fba')">
                                    <div class="issue-number">397</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="6aaa2d9d1735b186bf7e807c9065f8af5a5b3fba">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: fix a UBSAN warning in DML2.1

When programming phantom pipe, since cursor_width is explicity set to 0,
this causes calculation logic to trigger overflow for an unsigned int
triggering the kernel's UBSAN check as below:

[   40.962845] UBSAN: shift-out-of-bounds in /tmp/amd.EfpumTkO/amd/amdgpu/../display/dc/dml2/dml21/src/dml2_core/dml2_core_dcn4_calcs.c:3312:34
[   40.962849] shift exponent 4294967170 is too large for 32-bit type 'unsigned int'
[   40.962852] CPU: 1 PID: 1670 Comm: gnome-shell Tainted: G        W  OE      6.5.0-41-generic #41~22.04.2-Ubuntu
[   40.962854] Hardware name: Gigabyte Technology Co., Ltd. X670E AORUS PRO X/X670E AORUS PRO X, BIOS F21 01/10/2024
[   40.962856] Call Trace:
[   40.962857]  <TASK>
[   40.962860]  dump_stack_lvl+0x48/0x70
[   40.962870]  dump_stack+0x10/0x20
[   40.962872]  __ubsan_handle_shift_out_of_bounds+0x1ac/0x360
[   40.962878]  calculate_cursor_req_attributes.cold+0x1b/0x28 [amdgpu]
[   40.963099]  dml_core_mode_support+0x6b91/0x16bc0 [amdgpu]
[   40.963327]  ? srso_alias_return_thunk+0x5/0x7f
[   40.963331]  ? CalculateWatermarksMALLUseAndDRAMSpeedChangeSupport+0x18b8/0x2790 [amdgpu]
[   40.963534]  ? srso_alias_return_thunk+0x5/0x7f
[   40.963536]  ? dml_core_mode_support+0xb3db/0x16bc0 [amdgpu]
[   40.963730]  dml2_core_calcs_mode_support_ex+0x2c/0x90 [amdgpu]
[   40.963906]  ? srso_alias_return_thunk+0x5/0x7f
[   40.963909]  ? dml2_core_calcs_mode_support_ex+0x2c/0x90 [amdgpu]
[   40.964078]  core_dcn4_mode_support+0x72/0xbf0 [amdgpu]
[   40.964247]  dml2_top_optimization_perform_optimization_phase+0x1d3/0x2a0 [amdgpu]
[   40.964420]  dml2_build_mode_programming+0x23d/0x750 [amdgpu]
[   40.964587]  dml21_validate+0x274/0x770 [amdgpu]
[   40.964761]  ? srso_alias_return_thunk+0x5/0x7f
[   40.964763]  ? resource_append_dpp_pipes_for_plane_composition+0x27c/0x3b0 [amdgpu]
[   40.964942]  dml2_validate+0x504/0x750 [amdgpu]
[   40.965117]  ? dml21_copy+0x95/0xb0 [amdgpu]
[   40.965291]  ? srso_alias_return_thunk+0x5/0x7f
[   40.965295]  dcn401_validate_bandwidth+0x4e/0x70 [amdgpu]
[   40.965491]  update_planes_and_stream_state+0x38d/0x5c0 [amdgpu]
[   40.965672]  update_planes_and_stream_v3+0x52/0x1e0 [amdgpu]
[   40.965845]  ? srso_alias_return_thunk+0x5/0x7f
[   40.965849]  dc_update_planes_and_stream+0x71/0xb0 [amdgpu]

Fix this by adding a guard for checking cursor width before triggering
the size calculation.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('39699207863727761594a8710172dfd972ede899')">
                                    <div class="issue-number">398</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="39699207863727761594a8710172dfd972ede899">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

cpufreq: loongson3: Use raw_smp_processor_id() in do_service_request()

Use raw_smp_processor_id() instead of plain smp_processor_id() in
do_service_request(), otherwise we may get some errors with the driver
enabled:

 BUG: using smp_processor_id() in preemptible [00000000] code: (udev-worker)/208
 caller is loongson3_cpufreq_probe+0x5c/0x250 [loongson3_cpufreq]</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('9d2f66adc779137f509cf0795b8f66bf61fbd680')">
                                    <div class="issue-number">399</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="9d2f66adc779137f509cf0795b8f66bf61fbd680">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

ntfs3: Add bounds checking to mi_enum_attr()

Added bounds checking to make sure that every attr don't stray beyond
valid memory region.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('4bd64a8cea8faea7bef76b5f343fb76ceac91c34')">
                                    <div class="issue-number">400</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="4bd64a8cea8faea7bef76b5f343fb76ceac91c34">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

net: fix crash when config small gso_max_size/gso_ipv4_max_size

Config a small gso_max_size/gso_ipv4_max_size will lead to an underflow
in sk_dst_gso_max_size(), which may trigger a BUG_ON crash,
because sk->sk_gso_max_size would be much bigger than device limits.
Call Trace:
tcp_write_xmit
    tso_segs = tcp_init_tso_segs(skb, mss_now);
        tcp_set_skb_tso_segs
            tcp_skb_pcount_set
                // skb->len = 524288, mss_now = 8
                // u16 tso_segs = 524288/8 = 65535 -> 0
                tso_segs = DIV_ROUND_UP(skb->len, mss_now)
    BUG_ON(!tso_segs)
Add check for the minimum value of gso_max_size and gso_ipv4_max_size.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('a4320dc4f28aab86e86389056e3c71f027b33238')">
                                    <div class="issue-number">401</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="a4320dc4f28aab86e86389056e3c71f027b33238">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

dm: fix a crash if blk_alloc_disk fails

If blk_alloc_disk fails, the variable md->disk is set to an error value.
cleanup_mapped_device will see that md->disk is non-NULL and it will
attempt to access it, causing a crash on this statement
"md->disk->private_data = NULL;".</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('dec69d2c8cdebc24f03fba4068f947459117f07b')">
                                    <div class="issue-number">402</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="dec69d2c8cdebc24f03fba4068f947459117f07b">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

ksmbd: check outstanding simultaneous SMB operations

If Client send simultaneous SMB operations to ksmbd, It exhausts too much
memory through the "ksmbd_work_cache”. It will cause OOM issue.
ksmbd has a credit mechanism but it can't handle this problem. This patch
add the check if it exceeds max credits to prevent this problem by assuming
that one smb request consumes at least one credit.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('e6bc73a804dcb0a97d3ba56eec1788c3727960f2')">
                                    <div class="issue-number">403</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="e6bc73a804dcb0a97d3ba56eec1788c3727960f2">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

media: av7110: fix a spectre vulnerability

As warned by smatch:
	drivers/staging/media/av7110/av7110_ca.c:270 dvb_ca_ioctl() warn: potential spectre issue 'av7110->ci_slot' [w] (local cap)

There is a spectre-related vulnerability at the code. Fix it.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('988c595aa90b8e5b73b3e7a42f566313eb521373')">
                                    <div class="issue-number">404</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="988c595aa90b8e5b73b3e7a42f566313eb521373">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

net: enetc: allocate vf_state during PF probes

In the previous implementation, vf_state is allocated memory only when VF
is enabled. However, net_device_ops::ndo_set_vf_mac() may be called before
VF is enabled to configure the MAC address of VF. If this is the case,
enetc_pf_set_vf_mac() will access vf_state, resulting in access to a null
pointer. The simplified error log is as follows.

root@ls1028ardb:~# ip link set eno0 vf 1 mac 00:0c:e7:66:77:89
[  173.543315] Unable to handle kernel NULL pointer dereference at virtual address 0000000000000004
[  173.637254] pc : enetc_pf_set_vf_mac+0x3c/0x80 Message from sy
[  173.641973] lr : do_setlink+0x4a8/0xec8
[  173.732292] Call trace:
[  173.734740]  enetc_pf_set_vf_mac+0x3c/0x80
[  173.738847]  __rtnl_newlink+0x530/0x89c
[  173.742692]  rtnl_newlink+0x50/0x7c
[  173.746189]  rtnetlink_rcv_msg+0x128/0x390
[  173.750298]  netlink_rcv_skb+0x60/0x130
[  173.754145]  rtnetlink_rcv+0x18/0x24
[  173.757731]  netlink_unicast+0x318/0x380
[  173.761665]  netlink_sendmsg+0x17c/0x3c8</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('c708267f43a633ab4a54245b65b7a47c81cdaeac')">
                                    <div class="issue-number">405</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="c708267f43a633ab4a54245b65b7a47c81cdaeac">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

ipv4: ip_tunnel: Fix suspicious RCU usage warning in ip_tunnel_find()

The per-netns IP tunnel hash table is protected by the RTNL mutex and
ip_tunnel_find() is only called from the control path where the mutex is
taken.

Add a lockdep expression to hlist_for_each_entry_rcu() in
ip_tunnel_find() in order to validate that the mutex is held and to
silence the suspicious RCU usage warning [1].

[1]
WARNING: suspicious RCU usage
6.12.0-rc3-custom-gd95d9a31aceb #139 Not tainted
-----------------------------
net/ipv4/ip_tunnel.c:221 RCU-list traversed in non-reader section!!

other info that might help us debug this:

rcu_scheduler_active = 2, debug_locks = 1
1 lock held by ip/362:
 #0: ffffffff86fc7cb0 (rtnl_mutex){+.+.}-{3:3}, at: rtnetlink_rcv_msg+0x377/0xf60

stack backtrace:
CPU: 12 UID: 0 PID: 362 Comm: ip Not tainted 6.12.0-rc3-custom-gd95d9a31aceb #139
Hardware name: Bochs Bochs, BIOS Bochs 01/01/2011
Call Trace:
 <TASK>
 dump_stack_lvl+0xba/0x110
 lockdep_rcu_suspicious.cold+0x4f/0xd6
 ip_tunnel_find+0x435/0x4d0
 ip_tunnel_newlink+0x517/0x7a0
 ipgre_newlink+0x14c/0x170
 __rtnl_newlink+0x1173/0x19c0
 rtnl_newlink+0x6c/0xa0
 rtnetlink_rcv_msg+0x3cc/0xf60
 netlink_rcv_skb+0x171/0x450
 netlink_unicast+0x539/0x7f0
 netlink_sendmsg+0x8c1/0xd80
 ____sys_sendmsg+0x8f9/0xc20
 ___sys_sendmsg+0x197/0x1e0
 __sys_sendmsg+0x122/0x1f0
 do_syscall_64+0xbb/0x1d0
 entry_SYSCALL_64_after_hwframe+0x77/0x7f</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('ee356a2ef2f44608100213f87d794cb47f719551')">
                                    <div class="issue-number">406</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="ee356a2ef2f44608100213f87d794cb47f719551">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/i915/hdcp: Add encoder check in hdcp2_get_capability

Add encoder check in intel_hdcp2_get_capability to avoid
null pointer error.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('f2d9d31194cbe4ae7a68d626a155716c020c9e1b')">
                                    <div class="issue-number">407</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="f2d9d31194cbe4ae7a68d626a155716c020c9e1b">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/i915/hdcp: Add encoder check in intel_hdcp_get_capability

Sometimes during hotplug scenario or suspend/resume scenario encoder is
not always initialized when intel_hdcp_get_capability add
a check to avoid kernel null pointer dereference.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('7e08505ac9d8421686c44704ccaa675e3d7458e3')">
                                    <div class="issue-number">408</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="7e08505ac9d8421686c44704ccaa675e3d7458e3">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/mediatek: Fix potential NULL dereference in mtk_crtc_destroy()

In mtk_crtc_create(), if the call to mbox_request_channel() fails then we
set the "mtk_crtc->cmdq_client.chan" pointer to NULL.  In that situation,
we do not call cmdq_pkt_create().

During the cleanup, we need to check if the "mtk_crtc->cmdq_client.chan"
is NULL first before calling cmdq_pkt_destroy().  Calling
cmdq_pkt_destroy() is unnecessary if we didn't call cmdq_pkt_create() and
it will result in a NULL pointer dereference.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('666e30f2c5c4aa8472de1e7a28524854a72e4dc0')">
                                    <div class="issue-number">409</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="666e30f2c5c4aa8472de1e7a28524854a72e4dc0">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

mm/thp: fix deferred split unqueue naming and locking

Recent changes are putting more pressure on THP deferred split queues:
under load revealing long-standing races, causing list_del corruptions,
"Bad page state"s and worse (I keep BUGs in both of those, so usually
don't get to see how badly they end up without).  The relevant recent
changes being 6.8's mTHP, 6.10's mTHP swapout, and 6.12's mTHP swapin,
improved swap allocation, and underused THP splitting.

Before fixing locking: rename misleading folio_undo_large_rmappable(),
which does not undo large_rmappable, to folio_unqueue_deferred_split(),
which is what it does.  But that and its out-of-line __callee are mm
internals of very limited usability: add comment and WARN_ON_ONCEs to
check usage; and return a bool to say if a deferred split was unqueued,
which can then be used in WARN_ON_ONCEs around safety checks (sparing
callers the arcane conditionals in __folio_unqueue_deferred_split()).

Just omit the folio_unqueue_deferred_split() from free_unref_folios(), all
of whose callers now call it beforehand (and if any forget then bad_page()
will tell) - except for its caller put_pages_list(), which itself no
longer has any callers (and will be deleted separately).

Swapout: mem_cgroup_swapout() has been resetting folio->memcg_data 0
without checking and unqueueing a THP folio from deferred split list;
which is unfortunate, since the split_queue_lock depends on the memcg
(when memcg is enabled); so swapout has been unqueueing such THPs later,
when freeing the folio, using the pgdat's lock instead: potentially
corrupting the memcg's list.  __remove_mapping() has frozen refcount to 0
here, so no problem with calling folio_unqueue_deferred_split() before
resetting memcg_data.

That goes back to 5.4 commit 87eaceb3faa5 ("mm: thp: make deferred split
shrinker memcg aware"): which included a check on swapcache before adding
to deferred queue, but no check on deferred queue before adding THP to
swapcache.  That worked fine with the usual sequence of events in reclaim
(though there were a couple of rare ways in which a THP on deferred queue
could have been swapped out), but 6.12 commit dafff3f4c850 ("mm: split
underused THPs") avoids splitting underused THPs in reclaim, which makes
swapcache THPs on deferred queue commonplace.

Keep the check on swapcache before adding to deferred queue?  Yes: it is
no longer essential, but preserves the existing behaviour, and is likely
to be a worthwhile optimization (vmstat showed much more traffic on the
queue under swapping load if the check was removed); update its comment.

Memcg-v1 move (deprecated): mem_cgroup_move_account() has been changing
folio->memcg_data without checking and unqueueing a THP folio from the
deferred list, sometimes corrupting "from" memcg's list, like swapout. 
Refcount is non-zero here, so folio_unqueue_deferred_split() can only be
used in a WARN_ON_ONCE to validate the fix, which must be done earlier:
mem_cgroup_move_charge_pte_range() first try to split the THP (splitting
of course unqueues), or skip it if that fails.  Not ideal, but moving
charge has been requested, and khugepaged should repair the THP later:
nobody wants new custom unqueueing code just for this deprecated case.

The 87eaceb3faa5 commit did have the code to move from one deferred list
to another (but was not conscious of its unsafety while refcount non-0);
but that was removed by 5.6 commit fac0516b5534 ("mm: thp: don't need care
deferred split queue in memcg charge move path"), which argued that the
existence of a PMD mapping guarantees that the THP cannot be on a deferred
list.  As above, false in rare cases, and now commonly false.

Backport to 6.11 should be straightforward.  Earlier backports must take
care that other _deferred_list fixes and dependencies are included.  There
is not a strong case for backports, but they can fix cornercases.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('a78ec723f5b6d99dd29505619ec6a3bf2af7dfa1')">
                                    <div class="issue-number">410</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="a78ec723f5b6d99dd29505619ec6a3bf2af7dfa1">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/imagination: Break an object reference loop

When remaining resources are being cleaned up on driver close,
outstanding VM mappings may result in resources being leaked, due
to an object reference loop, as shown below, with each object (or
set of objects) referencing the object below it:

    PVR GEM Object
    GPU scheduler "finished" fence
    GPU scheduler “scheduled” fence
    PVR driver “done” fence
    PVR Context
    PVR VM Context
    PVR VM Mappings
    PVR GEM Object

The reference that the PVR VM Context has on the VM mappings is a
soft one, in the sense that the freeing of outstanding VM mappings
is done as part of VM context destruction; no reference counts are
involved, as is the case for all the other references in the loop.

To break the reference loop during cleanup, free the outstanding
VM mappings before destroying the PVR Context associated with the
VM context.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('b648bf68821e0f688a977fb4ce3da0563892e34b')">
                                    <div class="issue-number">411</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="b648bf68821e0f688a977fb4ce3da0563892e34b">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

tpm: Lock TPM chip in tpm_pm_suspend() first

Setting TPM_CHIP_FLAG_SUSPENDED in the end of tpm_pm_suspend() can be racy
according, as this leaves window for tpm_hwrng_read() to be called while
the operation is in progress. The recent bug report gives also evidence of
this behaviour.

Aadress this by locking the TPM chip before checking any chip->flags both
in tpm_pm_suspend() and tpm_hwrng_read(). Move TPM_CHIP_FLAG_SUSPENDED
check inside tpm_get_random() so that it will be always checked only when
the lock is reserved.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('d3daf7942128ef0d6ccec8d43e91403e2a9fdb2f')">
                                    <div class="issue-number">412</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="d3daf7942128ef0d6ccec8d43e91403e2a9fdb2f">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

LoongArch: KVM: Mark hrtimer to expire in hard interrupt context

Like commit 2c0d278f3293f ("KVM: LAPIC: Mark hrtimer to expire in hard
interrupt context") and commit 9090825fa9974 ("KVM: arm/arm64: Let the
timer expire in hardirq context on RT"), On PREEMPT_RT enabled kernels
unmarked hrtimers are moved into soft interrupt expiry mode by default.
Then the timers are canceled from an preempt-notifier which is invoked
with disabled preemption which is not allowed on PREEMPT_RT.

The timer callback is short so in could be invoked in hard-IRQ context.
So let the timer expire on hard-IRQ context even on -RT.

This fix a "scheduling while atomic" bug for PREEMPT_RT enabled kernels:

 BUG: scheduling while atomic: qemu-system-loo/1011/0x00000002
 Modules linked in: amdgpu rfkill nft_fib_inet nft_fib_ipv4 nft_fib_ipv6 nft_fib nft_reject_inet nf_reject_ipv4 nf_reject_ipv6 nft_reject nft_ct nft_chain_nat ns
 CPU: 1 UID: 0 PID: 1011 Comm: qemu-system-loo Tainted: G        W          6.12.0-rc2+ #1774
 Tainted: [W]=WARN
 Hardware name: Loongson Loongson-3A5000-7A1000-1w-CRB/Loongson-LS3A5000-7A1000-1w-CRB, BIOS vUDK2018-LoongArch-V2.0.0-prebeta9 10/21/2022
 Stack : ffffffffffffffff 0000000000000000 9000000004e3ea38 9000000116744000
         90000001167475a0 0000000000000000 90000001167475a8 9000000005644830
         90000000058dc000 90000000058dbff8 9000000116747420 0000000000000001
         0000000000000001 6a613fc938313980 000000000790c000 90000001001c1140
         00000000000003fe 0000000000000001 000000000000000d 0000000000000003
         0000000000000030 00000000000003f3 000000000790c000 9000000116747830
         90000000057ef000 0000000000000000 9000000005644830 0000000000000004
         0000000000000000 90000000057f4b58 0000000000000001 9000000116747868
         900000000451b600 9000000005644830 9000000003a13998 0000000010000020
         00000000000000b0 0000000000000004 0000000000000000 0000000000071c1d
         ...
 Call Trace:
 [<9000000003a13998>] show_stack+0x38/0x180
 [<9000000004e3ea34>] dump_stack_lvl+0x84/0xc0
 [<9000000003a71708>] __schedule_bug+0x48/0x60
 [<9000000004e45734>] __schedule+0x1114/0x1660
 [<9000000004e46040>] schedule_rtlock+0x20/0x60
 [<9000000004e4e330>] rtlock_slowlock_locked+0x3f0/0x10a0
 [<9000000004e4f038>] rt_spin_lock+0x58/0x80
 [<9000000003b02d68>] hrtimer_cancel_wait_running+0x68/0xc0
 [<9000000003b02e30>] hrtimer_cancel+0x70/0x80
 [<ffff80000235eb70>] kvm_restore_timer+0x50/0x1a0 [kvm]
 [<ffff8000023616c8>] kvm_arch_vcpu_load+0x68/0x2a0 [kvm]
 [<ffff80000234c2d4>] kvm_sched_in+0x34/0x60 [kvm]
 [<9000000003a749a0>] finish_task_switch.isra.0+0x140/0x2e0
 [<9000000004e44a70>] __schedule+0x450/0x1660
 [<9000000004e45cb0>] schedule+0x30/0x180
 [<ffff800002354c70>] kvm_vcpu_block+0x70/0x120 [kvm]
 [<ffff800002354d80>] kvm_vcpu_halt+0x60/0x3e0 [kvm]
 [<ffff80000235b194>] kvm_handle_gspr+0x3f4/0x4e0 [kvm]
 [<ffff80000235f548>] kvm_handle_exit+0x1c8/0x260 [kvm]</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('309dbc23b94c1a82828b4b2bc5d06e083f47e481')">
                                    <div class="issue-number">413</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="309dbc23b94c1a82828b4b2bc5d06e083f47e481">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

afs: Fix lock recursion

afs_wake_up_async_call() can incur lock recursion.  The problem is that it
is called from AF_RXRPC whilst holding the ->notify_lock, but it tries to
take a ref on the afs_call struct in order to pass it to a work queue - but
if the afs_call is already queued, we then have an extraneous ref that must
be put... calling afs_put_call() may call back down into AF_RXRPC through
rxrpc_kernel_shutdown_call(), however, which might try taking the
->notify_lock again.

This case isn't very common, however, so defer it to a workqueue.  The oops
looks something like:

  BUG: spinlock recursion on CPU#0, krxrpcio/7001/1646
   lock: 0xffff888141399b30, .magic: dead4ead, .owner: krxrpcio/7001/1646, .owner_cpu: 0
  CPU: 0 UID: 0 PID: 1646 Comm: krxrpcio/7001 Not tainted 6.12.0-rc2-build3+ #4351
  Hardware name: ASUS All Series/H97-PLUS, BIOS 2306 10/09/2014
  Call Trace:
   <TASK>
   dump_stack_lvl+0x47/0x70
   do_raw_spin_lock+0x3c/0x90
   rxrpc_kernel_shutdown_call+0x83/0xb0
   afs_put_call+0xd7/0x180
   rxrpc_notify_socket+0xa0/0x190
   rxrpc_input_split_jumbo+0x198/0x1d0
   rxrpc_input_data+0x14b/0x1e0
   ? rxrpc_input_call_packet+0xc2/0x1f0
   rxrpc_input_call_event+0xad/0x6b0
   rxrpc_input_packet_on_conn+0x1e1/0x210
   rxrpc_input_packet+0x3f2/0x4d0
   rxrpc_io_thread+0x243/0x410
   ? __pfx_rxrpc_io_thread+0x10/0x10
   kthread+0xcf/0xe0
   ? __pfx_kthread+0x10/0x10
   ret_from_fork+0x24/0x40
   ? __pfx_kthread+0x10/0x10
   ret_from_fork_asm+0x1a/0x30
   </TASK></p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('955a7b4cdd5d99879d1228660a4ed5af0b030e95')">
                                    <div class="issue-number">414</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="955a7b4cdd5d99879d1228660a4ed5af0b030e95">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

bpf: Add sk_is_inet and IS_ICSK check in tls_sw_has_ctx_tx/rx

As the introduction of the support for vsock and unix sockets in sockmap,
tls_sw_has_ctx_tx/rx cannot presume the socket passed in must be IS_ICSK.
vsock and af_unix sockets have vsock_sock and unix_sock instead of
inet_connection_sock. For these sockets, tls_get_ctx may return an invalid
pointer and cause page fault in function tls_sw_ctx_rx.

BUG: unable to handle page fault for address: 0000000000040030
Workqueue: vsock-loopback vsock_loopback_work
RIP: 0010:sk_psock_strp_data_ready+0x23/0x60
Call Trace:
 ? __die+0x81/0xc3
 ? no_context+0x194/0x350
 ? do_page_fault+0x30/0x110
 ? async_page_fault+0x3e/0x50
 ? sk_psock_strp_data_ready+0x23/0x60
 virtio_transport_recv_pkt+0x750/0x800
 ? update_load_avg+0x7e/0x620
 vsock_loopback_work+0xd0/0x100
 process_one_work+0x1a7/0x360
 worker_thread+0x30/0x390
 ? create_worker+0x1a0/0x1a0
 kthread+0x112/0x130
 ? __kthread_cancel_work+0x40/0x40
 ret_from_fork+0x1f/0x40

v2:
  - Add IS_ICSK check
v3:
  - Update the commits in Fixes</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('88f0196cf5cfd5cb6039bcb2add6740bef2476ae')">
                                    <div class="issue-number">415</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="88f0196cf5cfd5cb6039bcb2add6740bef2476ae">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

RDMA/siw: Add sendpage_ok() check to disable MSG_SPLICE_PAGES

While running ISER over SIW, the initiator machine encounters a warning
from skb_splice_from_iter() indicating that a slab page is being used in
send_page. To address this, it is better to add a sendpage_ok() check
within the driver itself, and if it returns 0, then MSG_SPLICE_PAGES flag
should be disabled before entering the network stack.

A similar issue has been discussed for NVMe in this thread:
https://lore.kernel.org/all/20240530142417.146696-1-ofir.gal@volumez.com/

  WARNING: CPU: 0 PID: 5342 at net/core/skbuff.c:7140 skb_splice_from_iter+0x173/0x320
  Call Trace:
   tcp_sendmsg_locked+0x368/0xe40
   siw_tx_hdt+0x695/0xa40 [siw]
   siw_qp_sq_process+0x102/0xb00 [siw]
   siw_sq_resume+0x39/0x110 [siw]
   siw_run_sq+0x74/0x160 [siw]
   kthread+0xd2/0x100
   ret_from_fork+0x34/0x40
   ret_from_fork_asm+0x1a/0x30</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('2ea23789167ad33f4facb6e3f2c3c8458d92303f')">
                                    <div class="issue-number">416</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="2ea23789167ad33f4facb6e3f2c3c8458d92303f">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

smb: client: Fix use-after-free of network namespace.

Recently, we got a customer report that CIFS triggers oops while
reconnecting to a server.  [0]

The workload runs on Kubernetes, and some pods mount CIFS servers
in non-root network namespaces.  The problem rarely happened, but
it was always while the pod was dying.

The root cause is wrong reference counting for network namespace.

CIFS uses kernel sockets, which do not hold refcnt of the netns that
the socket belongs to.  That means CIFS must ensure the socket is
always freed before its netns; otherwise, use-after-free happens.

The repro steps are roughly:

  1. mount CIFS in a non-root netns
  2. drop packets from the netns
  3. destroy the netns
  4. unmount CIFS

We can reproduce the issue quickly with the script [1] below and see
the splat [2] if CONFIG_NET_NS_REFCNT_TRACKER is enabled.

When the socket is TCP, it is hard to guarantee the netns lifetime
without holding refcnt due to async timers.

Let's hold netns refcnt for each socket as done for SMC in commit
9744d2bf1976 ("smc: Fix use-after-free in tcp_write_timer_handler().").

Note that we need to move put_net() from cifs_put_tcp_session() to
clean_demultiplex_info(); otherwise, __sock_create() still could touch a
freed netns while cifsd tries to reconnect from cifs_demultiplex_thread().

Also, maybe_get_net() cannot be put just before __sock_create() because
the code is not under RCU and there is a small chance that the same
address happened to be reallocated to another netns.

[0]:
CIFS: VFS: \\XXXXXXXXXXX has not responded in 15 seconds. Reconnecting...
CIFS: Serverclose failed 4 times, giving up
Unable to handle kernel paging request at virtual address 14de99e461f84a07
Mem abort info:
  ESR = 0x0000000096000004
  EC = 0x25: DABT (current EL), IL = 32 bits
  SET = 0, FnV = 0
  EA = 0, S1PTW = 0
  FSC = 0x04: level 0 translation fault
Data abort info:
  ISV = 0, ISS = 0x00000004
  CM = 0, WnR = 0
[14de99e461f84a07] address between user and kernel address ranges
Internal error: Oops: 0000000096000004 [#1] SMP
Modules linked in: cls_bpf sch_ingress nls_utf8 cifs cifs_arc4 cifs_md4 dns_resolver tcp_diag inet_diag veth xt_state xt_connmark nf_conntrack_netlink xt_nat xt_statistic xt_MASQUERADE xt_mark xt_addrtype ipt_REJECT nf_reject_ipv4 nft_chain_nat nf_nat xt_conntrack nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 xt_comment nft_compat nf_tables nfnetlink overlay nls_ascii nls_cp437 sunrpc vfat fat aes_ce_blk aes_ce_cipher ghash_ce sm4_ce_cipher sm4 sm3_ce sm3 sha3_ce sha512_ce sha512_arm64 sha1_ce ena button sch_fq_codel loop fuse configfs dmi_sysfs sha2_ce sha256_arm64 dm_mirror dm_region_hash dm_log dm_mod dax efivarfs
CPU: 5 PID: 2690970 Comm: cifsd Not tainted 6.1.103-109.184.amzn2023.aarch64 #1
Hardware name: Amazon EC2 r7g.4xlarge/, BIOS 1.0 11/1/2018
pstate: 00400005 (nzcv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)
pc : fib_rules_lookup+0x44/0x238
lr : __fib_lookup+0x64/0xbc
sp : ffff8000265db790
x29: ffff8000265db790 x28: 0000000000000000 x27: 000000000000bd01
x26: 0000000000000000 x25: ffff000b4baf8000 x24: ffff00047b5e4580
x23: ffff8000265db7e0 x22: 0000000000000000 x21: ffff00047b5e4500
x20: ffff0010e3f694f8 x19: 14de99e461f849f7 x18: 0000000000000000
x17: 0000000000000000 x16: 0000000000000000 x15: 0000000000000000
x14: 0000000000000000 x13: 0000000000000000 x12: 3f92800abd010002
x11: 0000000000000001 x10: ffff0010e3f69420 x9 : ffff800008a6f294
x8 : 0000000000000000 x7 : 0000000000000006 x6 : 0000000000000000
x5 : 0000000000000001 x4 : ffff001924354280 x3 : ffff8000265db7e0
x2 : 0000000000000000 x1 : ffff0010e3f694f8 x0 : ffff00047b5e4500
Call trace:
 fib_rules_lookup+0x44/0x238
 __fib_lookup+0x64/0xbc
 ip_route_output_key_hash_rcu+0x2c4/0x398
 ip_route_output_key_hash+0x60/0x8c
 tcp_v4_connect+0x290/0x488
 __inet_stream_connect+0x108/0x3d0
 inet_stream_connect+0x50/0x78
 kernel_connect+0x6c/0xac
 generic_ip_conne
---truncated---</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('bcb77f56772858bd52bf5fa5e6c1d83d7ebba10d')">
                                    <div class="issue-number">417</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="bcb77f56772858bd52bf5fa5e6c1d83d7ebba10d">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

mm: resolve faulty mmap_region() error path behaviour

The mmap_region() function is somewhat terrifying, with spaghetti-like
control flow and numerous means by which issues can arise and incomplete
state, memory leaks and other unpleasantness can occur.

A large amount of the complexity arises from trying to handle errors late
in the process of mapping a VMA, which forms the basis of recently
observed issues with resource leaks and observable inconsistent state.

Taking advantage of previous patches in this series we move a number of
checks earlier in the code, simplifying things by moving the core of the
logic into a static internal function __mmap_region().

Doing this allows us to perform a number of checks up front before we do
any real work, and allows us to unwind the writable unmap check
unconditionally as required and to perform a CONFIG_DEBUG_VM_MAPLE_TREE
validation unconditionally also.

We move a number of things here:

1. We preallocate memory for the iterator before we call the file-backed
   memory hook, allowing us to exit early and avoid having to perform
   complicated and error-prone close/free logic. We carefully free
   iterator state on both success and error paths.

2. The enclosing mmap_region() function handles the mapping_map_writable()
   logic early. Previously the logic had the mapping_map_writable() at the
   point of mapping a newly allocated file-backed VMA, and a matching
   mapping_unmap_writable() on success and error paths.

   We now do this unconditionally if this is a file-backed, shared writable
   mapping. If a driver changes the flags to eliminate VM_MAYWRITE, however
   doing so does not invalidate the seal check we just performed, and we in
   any case always decrement the counter in the wrapper.

   We perform a debug assert to ensure a driver does not attempt to do the
   opposite.

3. We also move arch_validate_flags() up into the mmap_region()
   function. This is only relevant on arm64 and sparc64, and the check is
   only meaningful for SPARC with ADI enabled. We explicitly add a warning
   for this arch if a driver invalidates this check, though the code ought
   eventually to be fixed to eliminate the need for this.

With all of these measures in place, we no longer need to explicitly close
the VMA on error paths, as we place all checks which might fail prior to a
call to any driver mmap hook.

This eliminates an entire class of errors, makes the code easier to reason
about and more robust.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('6f8914dece677c3003ed99a50413580f61faaea7')">
                                    <div class="issue-number">418</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="6f8914dece677c3003ed99a50413580f61faaea7">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/xe/ufence: Prefetch ufence addr to catch bogus address

access_ok() only checks for addr overflow so also try to read the addr
to catch invalid addr sent from userspace.

(cherry picked from commit 9408c4508483ffc60811e910a93d6425b8e63928)</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('c2996c7eb89bfa184a425e0fc3536f1ae244f55d')">
                                    <div class="issue-number">419</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="c2996c7eb89bfa184a425e0fc3536f1ae244f55d">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

bpf: Check validity of link->type in bpf_link_show_fdinfo()

If a newly-added link type doesn't invoke BPF_LINK_TYPE(), accessing
bpf_link_type_strs[link->type] may result in an out-of-bounds access.

To spot such missed invocations early in the future, checking the
validity of link->type in bpf_link_show_fdinfo() and emitting a warning
when such invocations are missed.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('3c7e1d88c467b73bd6e4133e14820eee82a16043')">
                                    <div class="issue-number">420</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="3c7e1d88c467b73bd6e4133e14820eee82a16043">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

nvme: tcp: avoid race between queue_lock lock and destroy

Commit 76d54bf20cdc ("nvme-tcp: don't access released socket during
error recovery") added a mutex_lock() call for the queue->queue_lock
in nvme_tcp_get_address(). However, the mutex_lock() races with
mutex_destroy() in nvme_tcp_free_queue(), and causes the WARN below.

DEBUG_LOCKS_WARN_ON(lock->magic != lock)
WARNING: CPU: 3 PID: 34077 at kernel/locking/mutex.c:587 __mutex_lock+0xcf0/0x1220
Modules linked in: nvmet_tcp nvmet nvme_tcp nvme_fabrics iw_cm ib_cm ib_core pktcdvd nft_fib_inet nft_fib_ipv4 nft_fib_ipv6 nft_fib nft_reject_inet nf_reject_ipv4 nf_reject_ipv6 nft_reject nft_ct nft_chain_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 ip_set nf_tables qrtr sunrpc ppdev 9pnet_virtio 9pnet pcspkr netfs parport_pc parport e1000 i2c_piix4 i2c_smbus loop fuse nfnetlink zram bochs drm_vram_helper drm_ttm_helper ttm drm_kms_helper xfs drm sym53c8xx floppy nvme scsi_transport_spi nvme_core nvme_auth serio_raw ata_generic pata_acpi dm_multipath qemu_fw_cfg [last unloaded: ib_uverbs]
CPU: 3 UID: 0 PID: 34077 Comm: udisksd Not tainted 6.11.0-rc7 #319
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-2.fc40 04/01/2014
RIP: 0010:__mutex_lock+0xcf0/0x1220
Code: 08 84 d2 0f 85 c8 04 00 00 8b 15 ef b6 c8 01 85 d2 0f 85 78 f4 ff ff 48 c7 c6 20 93 ee af 48 c7 c7 60 91 ee af e8 f0 a7 6d fd <0f> 0b e9 5e f4 ff ff 48 b8 00 00 00 00 00 fc ff df 4c 89 f2 48 c1
RSP: 0018:ffff88811305f760 EFLAGS: 00010286
RAX: 0000000000000000 RBX: ffff88812c652058 RCX: 0000000000000000
RDX: 0000000000000000 RSI: 0000000000000004 RDI: 0000000000000001
RBP: ffff88811305f8b0 R08: 0000000000000001 R09: ffffed1075c36341
R10: ffff8883ae1b1a0b R11: 0000000000010498 R12: 0000000000000000
R13: 0000000000000000 R14: dffffc0000000000 R15: ffff88812c652058
FS:  00007f9713ae4980(0000) GS:ffff8883ae180000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007fcd78483c7c CR3: 0000000122c38000 CR4: 00000000000006f0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
Call Trace:
 <TASK>
 ? __warn.cold+0x5b/0x1af
 ? __mutex_lock+0xcf0/0x1220
 ? report_bug+0x1ec/0x390
 ? handle_bug+0x3c/0x80
 ? exc_invalid_op+0x13/0x40
 ? asm_exc_invalid_op+0x16/0x20
 ? __mutex_lock+0xcf0/0x1220
 ? nvme_tcp_get_address+0xc2/0x1e0 [nvme_tcp]
 ? __pfx___mutex_lock+0x10/0x10
 ? __lock_acquire+0xd6a/0x59e0
 ? nvme_tcp_get_address+0xc2/0x1e0 [nvme_tcp]
 nvme_tcp_get_address+0xc2/0x1e0 [nvme_tcp]
 ? __pfx_nvme_tcp_get_address+0x10/0x10 [nvme_tcp]
 nvme_sysfs_show_address+0x81/0xc0 [nvme_core]
 dev_attr_show+0x42/0x80
 ? __asan_memset+0x1f/0x40
 sysfs_kf_seq_show+0x1f0/0x370
 seq_read_iter+0x2cb/0x1130
 ? rw_verify_area+0x3b1/0x590
 ? __mutex_lock+0x433/0x1220
 vfs_read+0x6a6/0xa20
 ? lockdep_hardirqs_on+0x78/0x100
 ? __pfx_vfs_read+0x10/0x10
 ksys_read+0xf7/0x1d0
 ? __pfx_ksys_read+0x10/0x10
 ? __x64_sys_openat+0x105/0x1d0
 do_syscall_64+0x93/0x180
 ? lockdep_hardirqs_on_prepare+0x16d/0x400
 ? do_syscall_64+0x9f/0x180
 ? lockdep_hardirqs_on+0x78/0x100
 ? do_syscall_64+0x9f/0x180
 ? __pfx_ksys_read+0x10/0x10
 ? lockdep_hardirqs_on_prepare+0x16d/0x400
 ? do_syscall_64+0x9f/0x180
 ? lockdep_hardirqs_on+0x78/0x100
 ? do_syscall_64+0x9f/0x180
 ? lockdep_hardirqs_on_prepare+0x16d/0x400
 ? do_syscall_64+0x9f/0x180
 ? lockdep_hardirqs_on+0x78/0x100
 ? do_syscall_64+0x9f/0x180
 ? lockdep_hardirqs_on_prepare+0x16d/0x400
 ? do_syscall_64+0x9f/0x180
 ? lockdep_hardirqs_on+0x78/0x100
 ? do_syscall_64+0x9f/0x180
 ? lockdep_hardirqs_on_prepare+0x16d/0x400
 ? do_syscall_64+0x9f/0x180
 ? lockdep_hardirqs_on+0x78/0x100
 ? do_syscall_64+0x9f/0x180
 ? do_syscall_64+0x9f/0x180
 entry_SYSCALL_64_after_hwframe+0x76/0x7e
RIP: 0033:0x7f9713f55cfa
Code: 55 48 89 e5 48 83 ec 20 48 89 55 e8 48 89 75 f0 89 7d f8 e8 e8 74 f8 ff 48 8b 55 e8 48 8b 75 f0 4
---truncated---</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('763b887686c0fa91971ce9a14e6efa13a911d2b3')">
                                    <div class="issue-number">421</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="763b887686c0fa91971ce9a14e6efa13a911d2b3">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

fs: Fix uninitialized value issue in from_kuid and from_kgid

ocfs2_setattr() uses attr->ia_mode, attr->ia_uid and attr->ia_gid in
a trace point even though ATTR_MODE, ATTR_UID and ATTR_GID aren't set.

Initialize all fields of newattrs to avoid uninitialized variables, by
checking if ATTR_MODE, ATTR_UID, ATTR_GID are initialized, otherwise 0.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('91bdd1e40be9082677840cd0e58cb14067a9cb8e')">
                                    <div class="issue-number">422</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="91bdd1e40be9082677840cd0e58cb14067a9cb8e">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

nvme: make keep-alive synchronous operation

The nvme keep-alive operation, which executes at a periodic interval,
could potentially sneak in while shutting down a fabric controller.
This may lead to a race between the fabric controller admin queue
destroy code path (invoked while shutting down controller) and hw/hctx
queue dispatcher called from the nvme keep-alive async request queuing
operation. This race could lead to the kernel crash shown below:

Call Trace:
    autoremove_wake_function+0x0/0xbc (unreliable)
    __blk_mq_sched_dispatch_requests+0x114/0x24c
    blk_mq_sched_dispatch_requests+0x44/0x84
    blk_mq_run_hw_queue+0x140/0x220
    nvme_keep_alive_work+0xc8/0x19c [nvme_core]
    process_one_work+0x200/0x4e0
    worker_thread+0x340/0x504
    kthread+0x138/0x140
    start_kernel_thread+0x14/0x18

While shutting down fabric controller, if nvme keep-alive request sneaks
in then it would be flushed off. The nvme_keep_alive_end_io function is
then invoked to handle the end of the keep-alive operation which
decrements the admin->q_usage_counter and assuming this is the last/only
request in the admin queue then the admin->q_usage_counter becomes zero.
If that happens then blk-mq destroy queue operation (blk_mq_destroy_
queue()) which could be potentially running simultaneously on another
cpu (as this is the controller shutdown code path) would forward
progress and deletes the admin queue. So, now from this point onward
we are not supposed to access the admin queue resources. However the
issue here's that the nvme keep-alive thread running hw/hctx queue
dispatch operation hasn't yet finished its work and so it could still
potentially access the admin queue resource while the admin queue had
been already deleted and that causes the above crash.

This fix helps avoid the observed crash by implementing keep-alive as a
synchronous operation so that we decrement admin->q_usage_counter only
after keep-alive command finished its execution and returns the command
status back up to its caller (blk_execute_rq()). This would ensure that
fabric shutdown code path doesn't destroy the fabric admin queue until
keep-alive request finished execution and also keep-alive thread is not
running hw/hctx queue dispatch operation.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('811f8ee9f32696669829980fef210c6ebb7a25ce')">
                                    <div class="issue-number">423</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="811f8ee9f32696669829980fef210c6ebb7a25ce">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

media: uvcvideo: Skip parsing frames of type UVC_VS_UNDEFINED in uvc_parse_format

This can lead to out of bounds writes since frames of this type were not
taken into account when calculating the size of the frames buffer in
uvc_parse_streaming.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('7968ce9384bba3b574d2721133cadd5900cad370')">
                                    <div class="issue-number">424</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="7968ce9384bba3b574d2721133cadd5900cad370">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

mm: page_alloc: move mlocked flag clearance into free_pages_prepare()

Syzbot reported a bad page state problem caused by a page being freed
using free_page() still having a mlocked flag at free_pages_prepare()
stage:

  BUG: Bad page state in process syz.5.504  pfn:61f45
  page: refcount:0 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x61f45
  flags: 0xfff00000080204(referenced|workingset|mlocked|node=0|zone=1|lastcpupid=0x7ff)
  raw: 00fff00000080204 0000000000000000 dead000000000122 0000000000000000
  raw: 0000000000000000 0000000000000000 00000000ffffffff 0000000000000000
  page dumped because: PAGE_FLAGS_CHECK_AT_FREE flag(s) set
  page_owner tracks the page as allocated
  page last allocated via order 0, migratetype Unmovable, gfp_mask 0x400dc0(GFP_KERNEL_ACCOUNT|__GFP_ZERO), pid 8443, tgid 8442 (syz.5.504), ts 201884660643, free_ts 201499827394
   set_page_owner include/linux/page_owner.h:32 [inline]
   post_alloc_hook+0x1f3/0x230 mm/page_alloc.c:1537
   prep_new_page mm/page_alloc.c:1545 [inline]
   get_page_from_freelist+0x303f/0x3190 mm/page_alloc.c:3457
   __alloc_pages_noprof+0x292/0x710 mm/page_alloc.c:4733
   alloc_pages_mpol_noprof+0x3e8/0x680 mm/mempolicy.c:2265
   kvm_coalesced_mmio_init+0x1f/0xf0 virt/kvm/coalesced_mmio.c:99
   kvm_create_vm virt/kvm/kvm_main.c:1235 [inline]
   kvm_dev_ioctl_create_vm virt/kvm/kvm_main.c:5488 [inline]
   kvm_dev_ioctl+0x12dc/0x2240 virt/kvm/kvm_main.c:5530
   __do_compat_sys_ioctl fs/ioctl.c:1007 [inline]
   __se_compat_sys_ioctl+0x510/0xc90 fs/ioctl.c:950
   do_syscall_32_irqs_on arch/x86/entry/common.c:165 [inline]
   __do_fast_syscall_32+0xb4/0x110 arch/x86/entry/common.c:386
   do_fast_syscall_32+0x34/0x80 arch/x86/entry/common.c:411
   entry_SYSENTER_compat_after_hwframe+0x84/0x8e
  page last free pid 8399 tgid 8399 stack trace:
   reset_page_owner include/linux/page_owner.h:25 [inline]
   free_pages_prepare mm/page_alloc.c:1108 [inline]
   free_unref_folios+0xf12/0x18d0 mm/page_alloc.c:2686
   folios_put_refs+0x76c/0x860 mm/swap.c:1007
   free_pages_and_swap_cache+0x5c8/0x690 mm/swap_state.c:335
   __tlb_batch_free_encoded_pages mm/mmu_gather.c:136 [inline]
   tlb_batch_pages_flush mm/mmu_gather.c:149 [inline]
   tlb_flush_mmu_free mm/mmu_gather.c:366 [inline]
   tlb_flush_mmu+0x3a3/0x680 mm/mmu_gather.c:373
   tlb_finish_mmu+0xd4/0x200 mm/mmu_gather.c:465
   exit_mmap+0x496/0xc40 mm/mmap.c:1926
   __mmput+0x115/0x390 kernel/fork.c:1348
   exit_mm+0x220/0x310 kernel/exit.c:571
   do_exit+0x9b2/0x28e0 kernel/exit.c:926
   do_group_exit+0x207/0x2c0 kernel/exit.c:1088
   __do_sys_exit_group kernel/exit.c:1099 [inline]
   __se_sys_exit_group kernel/exit.c:1097 [inline]
   __x64_sys_exit_group+0x3f/0x40 kernel/exit.c:1097
   x64_sys_call+0x2634/0x2640 arch/x86/include/generated/asm/syscalls_64.h:232
   do_syscall_x64 arch/x86/entry/common.c:52 [inline]
   do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83
   entry_SYSCALL_64_after_hwframe+0x77/0x7f
  Modules linked in:
  CPU: 0 UID: 0 PID: 8442 Comm: syz.5.504 Not tainted 6.12.0-rc6-syzkaller #0
  Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024
  Call Trace:
   <TASK>
   __dump_stack lib/dump_stack.c:94 [inline]
   dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120
   bad_page+0x176/0x1d0 mm/page_alloc.c:501
   free_page_is_bad mm/page_alloc.c:918 [inline]
   free_pages_prepare mm/page_alloc.c:1100 [inline]
   free_unref_page+0xed0/0xf20 mm/page_alloc.c:2638
   kvm_destroy_vm virt/kvm/kvm_main.c:1327 [inline]
   kvm_put_kvm+0xc75/0x1350 virt/kvm/kvm_main.c:1386
   kvm_vcpu_release+0x54/0x60 virt/kvm/kvm_main.c:4143
   __fput+0x23f/0x880 fs/file_table.c:431
   task_work_run+0x24f/0x310 kernel/task_work.c:239
   exit_task_work include/linux/task_work.h:43 [inline]
   do_exit+0xa2f/0x28e0 kernel/exit.c:939
   do_group_exit+0x207/0x2c0 kernel/exit.c:1088
   __do_sys_exit_group kernel/exit.c:1099 [in
---truncated---</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('31282c5e0a607b93af0ea5449aee46c3e7a7849c')">
                                    <div class="issue-number">425</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="31282c5e0a607b93af0ea5449aee46c3e7a7849c">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

ima: fix buffer overrun in ima_eventdigest_init_common

Function ima_eventdigest_init() calls ima_eventdigest_init_common()
with HASH_ALGO__LAST which is then used to access the array
hash_digest_size[] leading to buffer overrun. Have a conditional
statement to handle this.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('f2c94d8d95ead1146118cb73815845466be22c46')">
                                    <div class="issue-number">426</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="f2c94d8d95ead1146118cb73815845466be22c46">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

drm/amd/display: Adjust VSDB parser for replay feature

At some point, the IEEE ID identification for the replay check in the
AMD EDID was added. However, this check causes the following
out-of-bounds issues when using KASAN:

[   27.804016] BUG: KASAN: slab-out-of-bounds in amdgpu_dm_update_freesync_caps+0xefa/0x17a0 [amdgpu]
[   27.804788] Read of size 1 at addr ffff8881647fdb00 by task systemd-udevd/383

...

[   27.821207] Memory state around the buggy address:
[   27.821215]  ffff8881647fda00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
[   27.821224]  ffff8881647fda80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
[   27.821234] >ffff8881647fdb00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
[   27.821243]                    ^
[   27.821250]  ffff8881647fdb80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
[   27.821259]  ffff8881647fdc00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
[   27.821268] ==================================================================

This is caused because the ID extraction happens outside of the range of
the edid lenght. This commit addresses this issue by considering the
amd_vsdb_block size.

(cherry picked from commit b7e381b1ccd5e778e3d9c44c669ad38439a861d8)</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('920cee97b393fc5d283b4cb3714eaa4434055b6d')">
                                    <div class="issue-number">427</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="920cee97b393fc5d283b4cb3714eaa4434055b6d">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

vp_vdpa: fix id_table array not null terminated error

Allocate one extra virtio_device_id as null terminator, otherwise
vdpa_mgmtdev_get_classes() may iterate multiple times and visit
undefined memory.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('d081e45030ce6df74e33cff836142580df9076a8')">
                                    <div class="issue-number">428</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="d081e45030ce6df74e33cff836142580df9076a8">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

ocfs2: uncache inode which has failed entering the group

Syzbot has reported the following BUG:

kernel BUG at fs/ocfs2/uptodate.c:509!
...
Call Trace:
 <TASK>
 ? __die_body+0x5f/0xb0
 ? die+0x9e/0xc0
 ? do_trap+0x15a/0x3a0
 ? ocfs2_set_new_buffer_uptodate+0x145/0x160
 ? do_error_trap+0x1dc/0x2c0
 ? ocfs2_set_new_buffer_uptodate+0x145/0x160
 ? __pfx_do_error_trap+0x10/0x10
 ? handle_invalid_op+0x34/0x40
 ? ocfs2_set_new_buffer_uptodate+0x145/0x160
 ? exc_invalid_op+0x38/0x50
 ? asm_exc_invalid_op+0x1a/0x20
 ? ocfs2_set_new_buffer_uptodate+0x2e/0x160
 ? ocfs2_set_new_buffer_uptodate+0x144/0x160
 ? ocfs2_set_new_buffer_uptodate+0x145/0x160
 ocfs2_group_add+0x39f/0x15a0
 ? __pfx_ocfs2_group_add+0x10/0x10
 ? __pfx_lock_acquire+0x10/0x10
 ? mnt_get_write_access+0x68/0x2b0
 ? __pfx_lock_release+0x10/0x10
 ? rcu_read_lock_any_held+0xb7/0x160
 ? __pfx_rcu_read_lock_any_held+0x10/0x10
 ? smack_log+0x123/0x540
 ? mnt_get_write_access+0x68/0x2b0
 ? mnt_get_write_access+0x68/0x2b0
 ? mnt_get_write_access+0x226/0x2b0
 ocfs2_ioctl+0x65e/0x7d0
 ? __pfx_ocfs2_ioctl+0x10/0x10
 ? smack_file_ioctl+0x29e/0x3a0
 ? __pfx_smack_file_ioctl+0x10/0x10
 ? lockdep_hardirqs_on_prepare+0x43d/0x780
 ? __pfx_lockdep_hardirqs_on_prepare+0x10/0x10
 ? __pfx_ocfs2_ioctl+0x10/0x10
 __se_sys_ioctl+0xfb/0x170
 do_syscall_64+0xf3/0x230
 entry_SYSCALL_64_after_hwframe+0x77/0x7f
...
 </TASK>

When 'ioctl(OCFS2_IOC_GROUP_ADD, ...)' has failed for the particular
inode in 'ocfs2_verify_group_and_input()', corresponding buffer head
remains cached and subsequent call to the same 'ioctl()' for the same
inode issues the BUG() in 'ocfs2_set_new_buffer_uptodate()' (trying
to cache the same buffer head of that inode). Fix this by uncaching
the buffer head with 'ocfs2_remove_from_cache()' on error path in
'ocfs2_group_add()'.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('c74d84e428a260961f0a1b68814ccc20badf72de')">
                                    <div class="issue-number">429</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="c74d84e428a260961f0a1b68814ccc20badf72de">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

mm: fix NULL pointer dereference in alloc_pages_bulk_noprof

We triggered a NULL pointer dereference for ac.preferred_zoneref->zone in
alloc_pages_bulk_noprof() when the task is migrated between cpusets.

When cpuset is enabled, in prepare_alloc_pages(), ac->nodemask may be
&current->mems_allowed.  when first_zones_zonelist() is called to find
preferred_zoneref, the ac->nodemask may be modified concurrently if the
task is migrated between different cpusets.  Assuming we have 2 NUMA Node,
when traversing Node1 in ac->zonelist, the nodemask is 2, and when
traversing Node2 in ac->zonelist, the nodemask is 1.  As a result, the
ac->preferred_zoneref points to NULL zone.

In alloc_pages_bulk_noprof(), for_each_zone_zonelist_nodemask() finds a
allowable zone and calls zonelist_node_idx(ac.preferred_zoneref), leading
to NULL pointer dereference.

__alloc_pages_noprof() fixes this issue by checking NULL pointer in commit
ea57485af8f4 ("mm, page_alloc: fix check for NULL preferred_zone") and
commit df76cee6bbeb ("mm, page_alloc: remove redundant checks from alloc
fastpath").

To fix it, check NULL pointer for preferred_zoneref->zone.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('46fba4ee4526bc7d5336f51ee0a960cc6e723804')">
                                    <div class="issue-number">430</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="46fba4ee4526bc7d5336f51ee0a960cc6e723804">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

x86/CPU/AMD: Clear virtualized VMLOAD/VMSAVE on Zen4 client

A number of Zen4 client SoCs advertise the ability to use virtualized
VMLOAD/VMSAVE, but using these instructions is reported to be a cause
of a random host reboot.

These instructions aren't intended to be advertised on Zen4 client
so clear the capability.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('930acb9f2eb93bfe2334f2f3f268a8635fa6d481')">
                                    <div class="issue-number">431</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="930acb9f2eb93bfe2334f2f3f268a8635fa6d481">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

virtio/vsock: Fix accept_queue memory leak

As the final stages of socket destruction may be delayed, it is possible
that virtio_transport_recv_listen() will be called after the accept_queue
has been flushed, but before the SOCK_DONE flag has been set. As a result,
sockets enqueued after the flush would remain unremoved, leading to a
memory leak.

vsock_release
  __vsock_release
    lock
    virtio_transport_release
      virtio_transport_close
        schedule_delayed_work(close_work)
    sk_shutdown = SHUTDOWN_MASK
(!) flush accept_queue
    release
                                        virtio_transport_recv_pkt
                                          vsock_find_bound_socket
                                          lock
                                          if flag(SOCK_DONE) return
                                          virtio_transport_recv_listen
                                            child = vsock_create_connected
                                      (!)   vsock_enqueue_accept(child)
                                          release
close_work
  lock
  virtio_transport_do_close
    set_flag(SOCK_DONE)
    virtio_transport_remove_sock
      vsock_remove_sock
        vsock_remove_bound
  release

Introduce a sk_shutdown check to disallow vsock_enqueue_accept() during
socket destruction.

unreferenced object 0xffff888109e3f800 (size 2040):
  comm "kworker/5:2", pid 371, jiffies 4294940105
  hex dump (first 32 bytes):
    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    28 00 0b 40 00 00 00 00 00 00 00 00 00 00 00 00  (..@............
  backtrace (crc 9e5f4e84):
    [<ffffffff81418ff1>] kmem_cache_alloc_noprof+0x2c1/0x360
    [<ffffffff81d27aa0>] sk_prot_alloc+0x30/0x120
    [<ffffffff81d2b54c>] sk_alloc+0x2c/0x4b0
    [<ffffffff81fe049a>] __vsock_create.constprop.0+0x2a/0x310
    [<ffffffff81fe6d6c>] virtio_transport_recv_pkt+0x4dc/0x9a0
    [<ffffffff81fe745d>] vsock_loopback_work+0xfd/0x140
    [<ffffffff810fc6ac>] process_one_work+0x20c/0x570
    [<ffffffff810fce3f>] worker_thread+0x1bf/0x3a0
    [<ffffffff811070dd>] kthread+0xdd/0x110
    [<ffffffff81044fdd>] ret_from_fork+0x2d/0x50
    [<ffffffff8100785a>] ret_from_fork_asm+0x1a/0x30</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('45b260632f898d8bbbfa2b355af078a4c2a1c0b5')">
                                    <div class="issue-number">432</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="45b260632f898d8bbbfa2b355af078a4c2a1c0b5">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

net/mlx5e: CT: Fix null-ptr-deref in add rule err flow

In error flow of mlx5_tc_ct_entry_add_rule(), in case ct_rule_add()
callback returns error, zone_rule->attr is used uninitiated. Fix it to
use attr which has the needed pointer value.

Kernel log:
 BUG: kernel NULL pointer dereference, address: 0000000000000110
 RIP: 0010:mlx5_tc_ct_entry_add_rule+0x2b1/0x2f0 [mlx5_core]
…
 Call Trace:
  <TASK>
  ? __die+0x20/0x70
  ? page_fault_oops+0x150/0x3e0
  ? exc_page_fault+0x74/0x140
  ? asm_exc_page_fault+0x22/0x30
  ? mlx5_tc_ct_entry_add_rule+0x2b1/0x2f0 [mlx5_core]
  ? mlx5_tc_ct_entry_add_rule+0x1d5/0x2f0 [mlx5_core]
  mlx5_tc_ct_block_flow_offload+0xc6a/0xf90 [mlx5_core]
  ? nf_flow_offload_tuple+0xd8/0x190 [nf_flow_table]
  nf_flow_offload_tuple+0xd8/0x190 [nf_flow_table]
  flow_offload_work_handler+0x142/0x320 [nf_flow_table]
  ? finish_task_switch.isra.0+0x15b/0x2b0
  process_one_work+0x16c/0x320
  worker_thread+0x28c/0x3a0
  ? __pfx_worker_thread+0x10/0x10
  kthread+0xb8/0xf0
  ? __pfx_kthread+0x10/0x10
  ret_from_fork+0x2d/0x50
  ? __pfx_kthread+0x10/0x10
  ret_from_fork_asm+0x1a/0x30
  </TASK></p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('e0610b734855e5f3445afd375581575c2f7ab729')">
                                    <div class="issue-number">433</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="e0610b734855e5f3445afd375581575c2f7ab729">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

net/mlx5: fs, lock FTE when checking if active

The referenced commits introduced a two-step process for deleting FTEs:

- Lock the FTE, delete it from hardware, set the hardware deletion function
  to NULL and unlock the FTE.
- Lock the parent flow group, delete the software copy of the FTE, and
  remove it from the xarray.

However, this approach encounters a race condition if a rule with the same
match value is added simultaneously. In this scenario, fs_core may set the
hardware deletion function to NULL prematurely, causing a panic during
subsequent rule deletions.

To prevent this, ensure the active flag of the FTE is checked under a lock,
which will prevent the fs_core layer from attaching a new steering rule to
an FTE that is in the process of deletion.

[  438.967589] MOSHE: 2496 mlx5_del_flow_rules del_hw_func
[  438.968205] ------------[ cut here ]------------
[  438.968654] refcount_t: decrement hit 0; leaking memory.
[  438.969249] WARNING: CPU: 0 PID: 8957 at lib/refcount.c:31 refcount_warn_saturate+0xfb/0x110
[  438.970054] Modules linked in: act_mirred cls_flower act_gact sch_ingress openvswitch nsh mlx5_vdpa vringh vhost_iotlb vdpa mlx5_ib mlx5_core xt_conntrack xt_MASQUERADE nf_conntrack_netlink nfnetlink xt_addrtype iptable_nat nf_nat br_netfilter rpcsec_gss_krb5 auth_rpcgss oid_registry overlay rpcrdma rdma_ucm ib_iser libiscsi scsi_transport_iscsi ib_umad rdma_cm ib_ipoib iw_cm ib_cm ib_uverbs ib_core zram zsmalloc fuse [last unloaded: cls_flower]
[  438.973288] CPU: 0 UID: 0 PID: 8957 Comm: tc Not tainted 6.12.0-rc1+ #8
[  438.973888] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014
[  438.974874] RIP: 0010:refcount_warn_saturate+0xfb/0x110
[  438.975363] Code: 40 66 3b 82 c6 05 16 e9 4d 01 01 e8 1f 7c a0 ff 0f 0b c3 cc cc cc cc 48 c7 c7 10 66 3b 82 c6 05 fd e8 4d 01 01 e8 05 7c a0 ff <0f> 0b c3 cc cc cc cc 66 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 00 90
[  438.976947] RSP: 0018:ffff888124a53610 EFLAGS: 00010286
[  438.977446] RAX: 0000000000000000 RBX: ffff888119d56de0 RCX: 0000000000000000
[  438.978090] RDX: ffff88852c828700 RSI: ffff88852c81b3c0 RDI: ffff88852c81b3c0
[  438.978721] RBP: ffff888120fa0e88 R08: 0000000000000000 R09: ffff888124a534b0
[  438.979353] R10: 0000000000000001 R11: 0000000000000001 R12: ffff888119d56de0
[  438.979979] R13: ffff888120fa0ec0 R14: ffff888120fa0ee8 R15: ffff888119d56de0
[  438.980607] FS:  00007fe6dcc0f800(0000) GS:ffff88852c800000(0000) knlGS:0000000000000000
[  438.983984] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[  438.984544] CR2: 00000000004275e0 CR3: 0000000186982001 CR4: 0000000000372eb0
[  438.985205] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
[  438.985842] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
[  438.986507] Call Trace:
[  438.986799]  <TASK>
[  438.987070]  ? __warn+0x7d/0x110
[  438.987426]  ? refcount_warn_saturate+0xfb/0x110
[  438.987877]  ? report_bug+0x17d/0x190
[  438.988261]  ? prb_read_valid+0x17/0x20
[  438.988659]  ? handle_bug+0x53/0x90
[  438.989054]  ? exc_invalid_op+0x14/0x70
[  438.989458]  ? asm_exc_invalid_op+0x16/0x20
[  438.989883]  ? refcount_warn_saturate+0xfb/0x110
[  438.990348]  mlx5_del_flow_rules+0x2f7/0x340 [mlx5_core]
[  438.990932]  __mlx5_eswitch_del_rule+0x49/0x170 [mlx5_core]
[  438.991519]  ? mlx5_lag_is_sriov+0x3c/0x50 [mlx5_core]
[  438.992054]  ? xas_load+0x9/0xb0
[  438.992407]  mlx5e_tc_rule_unoffload+0x45/0xe0 [mlx5_core]
[  438.993037]  mlx5e_tc_del_fdb_flow+0x2a6/0x2e0 [mlx5_core]
[  438.993623]  mlx5e_flow_put+0x29/0x60 [mlx5_core]
[  438.994161]  mlx5e_delete_flower+0x261/0x390 [mlx5_core]
[  438.994728]  tc_setup_cb_destroy+0xb9/0x190
[  438.995150]  fl_hw_destroy_filter+0x94/0xc0 [cls_flower]
[  438.995650]  fl_change+0x11a4/0x13c0 [cls_flower]
[  438.996105]  tc_new_tfilter+0x347/0xbc0
[  438.996503]  ? __
---truncated---</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('5385fa223ff34e6033f90df8638a35a9d20a9522')">
                                    <div class="issue-number">434</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="5385fa223ff34e6033f90df8638a35a9d20a9522">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

mptcp: cope racing subflow creation in mptcp_rcv_space_adjust

Additional active subflows - i.e. created by the in kernel path
manager - are included into the subflow list before starting the
3whs.

A racing recvmsg() spooling data received on an already established
subflow would unconditionally call tcp_cleanup_rbuf() on all the
current subflows, potentially hitting a divide by zero error on
the newly created ones.

Explicitly check that the subflow is in a suitable state before
invoking tcp_cleanup_rbuf().</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('d454475f1f3df12c48e5b6816eaf9aacbe511d57')">
                                    <div class="issue-number">435</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="d454475f1f3df12c48e5b6816eaf9aacbe511d57">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

mptcp: error out earlier on disconnect

Eric reported a division by zero splat in the MPTCP protocol:

Oops: divide error: 0000 [#1] PREEMPT SMP KASAN PTI
CPU: 1 UID: 0 PID: 6094 Comm: syz-executor317 Not tainted
6.12.0-rc5-syzkaller-00291-g05b92660cdfe #0
Hardware name: Google Google Compute Engine/Google Compute Engine,
BIOS Google 09/13/2024
RIP: 0010:__tcp_select_window+0x5b4/0x1310 net/ipv4/tcp_output.c:3163
Code: f6 44 01 e3 89 df e8 9b 75 09 f8 44 39 f3 0f 8d 11 ff ff ff e8
0d 74 09 f8 45 89 f4 e9 04 ff ff ff e8 00 74 09 f8 44 89 f0 99 <f7> 7c
24 14 41 29 d6 45 89 f4 e9 ec fe ff ff e8 e8 73 09 f8 48 89
RSP: 0018:ffffc900041f7930 EFLAGS: 00010293
RAX: 0000000000017e67 RBX: 0000000000017e67 RCX: ffffffff8983314b
RDX: 0000000000000000 RSI: ffffffff898331b0 RDI: 0000000000000004
RBP: 00000000005d6000 R08: 0000000000000004 R09: 0000000000017e67
R10: 0000000000003e80 R11: 0000000000000000 R12: 0000000000003e80
R13: ffff888031d9b440 R14: 0000000000017e67 R15: 00000000002eb000
FS: 00007feb5d7f16c0(0000) GS:ffff8880b8700000(0000) knlGS:0000000000000000
CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007feb5d8adbb8 CR3: 0000000074e4c000 CR4: 00000000003526f0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
Call Trace:
<TASK>
__tcp_cleanup_rbuf+0x3e7/0x4b0 net/ipv4/tcp.c:1493
mptcp_rcv_space_adjust net/mptcp/protocol.c:2085 [inline]
mptcp_recvmsg+0x2156/0x2600 net/mptcp/protocol.c:2289
inet_recvmsg+0x469/0x6a0 net/ipv4/af_inet.c:885
sock_recvmsg_nosec net/socket.c:1051 [inline]
sock_recvmsg+0x1b2/0x250 net/socket.c:1073
__sys_recvfrom+0x1a5/0x2e0 net/socket.c:2265
__do_sys_recvfrom net/socket.c:2283 [inline]
__se_sys_recvfrom net/socket.c:2279 [inline]
__x64_sys_recvfrom+0xe0/0x1c0 net/socket.c:2279
do_syscall_x64 arch/x86/entry/common.c:52 [inline]
do_syscall_64+0xcd/0x250 arch/x86/entry/common.c:83
entry_SYSCALL_64_after_hwframe+0x77/0x7f
RIP: 0033:0x7feb5d857559
Code: 28 00 00 00 75 05 48 83 c4 28 c3 e8 51 18 00 00 90 48 89 f8 48
89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d
01 f0 ff ff 73 01 c3 48 c7 c1 b0 ff ff ff f7 d8 64 89 01 48
RSP: 002b:00007feb5d7f1208 EFLAGS: 00000246 ORIG_RAX: 000000000000002d
RAX: ffffffffffffffda RBX: 00007feb5d8e1318 RCX: 00007feb5d857559
RDX: 000000800000000e RSI: 0000000000000000 RDI: 0000000000000003
RBP: 00007feb5d8e1310 R08: 0000000000000000 R09: ffffffff81000000
R10: 0000000000000100 R11: 0000000000000246 R12: 00007feb5d8e131c
R13: 00007feb5d8ae074 R14: 000000800000000e R15: 00000000fffffdef

and provided a nice reproducer.

The root cause is the current bad handling of racing disconnect.
After the blamed commit below, sk_wait_data() can return (with
error) with the underlying socket disconnected and a zero rcv_mss.

Catch the error and return without performing any additional
operations on the current socket.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('1396cb5144aa90c5790f7f48ca66f2b1eaa5a26a')">
                                    <div class="issue-number">436</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="1396cb5144aa90c5790f7f48ca66f2b1eaa5a26a">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

net: fix data-races around sk->sk_forward_alloc

Syzkaller reported this warning:
 ------------[ cut here ]------------
 WARNING: CPU: 0 PID: 16 at net/ipv4/af_inet.c:156 inet_sock_destruct+0x1c5/0x1e0
 Modules linked in:
 CPU: 0 UID: 0 PID: 16 Comm: ksoftirqd/0 Not tainted 6.12.0-rc5 #26
 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014
 RIP: 0010:inet_sock_destruct+0x1c5/0x1e0
 Code: 24 12 4c 89 e2 5b 48 c7 c7 98 ec bb 82 41 5c e9 d1 18 17 ff 4c 89 e6 5b 48 c7 c7 d0 ec bb 82 41 5c e9 bf 18 17 ff 0f 0b eb 83 <0f> 0b eb 97 0f 0b eb 87 0f 0b e9 68 ff ff ff 66 66 2e 0f 1f 84 00
 RSP: 0018:ffffc9000008bd90 EFLAGS: 00010206
 RAX: 0000000000000300 RBX: ffff88810b172a90 RCX: 0000000000000007
 RDX: 0000000000000002 RSI: 0000000000000300 RDI: ffff88810b172a00
 RBP: ffff88810b172a00 R08: ffff888104273c00 R09: 0000000000100007
 R10: 0000000000020000 R11: 0000000000000006 R12: ffff88810b172a00
 R13: 0000000000000004 R14: 0000000000000000 R15: ffff888237c31f78
 FS:  0000000000000000(0000) GS:ffff888237c00000(0000) knlGS:0000000000000000
 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
 CR2: 00007ffc63fecac8 CR3: 000000000342e000 CR4: 00000000000006f0
 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
 Call Trace:
  <TASK>
  ? __warn+0x88/0x130
  ? inet_sock_destruct+0x1c5/0x1e0
  ? report_bug+0x18e/0x1a0
  ? handle_bug+0x53/0x90
  ? exc_invalid_op+0x18/0x70
  ? asm_exc_invalid_op+0x1a/0x20
  ? inet_sock_destruct+0x1c5/0x1e0
  __sk_destruct+0x2a/0x200
  rcu_do_batch+0x1aa/0x530
  ? rcu_do_batch+0x13b/0x530
  rcu_core+0x159/0x2f0
  handle_softirqs+0xd3/0x2b0
  ? __pfx_smpboot_thread_fn+0x10/0x10
  run_ksoftirqd+0x25/0x30
  smpboot_thread_fn+0xdd/0x1d0
  kthread+0xd3/0x100
  ? __pfx_kthread+0x10/0x10
  ret_from_fork+0x34/0x50
  ? __pfx_kthread+0x10/0x10
  ret_from_fork_asm+0x1a/0x30
  </TASK>
 ---[ end trace 0000000000000000 ]---

Its possible that two threads call tcp_v6_do_rcv()/sk_forward_alloc_add()
concurrently when sk->sk_state == TCP_LISTEN with sk->sk_lock unlocked,
which triggers a data-race around sk->sk_forward_alloc:
tcp_v6_rcv
    tcp_v6_do_rcv
        skb_clone_and_charge_r
            sk_rmem_schedule
                __sk_mem_schedule
                    sk_forward_alloc_add()
            skb_set_owner_r
                sk_mem_charge
                    sk_forward_alloc_add()
        __kfree_skb
            skb_release_all
                skb_release_head_state
                    sock_rfree
                        sk_mem_uncharge
                            sk_forward_alloc_add()
                            sk_mem_reclaim
                                // set local var reclaimable
                                __sk_mem_reclaim
                                    sk_forward_alloc_add()

In this syzkaller testcase, two threads call
tcp_v6_do_rcv() with skb->truesize=768, the sk_forward_alloc changes like
this:
 (cpu 1)             | (cpu 2)             | sk_forward_alloc
 ...                 | ...                 | 0
 __sk_mem_schedule() |                     | +4096 = 4096
                     | __sk_mem_schedule() | +4096 = 8192
 sk_mem_charge()     |                     | -768  = 7424
                     | sk_mem_charge()     | -768  = 6656
 ...                 |    ...              |
 sk_mem_uncharge()   |                     | +768  = 7424
 reclaimable=7424    |                     |
                     | sk_mem_uncharge()   | +768  = 8192
                     | reclaimable=8192    |
 __sk_mem_reclaim()  |                     | -4096 = 4096
                     | __sk_mem_reclaim()  | -8192 = -4096 != 0

The skb_clone_and_charge_r() should not be called in tcp_v6_do_rcv() when
sk->sk_state is TCP_LISTEN, it happens later in tcp_v6_syn_recv_sock().
Fix the same issue in dccp_v6_do_rcv().</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('5153fd56dc1db91f6c05cefec4d59aecfda3a5fb')">
                                    <div class="issue-number">437</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="5153fd56dc1db91f6c05cefec4d59aecfda3a5fb">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A flaw was found in shadow-utils. When asking for a new password, shadow-utils asks the password twice. If the password fails on the second attempt, shadow-utils fails in cleaning the buffer used to store the first entry. This may allow an attacker with enough access to retrieve the password from the memory.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('6e73a6c3fafd923e7cd568406f06219a934a1d58')">
                                    <div class="issue-number">438</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="6e73a6c3fafd923e7cd568406f06219a934a1d58">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Vulnerability in the MySQL Server product of Oracle MySQL (component: Client: mysqldump).  Supported versions that are affected are 8.0.36 and prior and  8.3.0 and prior. Difficult to exploit vulnerability allows unauthenticated attacker with logon to the infrastructure where MySQL Server executes to compromise MySQL Server.  Successful attacks of this vulnerability can result in  unauthorized update, insert or delete access to some of MySQL Server accessible data as well as  unauthorized read access to a subset of MySQL Server accessible data and unauthorized ability to cause a partial denial of service (partial DOS) of MySQL Server. CVSS 3.1 Base Score 4.9 (Confidentiality, Integrity and Availability impacts).  CVSS Vector: (CVSS:3.1/AV:L/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:L).</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('c44cc176f395701fb3a00b53b316f01415721eb8')">
                                    <div class="issue-number">439</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="c44cc176f395701fb3a00b53b316f01415721eb8">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> NCurse v6.4-20230418 was discovered to contain a segmentation fault via the component _nc_wrap_entry().</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('216b77890482164bbe34c76cb6535b12c33fc124')">
                                    <div class="issue-number">440</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="216b77890482164bbe34c76cb6535b12c33fc124">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> NCurse v6.4-20230418 was discovered to contain a segmentation fault via the component _nc_wrap_entry().</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('7c23dedcbed457597197851b8fe5c982887c7194')">
                                    <div class="issue-number">441</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="7c23dedcbed457597197851b8fe5c982887c7194">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A flaw was found in shadow-utils. When asking for a new password, shadow-utils asks the password twice. If the password fails on the second attempt, shadow-utils fails in cleaning the buffer used to store the first entry. This may allow an attacker with enough access to retrieve the password from the memory.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('db418a2b8bcc81a89f9ecbbde977262b56937c18')">
                                    <div class="issue-number">442</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="db418a2b8bcc81a89f9ecbbde977262b56937c18">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The email module of Python through 3.11.3 incorrectly parses e-mail addresses that contain a special character. The wrong portion of an RFC2822 header is identified as the value of the addr-spec. In some applications, an attacker can bypass a protection mechanism in which application access is granted only after verifying receipt of e-mail to a specific domain (e.g., only @company.example.com addresses may be used for signup). This occurs in email/_parseaddr.py in recent versions of Python.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('eeb101f3d6032f357d218a9ebe8b36c18b531781')">
                                    <div class="issue-number">443</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="eeb101f3d6032f357d218a9ebe8b36c18b531781">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> There is a MEDIUM severity vulnerability affecting CPython.

The 
email module didn’t properly quote newlines for email headers when 
serializing an email message allowing for header injection when an email
 is serialized.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('86eb95151ba1e8cbad2a3cc90f1f1970a66ea874')">
                                    <div class="issue-number">444</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="86eb95151ba1e8cbad2a3cc90f1f1970a66ea874">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A vulnerability has been found in the CPython `venv` module and CLI where path names provided when creating a virtual environment were not quoted properly, allowing the creator to inject commands into virtual environment "activation" scripts (ie "source venv/bin/activate"). This means that attacker-controlled virtual environments are able to run commands when the virtual environment is activated. Virtual environments which are not created by an attacker or which aren't activated before being used (ie "./venv/bin/python") are not affected.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('ad0cfafbd6f210f5290f57a369fe9267d870c2a4')">
                                    <div class="issue-number">445</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="ad0cfafbd6f210f5290f57a369fe9267d870c2a4">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The email module of Python through 3.11.3 incorrectly parses e-mail addresses that contain a special character. The wrong portion of an RFC2822 header is identified as the value of the addr-spec. In some applications, an attacker can bypass a protection mechanism in which application access is granted only after verifying receipt of e-mail to a specific domain (e.g., only @company.example.com addresses may be used for signup). This occurs in email/_parseaddr.py in recent versions of Python.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('2a747cf669cb356d785787fca3c96a01f7144a14')">
                                    <div class="issue-number">446</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="2a747cf669cb356d785787fca3c96a01f7144a14">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> There is a MEDIUM severity vulnerability affecting CPython.

The 
email module didn’t properly quote newlines for email headers when 
serializing an email message allowing for header injection when an email
 is serialized.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('7c9e42e36010cfae0d65dd9eb7a3c18af8639fac')">
                                    <div class="issue-number">447</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="7c9e42e36010cfae0d65dd9eb7a3c18af8639fac">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A vulnerability has been found in the CPython `venv` module and CLI where path names provided when creating a virtual environment were not quoted properly, allowing the creator to inject commands into virtual environment "activation" scripts (ie "source venv/bin/activate"). This means that attacker-controlled virtual environments are able to run commands when the virtual environment is activated. Virtual environments which are not created by an attacker or which aren't activated before being used (ie "./venv/bin/python") are not affected.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('d30c31d867ffc29ab0f89efabaa6f285764ed42f')">
                                    <div class="issue-number">448</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="d30c31d867ffc29ab0f89efabaa6f285764ed42f">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> GNU Wget through 1.21.1 does not omit the Authorization header upon a redirect to a different origin, a related issue to CVE-2018-1000007.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-medium"
                                     onclick="toggleDetail('fbdd696af911da03fc628a8db0011d329b9a3f17')">
                                    <div class="issue-number">449</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="fbdd696af911da03fc628a8db0011d329b9a3f17">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Medium</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Applications that use Wget to access a remote resource using shorthand URLs and pass arbitrary user credentials in the URL are vulnerable. In these cases attackers can enter crafted credentials which will cause Wget to access an arbitrary host.</p>
                                </div>
                            </li>
                        
                    </ul>
                
            
                
                    <h3>Low 风险漏洞（共558个）：</h3>
                    <ul>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('a65877bdd445f5931d550fb665cdc5bb6f0c22cb')">
                                    <div class="issue-number">1</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="a65877bdd445f5931d550fb665cdc5bb6f0c22cb">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> It was found that apt-key in apt, all versions, do not correctly validate gpg keys with the master keyring, leading to a potential man-in-the-middle attack.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('6ee9c8885675e09a8563ee9f51eee5577ae6b1d1')">
                                    <div class="issue-number">2</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="6ee9c8885675e09a8563ee9f51eee5577ae6b1d1">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> TEMP-0841856-B18BAF</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('0f876f8735d6745a5ee5abfbbf8c7a39b8ce7c2a')">
                                    <div class="issue-number">3</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="0f876f8735d6745a5ee5abfbbf8c7a39b8ce7c2a">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The C++ symbol demangler routine in cplus-dem.c in libiberty, as distributed in GNU Binutils 2.29, allows remote attackers to cause a denial of service (excessive memory allocation and application crash) via a crafted file, as demonstrated by a call from the Binary File Descriptor (BFD) library (aka libbfd).</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('91db7931036ae2081fec38f047592e7dab0f66d8')">
                                    <div class="issue-number">4</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="91db7931036ae2081fec38f047592e7dab0f66d8">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The demangle_template function in cplus-dem.c in GNU libiberty, as distributed in GNU Binutils 2.31.1, contains an integer overflow vulnerability (for "Create an array for saving the template argument values") that can trigger a heap-based buffer overflow, as demonstrated by nm.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('cca46dc62d1f24dacca08d45e5ba694a43107a06')">
                                    <div class="issue-number">5</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="cca46dc62d1f24dacca08d45e5ba694a43107a06">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A heap-based buffer over-read exists in the function d_expression_1 in cp-demangle.c in GNU libiberty, as distributed in GNU Binutils 2.31.1. A crafted input can cause segmentation faults, leading to denial-of-service, as demonstrated by c++filt.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('bf422bec61e9160f5d18cc38df19a725ce5e4894')">
                                    <div class="issue-number">6</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="bf422bec61e9160f5d18cc38df19a725ce5e4894">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in cplus-dem.c in GNU libiberty, as distributed in GNU Binutils 2.30. Stack Exhaustion occurs in the C++ demangling functions provided by libiberty, and there are recursive stack frames: demangle_template_value_parm, demangle_integral_value, and demangle_expression.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('4ecb61e3dffc9bac9e875d4d99d913f46edbc6ba')">
                                    <div class="issue-number">7</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="4ecb61e3dffc9bac9e875d4d99d913f46edbc6ba">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in GNU libiberty, as distributed in GNU Binutils 2.36. It is a stack-overflow issue in demangle_type in rust-demangle.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('0d1d9cef43394e14f5e73344e0f6416ffcff923b')">
                                    <div class="issue-number">8</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="0d1d9cef43394e14f5e73344e0f6416ffcff923b">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A potential heap based buffer overflow was found in _bfd_elf_slurp_version_tables() in bfd/elf.c. This may lead to loss of availability.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('2b8eb0cb24846c2aaacd042ab522808aa8b96dd7')">
                                    <div class="issue-number">9</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="2b8eb0cb24846c2aaacd042ab522808aa8b96dd7">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The C++ symbol demangler routine in cplus-dem.c in libiberty, as distributed in GNU Binutils 2.29, allows remote attackers to cause a denial of service (excessive memory allocation and application crash) via a crafted file, as demonstrated by a call from the Binary File Descriptor (BFD) library (aka libbfd).</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('13a31cdb61d7b3aeed18de95f29421361910fd96')">
                                    <div class="issue-number">10</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="13a31cdb61d7b3aeed18de95f29421361910fd96">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The demangle_template function in cplus-dem.c in GNU libiberty, as distributed in GNU Binutils 2.31.1, contains an integer overflow vulnerability (for "Create an array for saving the template argument values") that can trigger a heap-based buffer overflow, as demonstrated by nm.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('762588db276ce7fcbbb3b8e5ba1ed20f305bc659')">
                                    <div class="issue-number">11</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="762588db276ce7fcbbb3b8e5ba1ed20f305bc659">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A heap-based buffer over-read exists in the function d_expression_1 in cp-demangle.c in GNU libiberty, as distributed in GNU Binutils 2.31.1. A crafted input can cause segmentation faults, leading to denial-of-service, as demonstrated by c++filt.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('62024a5cf8c0c13f02c0b4251a675337e6eaa320')">
                                    <div class="issue-number">12</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="62024a5cf8c0c13f02c0b4251a675337e6eaa320">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in cplus-dem.c in GNU libiberty, as distributed in GNU Binutils 2.30. Stack Exhaustion occurs in the C++ demangling functions provided by libiberty, and there are recursive stack frames: demangle_template_value_parm, demangle_integral_value, and demangle_expression.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('f42c43625c825e346ca50dfe59ec3a5e52b7130c')">
                                    <div class="issue-number">13</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="f42c43625c825e346ca50dfe59ec3a5e52b7130c">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in GNU libiberty, as distributed in GNU Binutils 2.36. It is a stack-overflow issue in demangle_type in rust-demangle.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('c694f43adff6d1552a477e9acdf6123958b778b6')">
                                    <div class="issue-number">14</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="c694f43adff6d1552a477e9acdf6123958b778b6">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A potential heap based buffer overflow was found in _bfd_elf_slurp_version_tables() in bfd/elf.c. This may lead to loss of availability.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('7983d20d7e0b738214807699f511b2c1b9be87b8')">
                                    <div class="issue-number">15</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="7983d20d7e0b738214807699f511b2c1b9be87b8">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The C++ symbol demangler routine in cplus-dem.c in libiberty, as distributed in GNU Binutils 2.29, allows remote attackers to cause a denial of service (excessive memory allocation and application crash) via a crafted file, as demonstrated by a call from the Binary File Descriptor (BFD) library (aka libbfd).</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('b637d227805a2070bd9e93f465be237df69b6614')">
                                    <div class="issue-number">16</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="b637d227805a2070bd9e93f465be237df69b6614">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The demangle_template function in cplus-dem.c in GNU libiberty, as distributed in GNU Binutils 2.31.1, contains an integer overflow vulnerability (for "Create an array for saving the template argument values") that can trigger a heap-based buffer overflow, as demonstrated by nm.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('7c1d7a94f330448e09752056e274423016e5e49d')">
                                    <div class="issue-number">17</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="7c1d7a94f330448e09752056e274423016e5e49d">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A heap-based buffer over-read exists in the function d_expression_1 in cp-demangle.c in GNU libiberty, as distributed in GNU Binutils 2.31.1. A crafted input can cause segmentation faults, leading to denial-of-service, as demonstrated by c++filt.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('de8a743f919f66a3d3b499f479981f315aa8a6a2')">
                                    <div class="issue-number">18</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="de8a743f919f66a3d3b499f479981f315aa8a6a2">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in cplus-dem.c in GNU libiberty, as distributed in GNU Binutils 2.30. Stack Exhaustion occurs in the C++ demangling functions provided by libiberty, and there are recursive stack frames: demangle_template_value_parm, demangle_integral_value, and demangle_expression.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('a3fd6129133dc806fc5569a4614053b14f8c1a14')">
                                    <div class="issue-number">19</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="a3fd6129133dc806fc5569a4614053b14f8c1a14">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in GNU libiberty, as distributed in GNU Binutils 2.36. It is a stack-overflow issue in demangle_type in rust-demangle.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('69869dd41dd7bf0a2279f9670b501d44372bbae9')">
                                    <div class="issue-number">20</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="69869dd41dd7bf0a2279f9670b501d44372bbae9">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A potential heap based buffer overflow was found in _bfd_elf_slurp_version_tables() in bfd/elf.c. This may lead to loss of availability.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('2cb0149257a7d54dcf3c365483c9f9165af38910')">
                                    <div class="issue-number">21</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="2cb0149257a7d54dcf3c365483c9f9165af38910">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an "INPUTRC" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('4727c97309cab85eb7ca799e619c5a34590495d6')">
                                    <div class="issue-number">22</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="4727c97309cab85eb7ca799e619c5a34590495d6">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> chroot in GNU coreutils, when used with --userspec, allows local users to escape to the parent session via a crafted TIOCSTI ioctl call, which pushes characters to the terminal's input buffer.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('2a046c927b543b95092f5dd88cc8fa49de0343ce')">
                                    <div class="issue-number">23</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="2a046c927b543b95092f5dd88cc8fa49de0343ce">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In GNU Coreutils through 8.29, chown-core.c in chown and chgrp does not prevent replacement of a plain file with a symlink during use of the POSIX "-R -L" options, which allows local users to modify the ownership of arbitrary files by leveraging a race condition.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('8f283237e93a9db594c1e560741f19ccb31bb14e')">
                                    <div class="issue-number">24</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="8f283237e93a9db594c1e560741f19ccb31bb14e">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> libiberty/rust-demangle.c in GNU GCC 11.2 allows stack consumption in demangle_const, as demonstrated by nm-new.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('37f52b1967af3e3481bdb950f6bf0d608a6a1f0a')">
                                    <div class="issue-number">25</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="37f52b1967af3e3481bdb950f6bf0d608a6a1f0a">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> 

**DISPUTED**A failure in the -fstack-protector feature in GCC-based toolchains 
that target AArch64 allows an attacker to exploit an existing buffer 
overflow in dynamically-sized local variables in your application 
without this being detected. This stack-protector failure only applies 
to C99-style dynamically-sized local variables or those created using 
alloca(). The stack-protector operates as intended for statically-sized 
local variables.

The default behavior when the stack-protector 
detects an overflow is to terminate your application, resulting in 
controlled loss of availability. An attacker who can exploit a buffer 
overflow without triggering the stack-protector might be able to change 
program flow control to cause an uncontrolled loss of availability or to
 go further and affect confidentiality or integrity. NOTE: The GCC project argues that this is a missed hardening bug and not a vulnerability by itself.





</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('b2bc681d634444acceda64431646def1918a6ea0')">
                                    <div class="issue-number">26</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="b2bc681d634444acceda64431646def1918a6ea0">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> libcurl skips the certificate verification for a QUIC connection under certain conditions, when built to use wolfSSL. If told to use an unknown/bad cipher or curve, the error path accidentally skips the verification and returns OK, thus ignoring any certificate problems.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('421a6c1fefe7d40e855b159348ba58e00a4aa7d6')">
                                    <div class="issue-number">27</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="421a6c1fefe7d40e855b159348ba58e00a4aa7d6">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> GnuPG can be made to spin on a relatively small input by (for example) crafting a public key with thousands of signatures attached, compressed down to just a few KB.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('7b2f139fe3dcef8350ae2fc314b8ded9e1b7b0bf')">
                                    <div class="issue-number">28</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="7b2f139fe3dcef8350ae2fc314b8ded9e1b7b0bf">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> libiberty/rust-demangle.c in GNU GCC 11.2 allows stack consumption in demangle_const, as demonstrated by nm-new.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('b4b860242b7f1cf2058b1998f16f967eb84cd413')">
                                    <div class="issue-number">29</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="b4b860242b7f1cf2058b1998f16f967eb84cd413">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> 

**DISPUTED**A failure in the -fstack-protector feature in GCC-based toolchains 
that target AArch64 allows an attacker to exploit an existing buffer 
overflow in dynamically-sized local variables in your application 
without this being detected. This stack-protector failure only applies 
to C99-style dynamically-sized local variables or those created using 
alloca(). The stack-protector operates as intended for statically-sized 
local variables.

The default behavior when the stack-protector 
detects an overflow is to terminate your application, resulting in 
controlled loss of availability. An attacker who can exploit a buffer 
overflow without triggering the stack-protector might be able to change 
program flow control to cause an uncontrolled loss of availability or to
 go further and affect confidentiality or integrity. NOTE: The GCC project argues that this is a missed hardening bug and not a vulnerability by itself.





</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('0c9042c94b596cf82853c880cfb9d3f081ab6ddc')">
                                    <div class="issue-number">30</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="0c9042c94b596cf82853c880cfb9d3f081ab6ddc">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> libiberty/rust-demangle.c in GNU GCC 11.2 allows stack consumption in demangle_const, as demonstrated by nm-new.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('7cf43725156250ae31f8b101536fcdf516d4dfef')">
                                    <div class="issue-number">31</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="7cf43725156250ae31f8b101536fcdf516d4dfef">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> 

**DISPUTED**A failure in the -fstack-protector feature in GCC-based toolchains 
that target AArch64 allows an attacker to exploit an existing buffer 
overflow in dynamically-sized local variables in your application 
without this being detected. This stack-protector failure only applies 
to C99-style dynamically-sized local variables or those created using 
alloca(). The stack-protector operates as intended for statically-sized 
local variables.

The default behavior when the stack-protector 
detects an overflow is to terminate your application, resulting in 
controlled loss of availability. An attacker who can exploit a buffer 
overflow without triggering the stack-protector might be able to change 
program flow control to cause an uncontrolled loss of availability or to
 go further and affect confidentiality or integrity. NOTE: The GCC project argues that this is a missed hardening bug and not a vulnerability by itself.





</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('04015f25605c435edb98f5290185edddf37663ff')">
                                    <div class="issue-number">32</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="04015f25605c435edb98f5290185edddf37663ff">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> libiberty/rust-demangle.c in GNU GCC 11.2 allows stack consumption in demangle_const, as demonstrated by nm-new.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('cb7d2a407e9c7d32fe5cc381606a86d16f2b8621')">
                                    <div class="issue-number">33</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="cb7d2a407e9c7d32fe5cc381606a86d16f2b8621">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> 

**DISPUTED**A failure in the -fstack-protector feature in GCC-based toolchains 
that target AArch64 allows an attacker to exploit an existing buffer 
overflow in dynamically-sized local variables in your application 
without this being detected. This stack-protector failure only applies 
to C99-style dynamically-sized local variables or those created using 
alloca(). The stack-protector operates as intended for statically-sized 
local variables.

The default behavior when the stack-protector 
detects an overflow is to terminate your application, resulting in 
controlled loss of availability. An attacker who can exploit a buffer 
overflow without triggering the stack-protector might be able to change 
program flow control to cause an uncontrolled loss of availability or to
 go further and affect confidentiality or integrity. NOTE: The GCC project argues that this is a missed hardening bug and not a vulnerability by itself.





</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('a35702bf94f3b672f74cd95a14a3eb4836587992')">
                                    <div class="issue-number">34</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="a35702bf94f3b672f74cd95a14a3eb4836587992">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The _bfd_XXi_swap_aouthdr_in function in bfd/peXXigen.c in GNU binutils 2.24 and earlier allows remote attackers to cause a denial of service (out-of-bounds write) and possibly have other unspecified impact via a crafted NumberOfRvaAndSizes field in the AOUT header in a PE executable.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('b0e222c6f9aee827252a74961a00eff6cb6076cc')">
                                    <div class="issue-number">35</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="b0e222c6f9aee827252a74961a00eff6cb6076cc">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> GNU gdb (GDB) 13.0.50.20220805-git was discovered to contain a stack overflow via the function ada_decode at /gdb/ada-lang.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('983e64f208c4e87fb682f5e822e994c318ad0e6d')">
                                    <div class="issue-number">36</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="983e64f208c4e87fb682f5e822e994c318ad0e6d">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> GNU gdb (GDB) 13.0.50.20220805-git was discovered to contain a heap use after free via the function add_pe_exported_sym() at /gdb/coff-pe-read.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('5ef3d813d9b4acf073b7fe11aa65cbe788a64eab')">
                                    <div class="issue-number">37</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="5ef3d813d9b4acf073b7fe11aa65cbe788a64eab">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> GNU gdb (GDB) 13.0.50.20220805-git was discovered to contain a heap buffer overflow via the function pe_as16() at /gdb/coff-pe-read.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('569a1c75d2606382234656b19937ed72875b73b2')">
                                    <div class="issue-number">38</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="569a1c75d2606382234656b19937ed72875b73b2">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> GIT version 2.15.1 and earlier contains a Input Validation Error vulnerability in Client that can result in problems including messing up terminal configuration to RCE. This attack appear to be exploitable via The user must interact with a malicious git server, (or have their traffic modified in a MITM attack).</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('151392809c68b2b55293dafe4d44463405bd5a31')">
                                    <div class="issue-number">39</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="151392809c68b2b55293dafe4d44463405bd5a31">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The --mirror documentation for Git through 2.35.1 does not mention the availability of deleted content, aka the "GitBleed" issue. This could present a security risk if information-disclosure auditing processes rely on a clone operation without the --mirror option. Note: This has been disputed by multiple 3rd parties who believe this is an intended feature of the git binary and does not pose a security risk.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('25d4610cfd0735d1e717f2b1eb205a29ba78d996')">
                                    <div class="issue-number">40</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="25d4610cfd0735d1e717f2b1eb205a29ba78d996">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> GIT version 2.15.1 and earlier contains a Input Validation Error vulnerability in Client that can result in problems including messing up terminal configuration to RCE. This attack appear to be exploitable via The user must interact with a malicious git server, (or have their traffic modified in a MITM attack).</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('d456911f9050b9c8aed34b5f30edd045feb12877')">
                                    <div class="issue-number">41</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="d456911f9050b9c8aed34b5f30edd045feb12877">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The --mirror documentation for Git through 2.35.1 does not mention the availability of deleted content, aka the "GitBleed" issue. This could present a security risk if information-disclosure auditing processes rely on a clone operation without the --mirror option. Note: This has been disputed by multiple 3rd parties who believe this is an intended feature of the git binary and does not pose a security risk.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('f03d851b5fb98d8dad7ec450f7abcb9fa1de3332')">
                                    <div class="issue-number">42</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="f03d851b5fb98d8dad7ec450f7abcb9fa1de3332">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> GnuPG can be made to spin on a relatively small input by (for example) crafting a public key with thousands of signatures attached, compressed down to just a few KB.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('b6d7222fa343f10d993d97cc24c0cb5ee538ee50')">
                                    <div class="issue-number">43</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="b6d7222fa343f10d993d97cc24c0cb5ee538ee50">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> GnuPG can be made to spin on a relatively small input by (for example) crafting a public key with thousands of signatures attached, compressed down to just a few KB.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('0b97535f11c231e74865875ffb187a37dba0f3ff')">
                                    <div class="issue-number">44</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="0b97535f11c231e74865875ffb187a37dba0f3ff">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> GnuPG can be made to spin on a relatively small input by (for example) crafting a public key with thousands of signatures attached, compressed down to just a few KB.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('e84d755410dd9a05c13697018b9ebc98c0547f48')">
                                    <div class="issue-number">45</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="e84d755410dd9a05c13697018b9ebc98c0547f48">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> GnuPG can be made to spin on a relatively small input by (for example) crafting a public key with thousands of signatures attached, compressed down to just a few KB.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('5d2fa9b3e59dee8a32042564354f193ea09fe06d')">
                                    <div class="issue-number">46</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="5d2fa9b3e59dee8a32042564354f193ea09fe06d">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> GnuPG can be made to spin on a relatively small input by (for example) crafting a public key with thousands of signatures attached, compressed down to just a few KB.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('0212dc6edc5d28c9601461b3f5f61ecf078cc3db')">
                                    <div class="issue-number">47</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="0212dc6edc5d28c9601461b3f5f61ecf078cc3db">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> GnuPG can be made to spin on a relatively small input by (for example) crafting a public key with thousands of signatures attached, compressed down to just a few KB.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('6eb22eb71c632b3af13594e6ed2007e7dd68305a')">
                                    <div class="issue-number">48</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="6eb22eb71c632b3af13594e6ed2007e7dd68305a">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> GnuPG can be made to spin on a relatively small input by (for example) crafting a public key with thousands of signatures attached, compressed down to just a few KB.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('6e61868f96f20afa1c6ac2b8d3912c3dfbdb1532')">
                                    <div class="issue-number">49</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="6e61868f96f20afa1c6ac2b8d3912c3dfbdb1532">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> GnuPG can be made to spin on a relatively small input by (for example) crafting a public key with thousands of signatures attached, compressed down to just a few KB.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('63b32247f0d93836ee1f997d0170d95edcbc98ff')">
                                    <div class="issue-number">50</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="63b32247f0d93836ee1f997d0170d95edcbc98ff">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> GnuPG can be made to spin on a relatively small input by (for example) crafting a public key with thousands of signatures attached, compressed down to just a few KB.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('694bbffe3a53ad80fdf98da52ac1a508ed851c1f')">
                                    <div class="issue-number">51</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="694bbffe3a53ad80fdf98da52ac1a508ed851c1f">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> GnuPG can be made to spin on a relatively small input by (for example) crafting a public key with thousands of signatures attached, compressed down to just a few KB.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('95005322714157ebfbb475414782145999ffe86c')">
                                    <div class="issue-number">52</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="95005322714157ebfbb475414782145999ffe86c">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A design flaw in image processing software that modifies JPEG images might not modify the original EXIF thumbnail, which could lead to an information leak of potentially sensitive visual information that had been removed from the main JPEG image.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('8617c19feb1837480277dd0367b97abd120fabc9')">
                                    <div class="issue-number">53</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="8617c19feb1837480277dd0367b97abd120fabc9">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Multiple unspecified vulnerabilities in GraphicsMagick before 1.2.4 allow remote attackers to cause a denial of service (crash, infinite loop, or memory consumption) via (a) unspecified vectors in the (1) AVI, (2) AVS, (3) DCM, (4) EPT, (5) FITS, (6) MTV, (7) PALM, (8) RLA, and (9) TGA decoder readers; and (b) the GetImageCharacteristics function in magick/image.c, as reachable from a crafted (10) PNG, (11) JPEG, (12) BMP, or (13) TIFF file.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('0c08cebf560e9805b1c9f8cad819f638933d9a57')">
                                    <div class="issue-number">54</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="0c08cebf560e9805b1c9f8cad819f638933d9a57">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The IsPixelMonochrome function in MagickCore/pixel-accessor.h in ImageMagick 7.0.3.0 allows remote attackers to cause a denial of service (out-of-bounds read and crash) via a crafted file.  NOTE: the vendor says "This is a Q64 issue and we do not support Q64."</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('6d86d8207be1b7ed24489a9d3aae6a8e1aa316b1')">
                                    <div class="issue-number">55</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="6d86d8207be1b7ed24489a9d3aae6a8e1aa316b1">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The WritePICONImage function in coders/xpm.c in ImageMagick 7.0.6-4 allows remote attackers to cause a denial of service (memory leak) via a crafted file that is mishandled in an OpenPixelCache call.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('97e7a7f4b2efcdbb4d464258eba545473d8b97e8')">
                                    <div class="issue-number">56</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="97e7a7f4b2efcdbb4d464258eba545473d8b97e8">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The WritePICONImage function in coders/xpm.c in ImageMagick 7.0.6-4 allows remote attackers to cause a denial of service (memory leak) via a crafted file that is mishandled in an AcquireSemaphoreInfo call.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('de0a2b97d6703d4b25a994a4493bbc1c2e68138e')">
                                    <div class="issue-number">57</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="de0a2b97d6703d4b25a994a4493bbc1c2e68138e">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The ReadPCXImage function in coders/pcx.c in ImageMagick 7.0.4.9 allows remote attackers to cause a denial of service (attempted large memory allocation and application crash) via a crafted file. NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-8862 and CVE-2016-8866.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('95e25309a77873e9b36427b85f4afb18c91c4285')">
                                    <div class="issue-number">58</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="95e25309a77873e9b36427b85f4afb18c91c4285">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In ImageMagick 7.0.8-11 Q16, a tiny input file 0x50 0x36 0x36 0x36 0x36 0x4c 0x36 0x38 0x36 0x36 0x36 0x36 0x36 0x36 0x1f 0x35 0x50 0x00 can result in a hang of several minutes during which CPU and memory resources are consumed until ultimately an attempted large memory allocation fails. Remote attackers could leverage this vulnerability to cause a denial of service via a crafted file.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('fff06d9dc7b9ab5f3c2210775701a3930f3a5b1a')">
                                    <div class="issue-number">59</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="fff06d9dc7b9ab5f3c2210775701a3930f3a5b1a">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A flaw was found in ImageMagick in versions before 7.0.11, where a division by zero in sRGBTransformImage() in the MagickCore/colorspace.c may trigger undefined behavior via a crafted image file that is submitted by an attacker processed by an application using ImageMagick. The highest threat from this vulnerability is to system availability.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('a9dc5d6749cc422a495f4edba182a5b5a3713a45')">
                                    <div class="issue-number">60</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="a9dc5d6749cc422a495f4edba182a5b5a3713a45">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A vulnerability was found in ImageMagick. This security flaw cause a remote code execution vulnerability in OpenBlob with --enable-pipes configured.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('1e832a2457184e79705ca525325b46b69acf4697')">
                                    <div class="issue-number">61</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="1e832a2457184e79705ca525325b46b69acf4697">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A design flaw in image processing software that modifies JPEG images might not modify the original EXIF thumbnail, which could lead to an information leak of potentially sensitive visual information that had been removed from the main JPEG image.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('0415f081e691d3ff04ed1024b375fd67d85f198d')">
                                    <div class="issue-number">62</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="0415f081e691d3ff04ed1024b375fd67d85f198d">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Multiple unspecified vulnerabilities in GraphicsMagick before 1.2.4 allow remote attackers to cause a denial of service (crash, infinite loop, or memory consumption) via (a) unspecified vectors in the (1) AVI, (2) AVS, (3) DCM, (4) EPT, (5) FITS, (6) MTV, (7) PALM, (8) RLA, and (9) TGA decoder readers; and (b) the GetImageCharacteristics function in magick/image.c, as reachable from a crafted (10) PNG, (11) JPEG, (12) BMP, or (13) TIFF file.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('fd0557a181e20048b81aee64616e69ff4fcb55ad')">
                                    <div class="issue-number">63</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="fd0557a181e20048b81aee64616e69ff4fcb55ad">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The IsPixelMonochrome function in MagickCore/pixel-accessor.h in ImageMagick 7.0.3.0 allows remote attackers to cause a denial of service (out-of-bounds read and crash) via a crafted file.  NOTE: the vendor says "This is a Q64 issue and we do not support Q64."</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('e907740b98d1ca51eb83e6a14f4c94a9ccd1ff78')">
                                    <div class="issue-number">64</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="e907740b98d1ca51eb83e6a14f4c94a9ccd1ff78">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The WritePICONImage function in coders/xpm.c in ImageMagick 7.0.6-4 allows remote attackers to cause a denial of service (memory leak) via a crafted file that is mishandled in an OpenPixelCache call.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('2ac4655f4645e667e4c53dcad6efcc5f12e1d8d0')">
                                    <div class="issue-number">65</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="2ac4655f4645e667e4c53dcad6efcc5f12e1d8d0">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The WritePICONImage function in coders/xpm.c in ImageMagick 7.0.6-4 allows remote attackers to cause a denial of service (memory leak) via a crafted file that is mishandled in an AcquireSemaphoreInfo call.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('524a79c732c349df144713c49edd973f9079a9fb')">
                                    <div class="issue-number">66</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="524a79c732c349df144713c49edd973f9079a9fb">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The ReadPCXImage function in coders/pcx.c in ImageMagick 7.0.4.9 allows remote attackers to cause a denial of service (attempted large memory allocation and application crash) via a crafted file. NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-8862 and CVE-2016-8866.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('3af8da7c88831421efd7bffa16945379431dfa4e')">
                                    <div class="issue-number">67</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="3af8da7c88831421efd7bffa16945379431dfa4e">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In ImageMagick 7.0.8-11 Q16, a tiny input file 0x50 0x36 0x36 0x36 0x36 0x4c 0x36 0x38 0x36 0x36 0x36 0x36 0x36 0x36 0x1f 0x35 0x50 0x00 can result in a hang of several minutes during which CPU and memory resources are consumed until ultimately an attempted large memory allocation fails. Remote attackers could leverage this vulnerability to cause a denial of service via a crafted file.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('e1935818f24f7d504147e7ae27762169dbba5db8')">
                                    <div class="issue-number">68</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="e1935818f24f7d504147e7ae27762169dbba5db8">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A flaw was found in ImageMagick in versions before 7.0.11, where a division by zero in sRGBTransformImage() in the MagickCore/colorspace.c may trigger undefined behavior via a crafted image file that is submitted by an attacker processed by an application using ImageMagick. The highest threat from this vulnerability is to system availability.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('6d172111811296b18666d0456354a3dd5fc42a69')">
                                    <div class="issue-number">69</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="6d172111811296b18666d0456354a3dd5fc42a69">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A vulnerability was found in ImageMagick. This security flaw cause a remote code execution vulnerability in OpenBlob with --enable-pipes configured.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('c319aa4092138cb8a30c789cd72f6dfde29bae8c')">
                                    <div class="issue-number">70</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="c319aa4092138cb8a30c789cd72f6dfde29bae8c">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A design flaw in image processing software that modifies JPEG images might not modify the original EXIF thumbnail, which could lead to an information leak of potentially sensitive visual information that had been removed from the main JPEG image.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('19e0ecd8f364a7494e4cca605313880134a83fef')">
                                    <div class="issue-number">71</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="19e0ecd8f364a7494e4cca605313880134a83fef">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Multiple unspecified vulnerabilities in GraphicsMagick before 1.2.4 allow remote attackers to cause a denial of service (crash, infinite loop, or memory consumption) via (a) unspecified vectors in the (1) AVI, (2) AVS, (3) DCM, (4) EPT, (5) FITS, (6) MTV, (7) PALM, (8) RLA, and (9) TGA decoder readers; and (b) the GetImageCharacteristics function in magick/image.c, as reachable from a crafted (10) PNG, (11) JPEG, (12) BMP, or (13) TIFF file.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('17f5ab0ec4ea2122817f1e86fa6c1644779d9747')">
                                    <div class="issue-number">72</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="17f5ab0ec4ea2122817f1e86fa6c1644779d9747">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The IsPixelMonochrome function in MagickCore/pixel-accessor.h in ImageMagick 7.0.3.0 allows remote attackers to cause a denial of service (out-of-bounds read and crash) via a crafted file.  NOTE: the vendor says "This is a Q64 issue and we do not support Q64."</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('51f2db164097ff0ffa45633ae27ae29c1f5707fd')">
                                    <div class="issue-number">73</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="51f2db164097ff0ffa45633ae27ae29c1f5707fd">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The WritePICONImage function in coders/xpm.c in ImageMagick 7.0.6-4 allows remote attackers to cause a denial of service (memory leak) via a crafted file that is mishandled in an OpenPixelCache call.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('33c87ed2a2fbee76246d55778bab1b4d34e3ead9')">
                                    <div class="issue-number">74</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="33c87ed2a2fbee76246d55778bab1b4d34e3ead9">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The WritePICONImage function in coders/xpm.c in ImageMagick 7.0.6-4 allows remote attackers to cause a denial of service (memory leak) via a crafted file that is mishandled in an AcquireSemaphoreInfo call.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('634e5234450d693247a81df2a59d710aa7b46966')">
                                    <div class="issue-number">75</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="634e5234450d693247a81df2a59d710aa7b46966">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The ReadPCXImage function in coders/pcx.c in ImageMagick 7.0.4.9 allows remote attackers to cause a denial of service (attempted large memory allocation and application crash) via a crafted file. NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-8862 and CVE-2016-8866.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('bd61b81936059ac0c5ebb4c7b4394ea676e009bc')">
                                    <div class="issue-number">76</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="bd61b81936059ac0c5ebb4c7b4394ea676e009bc">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In ImageMagick 7.0.8-11 Q16, a tiny input file 0x50 0x36 0x36 0x36 0x36 0x4c 0x36 0x38 0x36 0x36 0x36 0x36 0x36 0x36 0x1f 0x35 0x50 0x00 can result in a hang of several minutes during which CPU and memory resources are consumed until ultimately an attempted large memory allocation fails. Remote attackers could leverage this vulnerability to cause a denial of service via a crafted file.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('1c05c7e4acc0081c0ce24ec48fefd01a8535eaab')">
                                    <div class="issue-number">77</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="1c05c7e4acc0081c0ce24ec48fefd01a8535eaab">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A flaw was found in ImageMagick in versions before 7.0.11, where a division by zero in sRGBTransformImage() in the MagickCore/colorspace.c may trigger undefined behavior via a crafted image file that is submitted by an attacker processed by an application using ImageMagick. The highest threat from this vulnerability is to system availability.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('bddd4d08ca48caad602281c09372412fbb90ae77')">
                                    <div class="issue-number">78</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="bddd4d08ca48caad602281c09372412fbb90ae77">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A vulnerability was found in ImageMagick. This security flaw cause a remote code execution vulnerability in OpenBlob with --enable-pipes configured.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('10681847f0c4a865d98c72a9b7fa52dff4cf8573')">
                                    <div class="issue-number">79</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="10681847f0c4a865d98c72a9b7fa52dff4cf8573">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in MIT Kerberos 5 (aka krb5) through 1.16. There is a variable "dbentry->n_key_data" in kadmin/dbutil/dump.c that can store 16-bit data but unknowingly the developer has assigned a "u4" variable to it, which is for 32-bit data. An attacker can use this vulnerability to affect other artifacts of the database as we know that a Kerberos database dump file contains trusted data.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('e3a33673702c6035f7e598304efd94cad2f79783')">
                                    <div class="issue-number">80</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="e3a33673702c6035f7e598304efd94cad2f79783">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Kerberos 5 (aka krb5) 1.21.2 contains a memory leak in /krb5/src/lib/rpc/pmap_rmt.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('ea920d3aec1d220cf7af4927ed4a5aff5f7c1e4e')">
                                    <div class="issue-number">81</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="ea920d3aec1d220cf7af4927ed4a5aff5f7c1e4e">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Kerberos 5 (aka krb5) 1.21.2 contains a memory leak vulnerability in /krb5/src/lib/gssapi/krb5/k5sealv3.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('3b01a005b04bd85e52b232fcbc5e1251f5564892')">
                                    <div class="issue-number">82</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="3b01a005b04bd85e52b232fcbc5e1251f5564892">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> It was found that apt-key in apt, all versions, do not correctly validate gpg keys with the master keyring, leading to a potential man-in-the-middle attack.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('fbd2831a36bf30462eab44791139236569af5296')">
                                    <div class="issue-number">83</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="fbd2831a36bf30462eab44791139236569af5296">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> libiberty/rust-demangle.c in GNU GCC 11.2 allows stack consumption in demangle_const, as demonstrated by nm-new.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('f4cae360747a58986466534aa8d28ddcc34cb9d5')">
                                    <div class="issue-number">84</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="f4cae360747a58986466534aa8d28ddcc34cb9d5">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> 

**DISPUTED**A failure in the -fstack-protector feature in GCC-based toolchains 
that target AArch64 allows an attacker to exploit an existing buffer 
overflow in dynamically-sized local variables in your application 
without this being detected. This stack-protector failure only applies 
to C99-style dynamically-sized local variables or those created using 
alloca(). The stack-protector operates as intended for statically-sized 
local variables.

The default behavior when the stack-protector 
detects an overflow is to terminate your application, resulting in 
controlled loss of availability. An attacker who can exploit a buffer 
overflow without triggering the stack-protector might be able to change 
program flow control to cause an uncontrolled loss of availability or to
 go further and affect confidentiality or integrity. NOTE: The GCC project argues that this is a missed hardening bug and not a vulnerability by itself.





</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('87edb005dfccef6177c780f4362d8f977f4f6d6c')">
                                    <div class="issue-number">85</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="87edb005dfccef6177c780f4362d8f977f4f6d6c">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> libiberty/rust-demangle.c in GNU GCC 11.2 allows stack consumption in demangle_const, as demonstrated by nm-new.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('b2d10081681c1122e79764dec1eec371935e478b')">
                                    <div class="issue-number">86</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="b2d10081681c1122e79764dec1eec371935e478b">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> 

**DISPUTED**A failure in the -fstack-protector feature in GCC-based toolchains 
that target AArch64 allows an attacker to exploit an existing buffer 
overflow in dynamically-sized local variables in your application 
without this being detected. This stack-protector failure only applies 
to C99-style dynamically-sized local variables or those created using 
alloca(). The stack-protector operates as intended for statically-sized 
local variables.

The default behavior when the stack-protector 
detects an overflow is to terminate your application, resulting in 
controlled loss of availability. An attacker who can exploit a buffer 
overflow without triggering the stack-protector might be able to change 
program flow control to cause an uncontrolled loss of availability or to
 go further and affect confidentiality or integrity. NOTE: The GCC project argues that this is a missed hardening bug and not a vulnerability by itself.





</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('0a357ecc5767015432d8b43e9ff4cf464b209c8f')">
                                    <div class="issue-number">87</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="0a357ecc5767015432d8b43e9ff4cf464b209c8f">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The C++ symbol demangler routine in cplus-dem.c in libiberty, as distributed in GNU Binutils 2.29, allows remote attackers to cause a denial of service (excessive memory allocation and application crash) via a crafted file, as demonstrated by a call from the Binary File Descriptor (BFD) library (aka libbfd).</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('cc6b020b3f817775e344e0f1f72376bfb2dd87f1')">
                                    <div class="issue-number">88</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="cc6b020b3f817775e344e0f1f72376bfb2dd87f1">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The demangle_template function in cplus-dem.c in GNU libiberty, as distributed in GNU Binutils 2.31.1, contains an integer overflow vulnerability (for "Create an array for saving the template argument values") that can trigger a heap-based buffer overflow, as demonstrated by nm.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('db964110b07a806f88d4101a053e096bcc7e9d2c')">
                                    <div class="issue-number">89</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="db964110b07a806f88d4101a053e096bcc7e9d2c">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A heap-based buffer over-read exists in the function d_expression_1 in cp-demangle.c in GNU libiberty, as distributed in GNU Binutils 2.31.1. A crafted input can cause segmentation faults, leading to denial-of-service, as demonstrated by c++filt.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('9643e286abc8be6883df15874538ded2c76c4fb7')">
                                    <div class="issue-number">90</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="9643e286abc8be6883df15874538ded2c76c4fb7">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in cplus-dem.c in GNU libiberty, as distributed in GNU Binutils 2.30. Stack Exhaustion occurs in the C++ demangling functions provided by libiberty, and there are recursive stack frames: demangle_template_value_parm, demangle_integral_value, and demangle_expression.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('874fa40032a565d49355aaa79619323d953d9d48')">
                                    <div class="issue-number">91</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="874fa40032a565d49355aaa79619323d953d9d48">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in GNU libiberty, as distributed in GNU Binutils 2.36. It is a stack-overflow issue in demangle_type in rust-demangle.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('2163a8c113fb6c00cc4c05d135231ac5387de0b1')">
                                    <div class="issue-number">92</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="2163a8c113fb6c00cc4c05d135231ac5387de0b1">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A potential heap based buffer overflow was found in _bfd_elf_slurp_version_tables() in bfd/elf.c. This may lead to loss of availability.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('7db48406a26a60ec3909fa4df571797f4f0ef749')">
                                    <div class="issue-number">93</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="7db48406a26a60ec3909fa4df571797f4f0ef749">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an "INPUTRC" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('f78c2332d8a3280344024e9b6d41ea666d5a1bbc')">
                                    <div class="issue-number">94</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="f78c2332d8a3280344024e9b6d41ea666d5a1bbc">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an "INPUTRC" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('acdb96ef3300f9afd946a83d109d728bed4d02e3')">
                                    <div class="issue-number">95</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="acdb96ef3300f9afd946a83d109d728bed4d02e3">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In BlueZ 5.42, a buffer over-read was observed in "l2cap_dump" function in "tools/parser/l2cap.c" source file. This issue can be triggered by processing a corrupted dump file and will result in hcidump crash.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('9443d9ce9af300c9023874f25921a82fa21f50ab')">
                                    <div class="issue-number">96</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="9443d9ce9af300c9023874f25921a82fa21f50ab">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In BlueZ 5.42, a use-after-free was identified in "conf_opt" function in "tools/parser/l2cap.c" source file. This issue can be triggered by processing a corrupted dump file and will result in hcidump crash.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('0b1e3bbad8991b18c3a719a5e6de1c5936a74ea4')">
                                    <div class="issue-number">97</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="0b1e3bbad8991b18c3a719a5e6de1c5936a74ea4">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In BlueZ 5.42, a buffer overflow was observed in "pklg_read_hci" function in "btsnoop.c" source file. This issue can be triggered by processing a corrupted dump file and will result in btmon crash.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('3c2c765b35039b356523e3fa923976d9f6f2f61d')">
                                    <div class="issue-number">98</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="3c2c765b35039b356523e3fa923976d9f6f2f61d">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In BlueZ 5.42, a buffer overflow was observed in "pin_code_reply_dump" function in "tools/parser/hci.c" source file. The issue exists because "pin" array is overflowed by supplied parameter due to lack of boundary checks on size of the buffer from frame "pin_code_reply_cp *cp" parameter.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('0aa7d500b9a8bc48898dd05135860668edbdd03d')">
                                    <div class="issue-number">99</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="0aa7d500b9a8bc48898dd05135860668edbdd03d">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In BlueZ 5.42, a buffer overflow was observed in "set_ext_ctrl" function in "tools/parser/l2cap.c" source file when processing corrupted dump file.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('cb19c041180ad8f0f832f51df2f72203f79c4d8a')">
                                    <div class="issue-number">100</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="cb19c041180ad8f0f832f51df2f72203f79c4d8a">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In BlueZ 5.42, a buffer over-read was identified in "l2cap_packet" function in "monitor/packet.c" source file. This issue can be triggered by processing a corrupted dump file and will result in btmon crash.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('268ed4c92d9be9ad1fbd169920df8472948ab88c')">
                                    <div class="issue-number">101</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="268ed4c92d9be9ad1fbd169920df8472948ab88c">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In BlueZ 5.42, an out-of-bounds read was observed in "le_meta_ev_dump" function in "tools/parser/hci.c" source file. This issue exists because 'subevent' (which is used to read correct element from 'ev_le_meta_str' array) is overflowed.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('d195c427f0a97e79f7cc260306be1638a3418f1e')">
                                    <div class="issue-number">102</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="d195c427f0a97e79f7cc260306be1638a3418f1e">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In BlueZ 5.42, a buffer overflow was observed in "commands_dump" function in "tools/parser/csr.c" source file. The issue exists because "commands" array is overflowed by supplied parameter due to lack of boundary checks on size of the buffer from frame "frm->ptr" parameter. This issue can be triggered by processing a corrupted dump file and will result in hcidump crash.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('ad752e625174d8f934617b8483f3e13be243275d')">
                                    <div class="issue-number">103</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="ad752e625174d8f934617b8483f3e13be243275d">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In BlueZ 5.42, a buffer overflow was observed in "read_n" function in "tools/hcidump.c" source file. This issue can be triggered by processing a corrupted dump file and will result in hcidump crash.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('85fd9b33ddd6d9213202d3e14b49f9c4b35a1c00')">
                                    <div class="issue-number">104</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="85fd9b33ddd6d9213202d3e14b49f9c4b35a1c00">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In BlueZ 5.42, an out-of-bounds read was identified in "packet_hexdump" function in "monitor/packet.c" source file. This issue can be triggered by processing a corrupted dump file and will result in btmon crash.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('6778a69e69dd87142bb120cc52b10663d2a50be8')">
                                    <div class="issue-number">105</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="6778a69e69dd87142bb120cc52b10663d2a50be8">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> BlueZ OBEX Library Out-Of-Bounds Read Information Disclosure Vulnerability. This vulnerability allows network-adjacent attackers to disclose sensitive information on affected installations of BlueZ. User interaction is required to exploit this vulnerability in that the target must connect to a malicious Bluetooth device.

The specific flaw exists within the handling of OBEX protocol parameters. The issue results from the lack of proper validation of user-supplied data, which can result in a read past the end of an allocated buffer. An attacker can leverage this in conjunction with other vulnerabilities to execute arbitrary code in the context of root. Was ZDI-CAN-20937.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('38995e4fde9a08d63c0c040553e9a8440339e322')">
                                    <div class="issue-number">106</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="38995e4fde9a08d63c0c040553e9a8440339e322">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In BlueZ 5.42, a buffer over-read was observed in "l2cap_dump" function in "tools/parser/l2cap.c" source file. This issue can be triggered by processing a corrupted dump file and will result in hcidump crash.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('80e498f414d2309fbca603e56215149e0e2dff37')">
                                    <div class="issue-number">107</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="80e498f414d2309fbca603e56215149e0e2dff37">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In BlueZ 5.42, a use-after-free was identified in "conf_opt" function in "tools/parser/l2cap.c" source file. This issue can be triggered by processing a corrupted dump file and will result in hcidump crash.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('5b3281a2d5eb9a0ecdabb9247717240a5cf4397b')">
                                    <div class="issue-number">108</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="5b3281a2d5eb9a0ecdabb9247717240a5cf4397b">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In BlueZ 5.42, a buffer overflow was observed in "pklg_read_hci" function in "btsnoop.c" source file. This issue can be triggered by processing a corrupted dump file and will result in btmon crash.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('d344540aeac9d73b1ab465c960b954d8110f01dc')">
                                    <div class="issue-number">109</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="d344540aeac9d73b1ab465c960b954d8110f01dc">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In BlueZ 5.42, a buffer overflow was observed in "pin_code_reply_dump" function in "tools/parser/hci.c" source file. The issue exists because "pin" array is overflowed by supplied parameter due to lack of boundary checks on size of the buffer from frame "pin_code_reply_cp *cp" parameter.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('82f29bd785b93e3dccaad26582473eae4be92cc4')">
                                    <div class="issue-number">110</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="82f29bd785b93e3dccaad26582473eae4be92cc4">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In BlueZ 5.42, a buffer overflow was observed in "set_ext_ctrl" function in "tools/parser/l2cap.c" source file when processing corrupted dump file.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('ed660e726ca0b247ba4ac2441e90d1594ba4aef9')">
                                    <div class="issue-number">111</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="ed660e726ca0b247ba4ac2441e90d1594ba4aef9">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In BlueZ 5.42, a buffer over-read was identified in "l2cap_packet" function in "monitor/packet.c" source file. This issue can be triggered by processing a corrupted dump file and will result in btmon crash.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('bee32584172ebd08e73e354c3c4d230764a57605')">
                                    <div class="issue-number">112</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="bee32584172ebd08e73e354c3c4d230764a57605">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In BlueZ 5.42, an out-of-bounds read was observed in "le_meta_ev_dump" function in "tools/parser/hci.c" source file. This issue exists because 'subevent' (which is used to read correct element from 'ev_le_meta_str' array) is overflowed.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('94d147859a5dc6e7641c28a0f966ff5c8a6e7760')">
                                    <div class="issue-number">113</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="94d147859a5dc6e7641c28a0f966ff5c8a6e7760">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In BlueZ 5.42, a buffer overflow was observed in "commands_dump" function in "tools/parser/csr.c" source file. The issue exists because "commands" array is overflowed by supplied parameter due to lack of boundary checks on size of the buffer from frame "frm->ptr" parameter. This issue can be triggered by processing a corrupted dump file and will result in hcidump crash.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('7c4f86a6dd5d6b930550afacf9125323eda991ef')">
                                    <div class="issue-number">114</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="7c4f86a6dd5d6b930550afacf9125323eda991ef">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In BlueZ 5.42, a buffer overflow was observed in "read_n" function in "tools/hcidump.c" source file. This issue can be triggered by processing a corrupted dump file and will result in hcidump crash.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('767a86605ed8714729a4a4c234208150b851f661')">
                                    <div class="issue-number">115</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="767a86605ed8714729a4a4c234208150b851f661">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In BlueZ 5.42, an out-of-bounds read was identified in "packet_hexdump" function in "monitor/packet.c" source file. This issue can be triggered by processing a corrupted dump file and will result in btmon crash.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('fef269c763646473beab06e86875e5ac87c100fb')">
                                    <div class="issue-number">116</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="fef269c763646473beab06e86875e5ac87c100fb">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> BlueZ OBEX Library Out-Of-Bounds Read Information Disclosure Vulnerability. This vulnerability allows network-adjacent attackers to disclose sensitive information on affected installations of BlueZ. User interaction is required to exploit this vulnerability in that the target must connect to a malicious Bluetooth device.

The specific flaw exists within the handling of OBEX protocol parameters. The issue results from the lack of proper validation of user-supplied data, which can result in a read past the end of an allocated buffer. An attacker can leverage this in conjunction with other vulnerabilities to execute arbitrary code in the context of root. Was ZDI-CAN-20937.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('cd8b561180bb04a556b06bb6c4b72811cd2bda7b')">
                                    <div class="issue-number">117</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="cd8b561180bb04a556b06bb6c4b72811cd2bda7b">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The glob implementation in the GNU C Library (aka glibc or libc6) allows remote authenticated users to cause a denial of service (CPU and memory consumption) via crafted glob expressions that do not match any pathnames, as demonstrated by glob expressions in STAT commands to an FTP daemon, a different vulnerability than CVE-2010-2632.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('87ad533749f80c36e596c47331a41bfd9f2ac782')">
                                    <div class="issue-number">118</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="87ad533749f80c36e596c47331a41bfd9f2ac782">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(\227|)(\\1\\1|t1|\\\2537)+' in grep.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('5c4e2fdeb97b2f02a613470209d85014ed98d71a')">
                                    <div class="issue-number">119</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="5c4e2fdeb97b2f02a613470209d85014ed98d71a">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass stack guard protection. The component is: nptl. The attack vector is: Exploit stack buffer overflow vulnerability and use this bypass vulnerability to bypass stack guard. NOTE: Upstream comments indicate "this is being treated as a non-security bug and no real threat.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('f0c49fc9958831ac245595a3847ac9c2b7a2df94')">
                                    <div class="issue-number">120</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="f0c49fc9958831ac245595a3847ac9c2b7a2df94">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> GNU Libc current is affected by: Re-mapping current loaded library with malicious ELF file. The impact is: In worst case attacker may evaluate privileges. The component is: libld. The attack vector is: Attacker sends 2 ELF files to victim and asks to run ldd on it. ldd execute code. NOTE: Upstream comments indicate "this is being treated as a non-security bug and no real threat.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('5b5ac61b2f7b5331bc9734bc2f9bad3003947889')">
                                    <div class="issue-number">121</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="5b5ac61b2f7b5331bc9734bc2f9bad3003947889">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass ASLR using cache of thread stack and heap. The component is: glibc. NOTE: Upstream comments indicate "this is being treated as a non-security bug and no real threat.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('8bdc47bf3c37afc6be721cdd7a46bd9df68738ec')">
                                    <div class="issue-number">122</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="8bdc47bf3c37afc6be721cdd7a46bd9df68738ec">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may guess the heap addresses of pthread_created thread. The component is: glibc. NOTE: the vendor's position is "ASLR bypass itself is not a vulnerability.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('fbfc0c2d4fa54d06bd2c11e94ffc9374916f6df8')">
                                    <div class="issue-number">123</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="fbfc0c2d4fa54d06bd2c11e94ffc9374916f6df8">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(|)(\\1\\1)*' in grep, a different issue than CVE-2018-20796. NOTE: the software maintainer disputes that this is a vulnerability because the behavior occurs only with a crafted pattern</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('b6ac7bddc8d46593d6d56bdd5830c50181d0dc83')">
                                    <div class="issue-number">124</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="b6ac7bddc8d46593d6d56bdd5830c50181d0dc83">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The glob implementation in the GNU C Library (aka glibc or libc6) allows remote authenticated users to cause a denial of service (CPU and memory consumption) via crafted glob expressions that do not match any pathnames, as demonstrated by glob expressions in STAT commands to an FTP daemon, a different vulnerability than CVE-2010-2632.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('57605910e76ca25fc062c1dc2c8d35a4db25b715')">
                                    <div class="issue-number">125</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="57605910e76ca25fc062c1dc2c8d35a4db25b715">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(\227|)(\\1\\1|t1|\\\2537)+' in grep.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('1a704fe11ee2414f48b6ea5acf5c83ba0b6e64ae')">
                                    <div class="issue-number">126</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="1a704fe11ee2414f48b6ea5acf5c83ba0b6e64ae">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass stack guard protection. The component is: nptl. The attack vector is: Exploit stack buffer overflow vulnerability and use this bypass vulnerability to bypass stack guard. NOTE: Upstream comments indicate "this is being treated as a non-security bug and no real threat.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('de982582d935b3ed5bc958bfaf67e8b44d9660b6')">
                                    <div class="issue-number">127</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="de982582d935b3ed5bc958bfaf67e8b44d9660b6">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> GNU Libc current is affected by: Re-mapping current loaded library with malicious ELF file. The impact is: In worst case attacker may evaluate privileges. The component is: libld. The attack vector is: Attacker sends 2 ELF files to victim and asks to run ldd on it. ldd execute code. NOTE: Upstream comments indicate "this is being treated as a non-security bug and no real threat.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('1bcbe2a35ba696f7b1c254a3d475b218e7a1a790')">
                                    <div class="issue-number">128</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="1bcbe2a35ba696f7b1c254a3d475b218e7a1a790">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass ASLR using cache of thread stack and heap. The component is: glibc. NOTE: Upstream comments indicate "this is being treated as a non-security bug and no real threat.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('f854ee4c3220f0fb3f3da45be8653522c8ba145a')">
                                    <div class="issue-number">129</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="f854ee4c3220f0fb3f3da45be8653522c8ba145a">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may guess the heap addresses of pthread_created thread. The component is: glibc. NOTE: the vendor's position is "ASLR bypass itself is not a vulnerability.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('3bff5141ea7e377c929a449a3e8fa681a8a43a48')">
                                    <div class="issue-number">130</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="3bff5141ea7e377c929a449a3e8fa681a8a43a48">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(|)(\\1\\1)*' in grep, a different issue than CVE-2018-20796. NOTE: the software maintainer disputes that this is a vulnerability because the behavior occurs only with a crafted pattern</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('1ee77c0d8058d6cfc4311ffb03b2806303a9cfea')">
                                    <div class="issue-number">131</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="1ee77c0d8058d6cfc4311ffb03b2806303a9cfea">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The glob implementation in the GNU C Library (aka glibc or libc6) allows remote authenticated users to cause a denial of service (CPU and memory consumption) via crafted glob expressions that do not match any pathnames, as demonstrated by glob expressions in STAT commands to an FTP daemon, a different vulnerability than CVE-2010-2632.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('d2abd6e0539409f9db4d467cb9c63396bc4479f6')">
                                    <div class="issue-number">132</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="d2abd6e0539409f9db4d467cb9c63396bc4479f6">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(\227|)(\\1\\1|t1|\\\2537)+' in grep.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('eaba949a816417fa244c0afcf2764334dfd859ed')">
                                    <div class="issue-number">133</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="eaba949a816417fa244c0afcf2764334dfd859ed">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass stack guard protection. The component is: nptl. The attack vector is: Exploit stack buffer overflow vulnerability and use this bypass vulnerability to bypass stack guard. NOTE: Upstream comments indicate "this is being treated as a non-security bug and no real threat.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('2a6db64de36b17b7bf4f365c38799b8bd7677330')">
                                    <div class="issue-number">134</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="2a6db64de36b17b7bf4f365c38799b8bd7677330">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> GNU Libc current is affected by: Re-mapping current loaded library with malicious ELF file. The impact is: In worst case attacker may evaluate privileges. The component is: libld. The attack vector is: Attacker sends 2 ELF files to victim and asks to run ldd on it. ldd execute code. NOTE: Upstream comments indicate "this is being treated as a non-security bug and no real threat.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('562836b4ce9eeaa8e3759cc85aa8c5a24ec4d730')">
                                    <div class="issue-number">135</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="562836b4ce9eeaa8e3759cc85aa8c5a24ec4d730">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass ASLR using cache of thread stack and heap. The component is: glibc. NOTE: Upstream comments indicate "this is being treated as a non-security bug and no real threat.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('6415e0be7e5e0e4c0fbe2e87247a3041fa6cc5f2')">
                                    <div class="issue-number">136</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="6415e0be7e5e0e4c0fbe2e87247a3041fa6cc5f2">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may guess the heap addresses of pthread_created thread. The component is: glibc. NOTE: the vendor's position is "ASLR bypass itself is not a vulnerability.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('9a9ff8c77ac607ef673a7b0cd58d6434e64895c3')">
                                    <div class="issue-number">137</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="9a9ff8c77ac607ef673a7b0cd58d6434e64895c3">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(|)(\\1\\1)*' in grep, a different issue than CVE-2018-20796. NOTE: the software maintainer disputes that this is a vulnerability because the behavior occurs only with a crafted pattern</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('0b7785aadae483765a61d9d70b00544fcf56636c')">
                                    <div class="issue-number">138</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="0b7785aadae483765a61d9d70b00544fcf56636c">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The glob implementation in the GNU C Library (aka glibc or libc6) allows remote authenticated users to cause a denial of service (CPU and memory consumption) via crafted glob expressions that do not match any pathnames, as demonstrated by glob expressions in STAT commands to an FTP daemon, a different vulnerability than CVE-2010-2632.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('e6d3098838363802f6fbb4a8182950f294f4f02b')">
                                    <div class="issue-number">139</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="e6d3098838363802f6fbb4a8182950f294f4f02b">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(\227|)(\\1\\1|t1|\\\2537)+' in grep.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('1b505898e220d075810b459f39252ff3372a29bc')">
                                    <div class="issue-number">140</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="1b505898e220d075810b459f39252ff3372a29bc">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass stack guard protection. The component is: nptl. The attack vector is: Exploit stack buffer overflow vulnerability and use this bypass vulnerability to bypass stack guard. NOTE: Upstream comments indicate "this is being treated as a non-security bug and no real threat.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('07b42c1e73cc370ee3365c54256912ee7692c726')">
                                    <div class="issue-number">141</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="07b42c1e73cc370ee3365c54256912ee7692c726">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> GNU Libc current is affected by: Re-mapping current loaded library with malicious ELF file. The impact is: In worst case attacker may evaluate privileges. The component is: libld. The attack vector is: Attacker sends 2 ELF files to victim and asks to run ldd on it. ldd execute code. NOTE: Upstream comments indicate "this is being treated as a non-security bug and no real threat.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('8cf2aac04d157f49c64556e96f1d1df847e9b48f')">
                                    <div class="issue-number">142</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="8cf2aac04d157f49c64556e96f1d1df847e9b48f">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass ASLR using cache of thread stack and heap. The component is: glibc. NOTE: Upstream comments indicate "this is being treated as a non-security bug and no real threat.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('4af8229d1c2354d791add5b25e02df7b7b10be4f')">
                                    <div class="issue-number">143</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="4af8229d1c2354d791add5b25e02df7b7b10be4f">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may guess the heap addresses of pthread_created thread. The component is: glibc. NOTE: the vendor's position is "ASLR bypass itself is not a vulnerability.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('95a8ce60ed79c59272586cbb63de715e55f602da')">
                                    <div class="issue-number">144</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="95a8ce60ed79c59272586cbb63de715e55f602da">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(|)(\\1\\1)*' in grep, a different issue than CVE-2018-20796. NOTE: the software maintainer disputes that this is a vulnerability because the behavior occurs only with a crafted pattern</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('0d03cc8d50b743795d69cc6c4a434a0af60188a7')">
                                    <div class="issue-number">145</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="0d03cc8d50b743795d69cc6c4a434a0af60188a7">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The glob implementation in the GNU C Library (aka glibc or libc6) allows remote authenticated users to cause a denial of service (CPU and memory consumption) via crafted glob expressions that do not match any pathnames, as demonstrated by glob expressions in STAT commands to an FTP daemon, a different vulnerability than CVE-2010-2632.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('8a5632eea3cd555fdf8696aa16a571642e7576e2')">
                                    <div class="issue-number">146</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="8a5632eea3cd555fdf8696aa16a571642e7576e2">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(\227|)(\\1\\1|t1|\\\2537)+' in grep.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('b0a7b80f408e5450777583bb2a924234fb7707f3')">
                                    <div class="issue-number">147</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="b0a7b80f408e5450777583bb2a924234fb7707f3">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass stack guard protection. The component is: nptl. The attack vector is: Exploit stack buffer overflow vulnerability and use this bypass vulnerability to bypass stack guard. NOTE: Upstream comments indicate "this is being treated as a non-security bug and no real threat.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('3034f52d376f050fbc01a1150aac30b6d84cc3af')">
                                    <div class="issue-number">148</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="3034f52d376f050fbc01a1150aac30b6d84cc3af">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> GNU Libc current is affected by: Re-mapping current loaded library with malicious ELF file. The impact is: In worst case attacker may evaluate privileges. The component is: libld. The attack vector is: Attacker sends 2 ELF files to victim and asks to run ldd on it. ldd execute code. NOTE: Upstream comments indicate "this is being treated as a non-security bug and no real threat.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('591993f297c4a3b08fb5ce2e169fe8ae3d3ee116')">
                                    <div class="issue-number">149</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="591993f297c4a3b08fb5ce2e169fe8ae3d3ee116">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may bypass ASLR using cache of thread stack and heap. The component is: glibc. NOTE: Upstream comments indicate "this is being treated as a non-security bug and no real threat.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('b77286e90c92e55673c977aa680be4b0cbacb362')">
                                    <div class="issue-number">150</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="b77286e90c92e55673c977aa680be4b0cbacb362">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> GNU Libc current is affected by: Mitigation bypass. The impact is: Attacker may guess the heap addresses of pthread_created thread. The component is: glibc. NOTE: the vendor's position is "ASLR bypass itself is not a vulnerability.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('0cdffb148843e3853afd8ec1be4502809ce19383')">
                                    <div class="issue-number">151</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="0cdffb148843e3853afd8ec1be4502809ce19383">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the GNU C Library (aka glibc or libc6) through 2.29, check_dst_limits_calc_pos_1 in posix/regexec.c has Uncontrolled Recursion, as demonstrated by '(|)(\\1\\1)*' in grep, a different issue than CVE-2018-20796. NOTE: the software maintainer disputes that this is a vulnerability because the behavior occurs only with a crafted pattern</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('45dc897c3f5525f0e6b06deac2264c6d1ba080f5')">
                                    <div class="issue-number">152</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="45dc897c3f5525f0e6b06deac2264c6d1ba080f5">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Cairo version 1.15.4 is vulnerable to a NULL pointer dereference related to the FT_Load_Glyph and FT_Render_Glyph resulting in an application crash.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('72fcdee17c3df5070981afc6c0da571cdadf1bf3')">
                                    <div class="issue-number">153</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="72fcdee17c3df5070981afc6c0da571cdadf1bf3">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> cairo through 1.15.14 has an out-of-bounds stack-memory write during processing of a crafted document by WebKitGTK+ because of the interaction between cairo-rectangular-scan-converter.c (the generate and render_rows functions) and cairo-image-compositor.c (the _cairo_image_spans_and_zero function).</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('682410815336dfdb81afee328f28da852e3064df')">
                                    <div class="issue-number">154</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="682410815336dfdb81afee328f28da852e3064df">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in cairo 1.16.0. There is an assertion problem in the function _cairo_arc_in_direction in the file cairo-arc.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('ddc41e3fce48059107a5f294fd830275e46b7ab7')">
                                    <div class="issue-number">155</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="ddc41e3fce48059107a5f294fd830275e46b7ab7">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in cairo 1.16.0. There is an infinite loop in the function _arc_error_normalized in the file cairo-arc.c, related to _arc_max_angle_for_tolerance_normalized.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('53ab38f7f172dd90b7b4cd6819cb7c301774913b')">
                                    <div class="issue-number">156</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="53ab38f7f172dd90b7b4cd6819cb7c301774913b">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Cairo version 1.15.4 is vulnerable to a NULL pointer dereference related to the FT_Load_Glyph and FT_Render_Glyph resulting in an application crash.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('a94da8bbc72dc22cc0d28171e91ffe6d74c0c3b5')">
                                    <div class="issue-number">157</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="a94da8bbc72dc22cc0d28171e91ffe6d74c0c3b5">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> cairo through 1.15.14 has an out-of-bounds stack-memory write during processing of a crafted document by WebKitGTK+ because of the interaction between cairo-rectangular-scan-converter.c (the generate and render_rows functions) and cairo-image-compositor.c (the _cairo_image_spans_and_zero function).</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('1218d7c0d02778f1db5b4b9040ad9b004460a690')">
                                    <div class="issue-number">158</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="1218d7c0d02778f1db5b4b9040ad9b004460a690">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in cairo 1.16.0. There is an assertion problem in the function _cairo_arc_in_direction in the file cairo-arc.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('77d6e6f39a569b99286fb8481c5926412861a72e')">
                                    <div class="issue-number">159</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="77d6e6f39a569b99286fb8481c5926412861a72e">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in cairo 1.16.0. There is an infinite loop in the function _arc_error_normalized in the file cairo-arc.c, related to _arc_max_angle_for_tolerance_normalized.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('aea56cf025bf0da4fe5b4368d3c33405df59baef')">
                                    <div class="issue-number">160</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="aea56cf025bf0da4fe5b4368d3c33405df59baef">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Cairo version 1.15.4 is vulnerable to a NULL pointer dereference related to the FT_Load_Glyph and FT_Render_Glyph resulting in an application crash.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('34b3f9b4565c68514d7dbf829927344b033a2fad')">
                                    <div class="issue-number">161</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="34b3f9b4565c68514d7dbf829927344b033a2fad">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> cairo through 1.15.14 has an out-of-bounds stack-memory write during processing of a crafted document by WebKitGTK+ because of the interaction between cairo-rectangular-scan-converter.c (the generate and render_rows functions) and cairo-image-compositor.c (the _cairo_image_spans_and_zero function).</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('b26b010e1af99309ce2d2cef7e7573c0f91ff6d4')">
                                    <div class="issue-number">162</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="b26b010e1af99309ce2d2cef7e7573c0f91ff6d4">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in cairo 1.16.0. There is an assertion problem in the function _cairo_arc_in_direction in the file cairo-arc.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('d082dae9c15cbc4d0229515bdb9065866534ed43')">
                                    <div class="issue-number">163</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="d082dae9c15cbc4d0229515bdb9065866534ed43">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in cairo 1.16.0. There is an infinite loop in the function _arc_error_normalized in the file cairo-arc.c, related to _arc_max_angle_for_tolerance_normalized.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('5d4f4e29b5be87db3fbc04b5860400f06f41fbf8')">
                                    <div class="issue-number">164</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="5d4f4e29b5be87db3fbc04b5860400f06f41fbf8">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Cairo version 1.15.4 is vulnerable to a NULL pointer dereference related to the FT_Load_Glyph and FT_Render_Glyph resulting in an application crash.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('01ea0bdd42cf7ef647ece93e76ece832d9a83fd1')">
                                    <div class="issue-number">165</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="01ea0bdd42cf7ef647ece93e76ece832d9a83fd1">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> cairo through 1.15.14 has an out-of-bounds stack-memory write during processing of a crafted document by WebKitGTK+ because of the interaction between cairo-rectangular-scan-converter.c (the generate and render_rows functions) and cairo-image-compositor.c (the _cairo_image_spans_and_zero function).</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('6aacf39ff411990fd9180bf12b611217890bcea8')">
                                    <div class="issue-number">166</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="6aacf39ff411990fd9180bf12b611217890bcea8">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in cairo 1.16.0. There is an assertion problem in the function _cairo_arc_in_direction in the file cairo-arc.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('42c47db08a119705fb3e5862111acfaf4e5cfdaa')">
                                    <div class="issue-number">167</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="42c47db08a119705fb3e5862111acfaf4e5cfdaa">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in cairo 1.16.0. There is an infinite loop in the function _arc_error_normalized in the file cairo-arc.c, related to _arc_max_angle_for_tolerance_normalized.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('213efa4aa7dd4789bc47ead7a1c7794c088b7354')">
                                    <div class="issue-number">168</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="213efa4aa7dd4789bc47ead7a1c7794c088b7354">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> libiberty/rust-demangle.c in GNU GCC 11.2 allows stack consumption in demangle_const, as demonstrated by nm-new.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('bf906dc4a82985c2ac1e7d89ceb05495806d1505')">
                                    <div class="issue-number">169</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="bf906dc4a82985c2ac1e7d89ceb05495806d1505">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> 

**DISPUTED**A failure in the -fstack-protector feature in GCC-based toolchains 
that target AArch64 allows an attacker to exploit an existing buffer 
overflow in dynamically-sized local variables in your application 
without this being detected. This stack-protector failure only applies 
to C99-style dynamically-sized local variables or those created using 
alloca(). The stack-protector operates as intended for statically-sized 
local variables.

The default behavior when the stack-protector 
detects an overflow is to terminate your application, resulting in 
controlled loss of availability. An attacker who can exploit a buffer 
overflow without triggering the stack-protector might be able to change 
program flow control to cause an uncontrolled loss of availability or to
 go further and affect confidentiality or integrity. NOTE: The GCC project argues that this is a missed hardening bug and not a vulnerability by itself.





</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('ea90292d1dd5d8bc35a82c5d5a58c60c8e4f2ee6')">
                                    <div class="issue-number">170</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="ea90292d1dd5d8bc35a82c5d5a58c60c8e4f2ee6">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The C++ symbol demangler routine in cplus-dem.c in libiberty, as distributed in GNU Binutils 2.29, allows remote attackers to cause a denial of service (excessive memory allocation and application crash) via a crafted file, as demonstrated by a call from the Binary File Descriptor (BFD) library (aka libbfd).</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('130eb4f59ce5d1b8b883ea7f2977115c0fadaf1d')">
                                    <div class="issue-number">171</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="130eb4f59ce5d1b8b883ea7f2977115c0fadaf1d">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The demangle_template function in cplus-dem.c in GNU libiberty, as distributed in GNU Binutils 2.31.1, contains an integer overflow vulnerability (for "Create an array for saving the template argument values") that can trigger a heap-based buffer overflow, as demonstrated by nm.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('64f6a55017dcdf1cf12b7fe649d68f9032ce8088')">
                                    <div class="issue-number">172</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="64f6a55017dcdf1cf12b7fe649d68f9032ce8088">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A heap-based buffer over-read exists in the function d_expression_1 in cp-demangle.c in GNU libiberty, as distributed in GNU Binutils 2.31.1. A crafted input can cause segmentation faults, leading to denial-of-service, as demonstrated by c++filt.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('1a6551480c4d23003fe72929c289952df327e354')">
                                    <div class="issue-number">173</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="1a6551480c4d23003fe72929c289952df327e354">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in cplus-dem.c in GNU libiberty, as distributed in GNU Binutils 2.30. Stack Exhaustion occurs in the C++ demangling functions provided by libiberty, and there are recursive stack frames: demangle_template_value_parm, demangle_integral_value, and demangle_expression.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('fe3b46a784804ee0d55ba784bfdb43f694ad0d80')">
                                    <div class="issue-number">174</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="fe3b46a784804ee0d55ba784bfdb43f694ad0d80">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in GNU libiberty, as distributed in GNU Binutils 2.36. It is a stack-overflow issue in demangle_type in rust-demangle.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('9345454813c6c16e45fbcce117a8d27b0f69db49')">
                                    <div class="issue-number">175</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="9345454813c6c16e45fbcce117a8d27b0f69db49">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A potential heap based buffer overflow was found in _bfd_elf_slurp_version_tables() in bfd/elf.c. This may lead to loss of availability.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('a47d6c7cec7a19325370d290ee8ba8c1bae896cf')">
                                    <div class="issue-number">176</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="a47d6c7cec7a19325370d290ee8ba8c1bae896cf">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The C++ symbol demangler routine in cplus-dem.c in libiberty, as distributed in GNU Binutils 2.29, allows remote attackers to cause a denial of service (excessive memory allocation and application crash) via a crafted file, as demonstrated by a call from the Binary File Descriptor (BFD) library (aka libbfd).</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('6b466f5d4eef6fd4f65e49403ec6be9f8affa855')">
                                    <div class="issue-number">177</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="6b466f5d4eef6fd4f65e49403ec6be9f8affa855">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The demangle_template function in cplus-dem.c in GNU libiberty, as distributed in GNU Binutils 2.31.1, contains an integer overflow vulnerability (for "Create an array for saving the template argument values") that can trigger a heap-based buffer overflow, as demonstrated by nm.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('2bf59e78ada922b8cb12b6616a31a7bb264f27b5')">
                                    <div class="issue-number">178</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="2bf59e78ada922b8cb12b6616a31a7bb264f27b5">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A heap-based buffer over-read exists in the function d_expression_1 in cp-demangle.c in GNU libiberty, as distributed in GNU Binutils 2.31.1. A crafted input can cause segmentation faults, leading to denial-of-service, as demonstrated by c++filt.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('b33b268f06ca6e6444e1296882b8660adc4a5cd5')">
                                    <div class="issue-number">179</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="b33b268f06ca6e6444e1296882b8660adc4a5cd5">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in cplus-dem.c in GNU libiberty, as distributed in GNU Binutils 2.30. Stack Exhaustion occurs in the C++ demangling functions provided by libiberty, and there are recursive stack frames: demangle_template_value_parm, demangle_integral_value, and demangle_expression.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('b093d6f88dca56aae30b6e50ff5a247ab702f12f')">
                                    <div class="issue-number">180</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="b093d6f88dca56aae30b6e50ff5a247ab702f12f">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in GNU libiberty, as distributed in GNU Binutils 2.36. It is a stack-overflow issue in demangle_type in rust-demangle.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('a6d40129204ee57498d1af38dd28f37e96a5bf04')">
                                    <div class="issue-number">181</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="a6d40129204ee57498d1af38dd28f37e96a5bf04">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A potential heap based buffer overflow was found in _bfd_elf_slurp_version_tables() in bfd/elf.c. This may lead to loss of availability.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('f2979e2ca35989d13ac179234696c7567d176256')">
                                    <div class="issue-number">182</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="f2979e2ca35989d13ac179234696c7567d176256">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> libcurl skips the certificate verification for a QUIC connection under certain conditions, when built to use wolfSSL. If told to use an unknown/bad cipher or curve, the error path accidentally skips the verification and returns OK, thus ignoring any certificate problems.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('3b2f02a0edd38e960955010e868d305ef41df2b6')">
                                    <div class="issue-number">183</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="3b2f02a0edd38e960955010e868d305ef41df2b6">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> libcurl skips the certificate verification for a QUIC connection under certain conditions, when built to use wolfSSL. If told to use an unknown/bad cipher or curve, the error path accidentally skips the verification and returns OK, thus ignoring any certificate problems.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('c554e5b200cd867922a6272e468ab3cd433cb0be')">
                                    <div class="issue-number">184</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="c554e5b200cd867922a6272e468ab3cd433cb0be">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> libcurl skips the certificate verification for a QUIC connection under certain conditions, when built to use wolfSSL. If told to use an unknown/bad cipher or curve, the error path accidentally skips the verification and returns OK, thus ignoring any certificate problems.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('34844f1f26fb2fb225df871e9c9300f9a42f1990')">
                                    <div class="issue-number">185</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="34844f1f26fb2fb225df871e9c9300f9a42f1990">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> elfutils v0.189 was discovered to contain a NULL pointer dereference via the handle_verdef() function at readelf.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('0bab126ee5a58ba1c50a4e5a8fca5a511ccd0054')">
                                    <div class="issue-number">186</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="0bab126ee5a58ba1c50a4e5a8fca5a511ccd0054">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> elfutils v0.189 was discovered to contain a NULL pointer dereference via the handle_verdef() function at readelf.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('5b6703e63280b179e3764bd7b25f35064ab4aac1')">
                                    <div class="issue-number">187</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="5b6703e63280b179e3764bd7b25f35064ab4aac1">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> elfutils v0.189 was discovered to contain a NULL pointer dereference via the handle_verdef() function at readelf.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('06893fcf2f45a9042353b858ca0aeffe4561cc5b')">
                                    <div class="issue-number">188</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="06893fcf2f45a9042353b858ca0aeffe4561cc5b">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> elfutils v0.189 was discovered to contain a NULL pointer dereference via the handle_verdef() function at readelf.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('1cc53aee4ae47a2c4bccf8b914622c323a00ecdd')">
                                    <div class="issue-number">189</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="1cc53aee4ae47a2c4bccf8b914622c323a00ecdd">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> libexpat through 2.5.0 allows recursive XML Entity Expansion if XML_DTD is undefined at compile time.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('432f77f56879f1aebfe445648480d941b231fe49')">
                                    <div class="issue-number">190</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="432f77f56879f1aebfe445648480d941b231fe49">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> libexpat through 2.6.1 allows an XML Entity Expansion attack when there is isolated use of external parsers (created via XML_ExternalEntityParserCreate).</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('e17225bcd6c7d4e0775e3fe39ee0a837d984685a')">
                                    <div class="issue-number">191</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="e17225bcd6c7d4e0775e3fe39ee0a837d984685a">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> libexpat through 2.5.0 allows recursive XML Entity Expansion if XML_DTD is undefined at compile time.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('5291350813cac2dfef8381f308edb7262645442f')">
                                    <div class="issue-number">192</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="5291350813cac2dfef8381f308edb7262645442f">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> libexpat through 2.6.1 allows an XML Entity Expansion attack when there is isolated use of external parsers (created via XML_ExternalEntityParserCreate).</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('721b07caeb60944f4611448f9b167825937338a9')">
                                    <div class="issue-number">193</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="721b07caeb60944f4611448f9b167825937338a9">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> libiberty/rust-demangle.c in GNU GCC 11.2 allows stack consumption in demangle_const, as demonstrated by nm-new.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('c189d0ba4d537731f6f9218926ec995e142a4c4e')">
                                    <div class="issue-number">194</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="c189d0ba4d537731f6f9218926ec995e142a4c4e">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> 

**DISPUTED**A failure in the -fstack-protector feature in GCC-based toolchains 
that target AArch64 allows an attacker to exploit an existing buffer 
overflow in dynamically-sized local variables in your application 
without this being detected. This stack-protector failure only applies 
to C99-style dynamically-sized local variables or those created using 
alloca(). The stack-protector operates as intended for statically-sized 
local variables.

The default behavior when the stack-protector 
detects an overflow is to terminate your application, resulting in 
controlled loss of availability. An attacker who can exploit a buffer 
overflow without triggering the stack-protector might be able to change 
program flow control to cause an uncontrolled loss of availability or to
 go further and affect confidentiality or integrity. NOTE: The GCC project argues that this is a missed hardening bug and not a vulnerability by itself.





</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('29d9977df86376dd3b39792804a76fb4afde062f')">
                                    <div class="issue-number">195</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="29d9977df86376dd3b39792804a76fb4afde062f">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> libiberty/rust-demangle.c in GNU GCC 11.2 allows stack consumption in demangle_const, as demonstrated by nm-new.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('66ac2f1c8e5150d3a66e12b7a31bbd65de53e3b6')">
                                    <div class="issue-number">196</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="66ac2f1c8e5150d3a66e12b7a31bbd65de53e3b6">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> 

**DISPUTED**A failure in the -fstack-protector feature in GCC-based toolchains 
that target AArch64 allows an attacker to exploit an existing buffer 
overflow in dynamically-sized local variables in your application 
without this being detected. This stack-protector failure only applies 
to C99-style dynamically-sized local variables or those created using 
alloca(). The stack-protector operates as intended for statically-sized 
local variables.

The default behavior when the stack-protector 
detects an overflow is to terminate your application, resulting in 
controlled loss of availability. An attacker who can exploit a buffer 
overflow without triggering the stack-protector might be able to change 
program flow control to cause an uncontrolled loss of availability or to
 go further and affect confidentiality or integrity. NOTE: The GCC project argues that this is a missed hardening bug and not a vulnerability by itself.





</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('3ffbf19b018d8fceec99ed60a40c83bbbad7bec0')">
                                    <div class="issue-number">197</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="3ffbf19b018d8fceec99ed60a40c83bbbad7bec0">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> cipher/elgamal.c in Libgcrypt through 1.8.2, when used to encrypt messages directly, improperly encodes plaintexts, which allows attackers to obtain sensitive information by reading ciphertext data (i.e., it does not have semantic security in face of a ciphertext-only attack). The Decisional Diffie-Hellman (DDH) assumption does not hold for Libgcrypt's ElGamal implementation.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('1af52060dbaf1587bb6ab96ca2045f73a994b466')">
                                    <div class="issue-number">198</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="1af52060dbaf1587bb6ab96ca2045f73a994b466">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> GLib 2.31.8 and earlier, when the g_str_hash function is used, computes hash values without restricting the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table. NOTE: this issue may be disputed by the vendor; the existence of the g_str_hash function is not a vulnerability in the library, because callers of g_hash_table_new and g_hash_table_new_full can specify an arbitrary hash function that is appropriate for the application.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('198b8b822d0c834f98db7a8c3164e1d1cc8064f3')">
                                    <div class="issue-number">199</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="198b8b822d0c834f98db7a8c3164e1d1cc8064f3">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> GLib 2.31.8 and earlier, when the g_str_hash function is used, computes hash values without restricting the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table. NOTE: this issue may be disputed by the vendor; the existence of the g_str_hash function is not a vulnerability in the library, because callers of g_hash_table_new and g_hash_table_new_full can specify an arbitrary hash function that is appropriate for the application.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('3521abf70327263d1084f2fdb86826f4f730cf05')">
                                    <div class="issue-number">200</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="3521abf70327263d1084f2fdb86826f4f730cf05">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> GLib 2.31.8 and earlier, when the g_str_hash function is used, computes hash values without restricting the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table. NOTE: this issue may be disputed by the vendor; the existence of the g_str_hash function is not a vulnerability in the library, because callers of g_hash_table_new and g_hash_table_new_full can specify an arbitrary hash function that is appropriate for the application.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('579cad032832f34fccb7574586a2a8d04dff057d')">
                                    <div class="issue-number">201</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="579cad032832f34fccb7574586a2a8d04dff057d">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> GLib 2.31.8 and earlier, when the g_str_hash function is used, computes hash values without restricting the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table. NOTE: this issue may be disputed by the vendor; the existence of the g_str_hash function is not a vulnerability in the library, because callers of g_hash_table_new and g_hash_table_new_full can specify an arbitrary hash function that is appropriate for the application.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('3a1cc0a134f54f5db92824a0aa3f8a5310305110')">
                                    <div class="issue-number">202</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="3a1cc0a134f54f5db92824a0aa3f8a5310305110">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> GLib 2.31.8 and earlier, when the g_str_hash function is used, computes hash values without restricting the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via crafted input to an application that maintains a hash table. NOTE: this issue may be disputed by the vendor; the existence of the g_str_hash function is not a vulnerability in the library, because callers of g_hash_table_new and g_hash_table_new_full can specify an arbitrary hash function that is appropriate for the application.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('c967c587cfba897309e07e9e35fef9612e195f59')">
                                    <div class="issue-number">203</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="c967c587cfba897309e07e9e35fef9612e195f59">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The SSL protocol, as used in certain configurations in Microsoft Windows and Microsoft Internet Explorer, Mozilla Firefox, Google Chrome, Opera, and other products, encrypts data by using CBC mode with chained initialization vectors, which allows man-in-the-middle attackers to obtain plaintext HTTP headers via a blockwise chosen-boundary attack (BCBA) on an HTTPS session, in conjunction with JavaScript code that uses (1) the HTML5 WebSocket API, (2) the Java URLConnection API, or (3) the Silverlight WebClient API, aka a "BEAST" attack.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('45d9a001438e0914894e964a6a03d29c258c6c3f')">
                                    <div class="issue-number">204</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="45d9a001438e0914894e964a6a03d29c258c6c3f">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> libiberty/rust-demangle.c in GNU GCC 11.2 allows stack consumption in demangle_const, as demonstrated by nm-new.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('084784822bcafc521577bc06dcd4063ef94aa8e5')">
                                    <div class="issue-number">205</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="084784822bcafc521577bc06dcd4063ef94aa8e5">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> 

**DISPUTED**A failure in the -fstack-protector feature in GCC-based toolchains 
that target AArch64 allows an attacker to exploit an existing buffer 
overflow in dynamically-sized local variables in your application 
without this being detected. This stack-protector failure only applies 
to C99-style dynamically-sized local variables or those created using 
alloca(). The stack-protector operates as intended for statically-sized 
local variables.

The default behavior when the stack-protector 
detects an overflow is to terminate your application, resulting in 
controlled loss of availability. An attacker who can exploit a buffer 
overflow without triggering the stack-protector might be able to change 
program flow control to cause an uncontrolled loss of availability or to
 go further and affect confidentiality or integrity. NOTE: The GCC project argues that this is a missed hardening bug and not a vulnerability by itself.





</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('15071b9cfe2ee3860751f0f6b3bf22b6a6cc5c16')">
                                    <div class="issue-number">206</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="15071b9cfe2ee3860751f0f6b3bf22b6a6cc5c16">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The C++ symbol demangler routine in cplus-dem.c in libiberty, as distributed in GNU Binutils 2.29, allows remote attackers to cause a denial of service (excessive memory allocation and application crash) via a crafted file, as demonstrated by a call from the Binary File Descriptor (BFD) library (aka libbfd).</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('e81d2779743ee0ecc9f0eccddd7302d8411eb26d')">
                                    <div class="issue-number">207</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="e81d2779743ee0ecc9f0eccddd7302d8411eb26d">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The demangle_template function in cplus-dem.c in GNU libiberty, as distributed in GNU Binutils 2.31.1, contains an integer overflow vulnerability (for "Create an array for saving the template argument values") that can trigger a heap-based buffer overflow, as demonstrated by nm.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('068eb1888a75feb723f007410a1113bfb2c1efab')">
                                    <div class="issue-number">208</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="068eb1888a75feb723f007410a1113bfb2c1efab">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A heap-based buffer over-read exists in the function d_expression_1 in cp-demangle.c in GNU libiberty, as distributed in GNU Binutils 2.31.1. A crafted input can cause segmentation faults, leading to denial-of-service, as demonstrated by c++filt.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('5c86018d46cf4fe8b227a698e25cb7632cbce428')">
                                    <div class="issue-number">209</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="5c86018d46cf4fe8b227a698e25cb7632cbce428">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in cplus-dem.c in GNU libiberty, as distributed in GNU Binutils 2.30. Stack Exhaustion occurs in the C++ demangling functions provided by libiberty, and there are recursive stack frames: demangle_template_value_parm, demangle_integral_value, and demangle_expression.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('44c60ffece288eba29548257862661d5780d8622')">
                                    <div class="issue-number">210</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="44c60ffece288eba29548257862661d5780d8622">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in GNU libiberty, as distributed in GNU Binutils 2.36. It is a stack-overflow issue in demangle_type in rust-demangle.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('a9fb12509aedee6efc90d7cf95f8294ffe191de1')">
                                    <div class="issue-number">211</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="a9fb12509aedee6efc90d7cf95f8294ffe191de1">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A potential heap based buffer overflow was found in _bfd_elf_slurp_version_tables() in bfd/elf.c. This may lead to loss of availability.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('bcc7403ba360e344b95a1219fe79920fa6acbda4')">
                                    <div class="issue-number">212</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="bcc7403ba360e344b95a1219fe79920fa6acbda4">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in MIT Kerberos 5 (aka krb5) through 1.16. There is a variable "dbentry->n_key_data" in kadmin/dbutil/dump.c that can store 16-bit data but unknowingly the developer has assigned a "u4" variable to it, which is for 32-bit data. An attacker can use this vulnerability to affect other artifacts of the database as we know that a Kerberos database dump file contains trusted data.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('2fbf5188a5daf8ed1ab5b88aa22ce2ed050ce924')">
                                    <div class="issue-number">213</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="2fbf5188a5daf8ed1ab5b88aa22ce2ed050ce924">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Kerberos 5 (aka krb5) 1.21.2 contains a memory leak in /krb5/src/lib/rpc/pmap_rmt.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('fe466ebc25e083eeeab542b916b5d9930bc1442c')">
                                    <div class="issue-number">214</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="fe466ebc25e083eeeab542b916b5d9930bc1442c">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Kerberos 5 (aka krb5) 1.21.2 contains a memory leak vulnerability in /krb5/src/lib/gssapi/krb5/k5sealv3.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('9d127bc6ab0d86550723146cfd130c71eead3eab')">
                                    <div class="issue-number">215</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="9d127bc6ab0d86550723146cfd130c71eead3eab">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in MIT Kerberos 5 (aka krb5) through 1.16. There is a variable "dbentry->n_key_data" in kadmin/dbutil/dump.c that can store 16-bit data but unknowingly the developer has assigned a "u4" variable to it, which is for 32-bit data. An attacker can use this vulnerability to affect other artifacts of the database as we know that a Kerberos database dump file contains trusted data.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('e676d3bebed1bc85b512cb28a0bfd101c17c7de5')">
                                    <div class="issue-number">216</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="e676d3bebed1bc85b512cb28a0bfd101c17c7de5">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Kerberos 5 (aka krb5) 1.21.2 contains a memory leak in /krb5/src/lib/rpc/pmap_rmt.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('6c99dfae999970e16ec7f0aec96f97176a57b2ac')">
                                    <div class="issue-number">217</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="6c99dfae999970e16ec7f0aec96f97176a57b2ac">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Kerberos 5 (aka krb5) 1.21.2 contains a memory leak vulnerability in /krb5/src/lib/gssapi/krb5/k5sealv3.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('0c18cf017ff24aafb6acfaecd72394346d77d39b')">
                                    <div class="issue-number">218</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="0c18cf017ff24aafb6acfaecd72394346d77d39b">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> libheif v1.17.5 was discovered to contain a segmentation violation via the function find_exif_tag at /libheif/exif.cc.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('e6943cc4cc4d470422e51e48db480e01c2a466bd')">
                                    <div class="issue-number">219</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="e6943cc4cc4d470422e51e48db480e01c2a466bd">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> libheif <= 1.17.6 contains a memory leak in the function JpegEncoder::Encode. This flaw allows an attacker to cause a denial of service attack.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('d4193c64260d9e87341d4dde363c10382532770a')">
                                    <div class="issue-number">220</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="d4193c64260d9e87341d4dde363c10382532770a">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> libiberty/rust-demangle.c in GNU GCC 11.2 allows stack consumption in demangle_const, as demonstrated by nm-new.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('11a242a8e7eccadff0184adb02a9d1f060c70287')">
                                    <div class="issue-number">221</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="11a242a8e7eccadff0184adb02a9d1f060c70287">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> 

**DISPUTED**A failure in the -fstack-protector feature in GCC-based toolchains 
that target AArch64 allows an attacker to exploit an existing buffer 
overflow in dynamically-sized local variables in your application 
without this being detected. This stack-protector failure only applies 
to C99-style dynamically-sized local variables or those created using 
alloca(). The stack-protector operates as intended for statically-sized 
local variables.

The default behavior when the stack-protector 
detects an overflow is to terminate your application, resulting in 
controlled loss of availability. An attacker who can exploit a buffer 
overflow without triggering the stack-protector might be able to change 
program flow control to cause an uncontrolled loss of availability or to
 go further and affect confidentiality or integrity. NOTE: The GCC project argues that this is a missed hardening bug and not a vulnerability by itself.





</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('f6065b69b2ebe6998497831cdef4af837f5549e9')">
                                    <div class="issue-number">222</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="f6065b69b2ebe6998497831cdef4af837f5549e9">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in Jansson through 2.13.1. Due to a parsing error in json_loads, there's an out-of-bounds read-access bug. NOTE: the vendor reports that this only occurs when a programmer fails to follow the API specification</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('e71224583380f2ec50c4933a5a5c58ee53c726a2')">
                                    <div class="issue-number">223</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="e71224583380f2ec50c4933a5a5c58ee53c726a2">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In LibTIFF 4.0.8, there is a memory malloc failure in tif_jbig.c. A crafted TIFF document can lead to an abort resulting in a remote denial of service attack.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('b3c0a89c5b290e13fda8ed6771cad5714b381dbf')">
                                    <div class="issue-number">224</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="b3c0a89c5b290e13fda8ed6771cad5714b381dbf">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In LibTIFF 4.0.8, there is a memory malloc failure in tif_jbig.c. A crafted TIFF document can lead to an abort resulting in a remote denial of service attack.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('53eee3351036f16c7196f4d1f20605de3663dd48')">
                                    <div class="issue-number">225</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="53eee3351036f16c7196f4d1f20605de3663dd48">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in MIT Kerberos 5 (aka krb5) through 1.16. There is a variable "dbentry->n_key_data" in kadmin/dbutil/dump.c that can store 16-bit data but unknowingly the developer has assigned a "u4" variable to it, which is for 32-bit data. An attacker can use this vulnerability to affect other artifacts of the database as we know that a Kerberos database dump file contains trusted data.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('a828a00ac3f6a8e0b987c1494cf190fbe8a54d72')">
                                    <div class="issue-number">226</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="a828a00ac3f6a8e0b987c1494cf190fbe8a54d72">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Kerberos 5 (aka krb5) 1.21.2 contains a memory leak in /krb5/src/lib/rpc/pmap_rmt.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('91d1a757a9dde4c1a5938e32fce80999a5997eb2')">
                                    <div class="issue-number">227</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="91d1a757a9dde4c1a5938e32fce80999a5997eb2">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Kerberos 5 (aka krb5) 1.21.2 contains a memory leak vulnerability in /krb5/src/lib/gssapi/krb5/k5sealv3.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('83b704a0c5db05773be7d3a55f639ca6ca8d8f3c')">
                                    <div class="issue-number">228</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="83b704a0c5db05773be7d3a55f639ca6ca8d8f3c">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in MIT Kerberos 5 (aka krb5) through 1.16. There is a variable "dbentry->n_key_data" in kadmin/dbutil/dump.c that can store 16-bit data but unknowingly the developer has assigned a "u4" variable to it, which is for 32-bit data. An attacker can use this vulnerability to affect other artifacts of the database as we know that a Kerberos database dump file contains trusted data.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('802180ffe94a04eca892fb744703aaf015a3adfd')">
                                    <div class="issue-number">229</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="802180ffe94a04eca892fb744703aaf015a3adfd">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Kerberos 5 (aka krb5) 1.21.2 contains a memory leak in /krb5/src/lib/rpc/pmap_rmt.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('43e85e82a9402ee2bb5dfa7add009f16ba9eafda')">
                                    <div class="issue-number">230</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="43e85e82a9402ee2bb5dfa7add009f16ba9eafda">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Kerberos 5 (aka krb5) 1.21.2 contains a memory leak vulnerability in /krb5/src/lib/gssapi/krb5/k5sealv3.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('820ac63cf1d73c89491c6ec8a5745f6b4a075b23')">
                                    <div class="issue-number">231</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="820ac63cf1d73c89491c6ec8a5745f6b4a075b23">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in MIT Kerberos 5 (aka krb5) through 1.16. There is a variable "dbentry->n_key_data" in kadmin/dbutil/dump.c that can store 16-bit data but unknowingly the developer has assigned a "u4" variable to it, which is for 32-bit data. An attacker can use this vulnerability to affect other artifacts of the database as we know that a Kerberos database dump file contains trusted data.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('2ec8a7ec626b63f0eeefe2c7c623d29c2c61ff50')">
                                    <div class="issue-number">232</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="2ec8a7ec626b63f0eeefe2c7c623d29c2c61ff50">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Kerberos 5 (aka krb5) 1.21.2 contains a memory leak in /krb5/src/lib/rpc/pmap_rmt.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('3b3d3e993ef3e85e04949b4563ed97f87434191a')">
                                    <div class="issue-number">233</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="3b3d3e993ef3e85e04949b4563ed97f87434191a">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Kerberos 5 (aka krb5) 1.21.2 contains a memory leak vulnerability in /krb5/src/lib/gssapi/krb5/k5sealv3.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('81b7641ebb34b832cc4bd45d1fad6856483489d2')">
                                    <div class="issue-number">234</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="81b7641ebb34b832cc4bd45d1fad6856483489d2">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in MIT Kerberos 5 (aka krb5) through 1.16. There is a variable "dbentry->n_key_data" in kadmin/dbutil/dump.c that can store 16-bit data but unknowingly the developer has assigned a "u4" variable to it, which is for 32-bit data. An attacker can use this vulnerability to affect other artifacts of the database as we know that a Kerberos database dump file contains trusted data.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('43baf9b56e057011ec29c796d7a3312b713481b8')">
                                    <div class="issue-number">235</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="43baf9b56e057011ec29c796d7a3312b713481b8">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Kerberos 5 (aka krb5) 1.21.2 contains a memory leak in /krb5/src/lib/rpc/pmap_rmt.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('35dcdeb2ff97da8a2647cee97ee8b8f28539ba18')">
                                    <div class="issue-number">236</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="35dcdeb2ff97da8a2647cee97ee8b8f28539ba18">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Kerberos 5 (aka krb5) 1.21.2 contains a memory leak vulnerability in /krb5/src/lib/gssapi/krb5/k5sealv3.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('e2d4b2eb417a34799541a559440e1f89c775f66c')">
                                    <div class="issue-number">237</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="e2d4b2eb417a34799541a559440e1f89c775f66c">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in MIT Kerberos 5 (aka krb5) through 1.16. There is a variable "dbentry->n_key_data" in kadmin/dbutil/dump.c that can store 16-bit data but unknowingly the developer has assigned a "u4" variable to it, which is for 32-bit data. An attacker can use this vulnerability to affect other artifacts of the database as we know that a Kerberos database dump file contains trusted data.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('d6d3b82c97ebf47e84a42da83cb350c1b69c29e1')">
                                    <div class="issue-number">238</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="d6d3b82c97ebf47e84a42da83cb350c1b69c29e1">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Kerberos 5 (aka krb5) 1.21.2 contains a memory leak in /krb5/src/lib/rpc/pmap_rmt.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('4f90351ff51d82529730ab0d6e40af31681f3a4e')">
                                    <div class="issue-number">239</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="4f90351ff51d82529730ab0d6e40af31681f3a4e">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Kerberos 5 (aka krb5) 1.21.2 contains a memory leak vulnerability in /krb5/src/lib/gssapi/krb5/k5sealv3.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('1693cb308deaf451ee5a7c386ad8d4825c8aa762')">
                                    <div class="issue-number">240</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="1693cb308deaf451ee5a7c386ad8d4825c8aa762">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in MIT Kerberos 5 (aka krb5) through 1.16. There is a variable "dbentry->n_key_data" in kadmin/dbutil/dump.c that can store 16-bit data but unknowingly the developer has assigned a "u4" variable to it, which is for 32-bit data. An attacker can use this vulnerability to affect other artifacts of the database as we know that a Kerberos database dump file contains trusted data.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('ca430f2791cf507a2723926689833e147258b527')">
                                    <div class="issue-number">241</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="ca430f2791cf507a2723926689833e147258b527">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Kerberos 5 (aka krb5) 1.21.2 contains a memory leak in /krb5/src/lib/rpc/pmap_rmt.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('bfd3eb6220d0870ac3b31a303ed7a5dfcbabb454')">
                                    <div class="issue-number">242</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="bfd3eb6220d0870ac3b31a303ed7a5dfcbabb454">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Kerberos 5 (aka krb5) 1.21.2 contains a memory leak vulnerability in /krb5/src/lib/gssapi/krb5/k5sealv3.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('2355b483b85e95e4f38629538f95261d77082db2')">
                                    <div class="issue-number">243</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="2355b483b85e95e4f38629538f95261d77082db2">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in MIT Kerberos 5 (aka krb5) through 1.16. There is a variable "dbentry->n_key_data" in kadmin/dbutil/dump.c that can store 16-bit data but unknowingly the developer has assigned a "u4" variable to it, which is for 32-bit data. An attacker can use this vulnerability to affect other artifacts of the database as we know that a Kerberos database dump file contains trusted data.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('470ba8ab9139fdb3ad48f36180077ae87381a837')">
                                    <div class="issue-number">244</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="470ba8ab9139fdb3ad48f36180077ae87381a837">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Kerberos 5 (aka krb5) 1.21.2 contains a memory leak in /krb5/src/lib/rpc/pmap_rmt.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('7d11406aab810eeaad00b8d7f50ee6bdbc036712')">
                                    <div class="issue-number">245</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="7d11406aab810eeaad00b8d7f50ee6bdbc036712">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Kerberos 5 (aka krb5) 1.21.2 contains a memory leak vulnerability in /krb5/src/lib/gssapi/krb5/k5sealv3.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('be27a1cf1e166a98f4c7f2043977d060370d9af3')">
                                    <div class="issue-number">246</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="be27a1cf1e166a98f4c7f2043977d060370d9af3">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The nss_parse_ciphers function in libraries/libldap/tls_m.c in OpenLDAP does not properly parse OpenSSL-style multi-keyword mode cipher strings, which might cause a weaker than intended cipher to be used and allow remote attackers to have unspecified impact via unknown vectors.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('2c6de7d6e229667e7617cc922da63bc5a71be48e')">
                                    <div class="issue-number">247</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="2c6de7d6e229667e7617cc922da63bc5a71be48e">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> slapd in OpenLDAP 2.4.45 and earlier creates a PID file after dropping privileges to a non-root account, which might allow local users to kill arbitrary processes by leveraging access to this non-root account for PID file modification before a root script executes a "kill `cat /pathname`" command, as demonstrated by openldap-initscript.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('f7a4eea0430586ec674a1c7a3588d5ef79c13d72')">
                                    <div class="issue-number">248</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="f7a4eea0430586ec674a1c7a3588d5ef79c13d72">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> contrib/slapd-modules/nops/nops.c in OpenLDAP through 2.4.45, when both the nops module and the memberof overlay are enabled, attempts to free a buffer that was allocated on the stack, which allows remote attackers to cause a denial of service (slapd crash) via a member MODDN operation.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('b50d04edd1c36eed9038beb5292e02bff503dd55')">
                                    <div class="issue-number">249</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="b50d04edd1c36eed9038beb5292e02bff503dd55">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> libldap in certain third-party OpenLDAP packages has a certificate-validation flaw when the third-party package is asserting RFC6125 support. It considers CN even when there is a non-matching subjectAltName (SAN). This is fixed in, for example, openldap-2.4.46-10.el8 in Red Hat Enterprise Linux.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('e24dae69872f17089c99f42eb534f46868c2ba79')">
                                    <div class="issue-number">250</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="e24dae69872f17089c99f42eb534f46868c2ba79">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> libiberty/rust-demangle.c in GNU GCC 11.2 allows stack consumption in demangle_const, as demonstrated by nm-new.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('db91ab68f2cc48b4ce1e5a4bc4f13e7bc11525d1')">
                                    <div class="issue-number">251</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="db91ab68f2cc48b4ce1e5a4bc4f13e7bc11525d1">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> 

**DISPUTED**A failure in the -fstack-protector feature in GCC-based toolchains 
that target AArch64 allows an attacker to exploit an existing buffer 
overflow in dynamically-sized local variables in your application 
without this being detected. This stack-protector failure only applies 
to C99-style dynamically-sized local variables or those created using 
alloca(). The stack-protector operates as intended for statically-sized 
local variables.

The default behavior when the stack-protector 
detects an overflow is to terminate your application, resulting in 
controlled loss of availability. An attacker who can exploit a buffer 
overflow without triggering the stack-protector might be able to change 
program flow control to cause an uncontrolled loss of availability or to
 go further and affect confidentiality or integrity. NOTE: The GCC project argues that this is a missed hardening bug and not a vulnerability by itself.





</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('ff3d425c14ec39d70f25be6b84fcbfe2b5234fe9')">
                                    <div class="issue-number">252</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="ff3d425c14ec39d70f25be6b84fcbfe2b5234fe9">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A design flaw in image processing software that modifies JPEG images might not modify the original EXIF thumbnail, which could lead to an information leak of potentially sensitive visual information that had been removed from the main JPEG image.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('1ee7596b236ea778e23b015114c3c49a613c82e3')">
                                    <div class="issue-number">253</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="1ee7596b236ea778e23b015114c3c49a613c82e3">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Multiple unspecified vulnerabilities in GraphicsMagick before 1.2.4 allow remote attackers to cause a denial of service (crash, infinite loop, or memory consumption) via (a) unspecified vectors in the (1) AVI, (2) AVS, (3) DCM, (4) EPT, (5) FITS, (6) MTV, (7) PALM, (8) RLA, and (9) TGA decoder readers; and (b) the GetImageCharacteristics function in magick/image.c, as reachable from a crafted (10) PNG, (11) JPEG, (12) BMP, or (13) TIFF file.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('b3cffad655d65b2f07a0b9ae4267e903d1d9dcd8')">
                                    <div class="issue-number">254</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="b3cffad655d65b2f07a0b9ae4267e903d1d9dcd8">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The IsPixelMonochrome function in MagickCore/pixel-accessor.h in ImageMagick 7.0.3.0 allows remote attackers to cause a denial of service (out-of-bounds read and crash) via a crafted file.  NOTE: the vendor says "This is a Q64 issue and we do not support Q64."</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('f38a2e51ec3da35e6380c10691cf9729f749d7f4')">
                                    <div class="issue-number">255</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="f38a2e51ec3da35e6380c10691cf9729f749d7f4">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The WritePICONImage function in coders/xpm.c in ImageMagick 7.0.6-4 allows remote attackers to cause a denial of service (memory leak) via a crafted file that is mishandled in an OpenPixelCache call.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('0119b8140372bcae12bcb19a8298c4fecbab94c8')">
                                    <div class="issue-number">256</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="0119b8140372bcae12bcb19a8298c4fecbab94c8">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The WritePICONImage function in coders/xpm.c in ImageMagick 7.0.6-4 allows remote attackers to cause a denial of service (memory leak) via a crafted file that is mishandled in an AcquireSemaphoreInfo call.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('2de218681ec848e774c08f1fa3a3aecfe68c80ef')">
                                    <div class="issue-number">257</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="2de218681ec848e774c08f1fa3a3aecfe68c80ef">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The ReadPCXImage function in coders/pcx.c in ImageMagick 7.0.4.9 allows remote attackers to cause a denial of service (attempted large memory allocation and application crash) via a crafted file. NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-8862 and CVE-2016-8866.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('6166677a3bed7b6916176a1d314b0fff163d728c')">
                                    <div class="issue-number">258</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="6166677a3bed7b6916176a1d314b0fff163d728c">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In ImageMagick 7.0.8-11 Q16, a tiny input file 0x50 0x36 0x36 0x36 0x36 0x4c 0x36 0x38 0x36 0x36 0x36 0x36 0x36 0x36 0x1f 0x35 0x50 0x00 can result in a hang of several minutes during which CPU and memory resources are consumed until ultimately an attempted large memory allocation fails. Remote attackers could leverage this vulnerability to cause a denial of service via a crafted file.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('67e32940f07e2ae8e96e81da64bbe60c24f2ad51')">
                                    <div class="issue-number">259</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="67e32940f07e2ae8e96e81da64bbe60c24f2ad51">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A flaw was found in ImageMagick in versions before 7.0.11, where a division by zero in sRGBTransformImage() in the MagickCore/colorspace.c may trigger undefined behavior via a crafted image file that is submitted by an attacker processed by an application using ImageMagick. The highest threat from this vulnerability is to system availability.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('7c5718100de7f2abdc00595e2b4af07b84609104')">
                                    <div class="issue-number">260</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="7c5718100de7f2abdc00595e2b4af07b84609104">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A vulnerability was found in ImageMagick. This security flaw cause a remote code execution vulnerability in OpenBlob with --enable-pipes configured.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('267907f7f4051a70f09c669c08cdcd06d184279d')">
                                    <div class="issue-number">261</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="267907f7f4051a70f09c669c08cdcd06d184279d">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A design flaw in image processing software that modifies JPEG images might not modify the original EXIF thumbnail, which could lead to an information leak of potentially sensitive visual information that had been removed from the main JPEG image.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('b6cac18858b7a7a9ff5a66bf2adfa6da5f600f03')">
                                    <div class="issue-number">262</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="b6cac18858b7a7a9ff5a66bf2adfa6da5f600f03">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Multiple unspecified vulnerabilities in GraphicsMagick before 1.2.4 allow remote attackers to cause a denial of service (crash, infinite loop, or memory consumption) via (a) unspecified vectors in the (1) AVI, (2) AVS, (3) DCM, (4) EPT, (5) FITS, (6) MTV, (7) PALM, (8) RLA, and (9) TGA decoder readers; and (b) the GetImageCharacteristics function in magick/image.c, as reachable from a crafted (10) PNG, (11) JPEG, (12) BMP, or (13) TIFF file.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('d7444a3300639e1aec89c649bd4f33cb87d29db9')">
                                    <div class="issue-number">263</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="d7444a3300639e1aec89c649bd4f33cb87d29db9">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The IsPixelMonochrome function in MagickCore/pixel-accessor.h in ImageMagick 7.0.3.0 allows remote attackers to cause a denial of service (out-of-bounds read and crash) via a crafted file.  NOTE: the vendor says "This is a Q64 issue and we do not support Q64."</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('03fd2d5af5b779d8b6c40efe0b26c146eac6c64a')">
                                    <div class="issue-number">264</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="03fd2d5af5b779d8b6c40efe0b26c146eac6c64a">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The WritePICONImage function in coders/xpm.c in ImageMagick 7.0.6-4 allows remote attackers to cause a denial of service (memory leak) via a crafted file that is mishandled in an OpenPixelCache call.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('4e2979c2f4f6dc3714fd2d962eb3cad3938deeab')">
                                    <div class="issue-number">265</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="4e2979c2f4f6dc3714fd2d962eb3cad3938deeab">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The WritePICONImage function in coders/xpm.c in ImageMagick 7.0.6-4 allows remote attackers to cause a denial of service (memory leak) via a crafted file that is mishandled in an AcquireSemaphoreInfo call.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('bac3a9f8479636e6765712602a7d6c20803eeb7d')">
                                    <div class="issue-number">266</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="bac3a9f8479636e6765712602a7d6c20803eeb7d">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The ReadPCXImage function in coders/pcx.c in ImageMagick 7.0.4.9 allows remote attackers to cause a denial of service (attempted large memory allocation and application crash) via a crafted file. NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-8862 and CVE-2016-8866.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('392a31dedf5c83968913351b99893000f725b74c')">
                                    <div class="issue-number">267</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="392a31dedf5c83968913351b99893000f725b74c">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In ImageMagick 7.0.8-11 Q16, a tiny input file 0x50 0x36 0x36 0x36 0x36 0x4c 0x36 0x38 0x36 0x36 0x36 0x36 0x36 0x36 0x1f 0x35 0x50 0x00 can result in a hang of several minutes during which CPU and memory resources are consumed until ultimately an attempted large memory allocation fails. Remote attackers could leverage this vulnerability to cause a denial of service via a crafted file.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('5d68e25adb357e5a77661b96f87e5b01737e9c4c')">
                                    <div class="issue-number">268</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="5d68e25adb357e5a77661b96f87e5b01737e9c4c">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A flaw was found in ImageMagick in versions before 7.0.11, where a division by zero in sRGBTransformImage() in the MagickCore/colorspace.c may trigger undefined behavior via a crafted image file that is submitted by an attacker processed by an application using ImageMagick. The highest threat from this vulnerability is to system availability.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('57a9b6bd2b909592dee1adf7d537b54421dc886e')">
                                    <div class="issue-number">269</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="57a9b6bd2b909592dee1adf7d537b54421dc886e">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A vulnerability was found in ImageMagick. This security flaw cause a remote code execution vulnerability in OpenBlob with --enable-pipes configured.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('d6b59534677c12c4d87a9950a28fe86d268472b3')">
                                    <div class="issue-number">270</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="d6b59534677c12c4d87a9950a28fe86d268472b3">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A design flaw in image processing software that modifies JPEG images might not modify the original EXIF thumbnail, which could lead to an information leak of potentially sensitive visual information that had been removed from the main JPEG image.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('b517663fd660390835c9672b66740e65852441f6')">
                                    <div class="issue-number">271</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="b517663fd660390835c9672b66740e65852441f6">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Multiple unspecified vulnerabilities in GraphicsMagick before 1.2.4 allow remote attackers to cause a denial of service (crash, infinite loop, or memory consumption) via (a) unspecified vectors in the (1) AVI, (2) AVS, (3) DCM, (4) EPT, (5) FITS, (6) MTV, (7) PALM, (8) RLA, and (9) TGA decoder readers; and (b) the GetImageCharacteristics function in magick/image.c, as reachable from a crafted (10) PNG, (11) JPEG, (12) BMP, or (13) TIFF file.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('2cce6ec5e3a0384a23535548dcfe4a12fcc13fc5')">
                                    <div class="issue-number">272</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="2cce6ec5e3a0384a23535548dcfe4a12fcc13fc5">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The IsPixelMonochrome function in MagickCore/pixel-accessor.h in ImageMagick 7.0.3.0 allows remote attackers to cause a denial of service (out-of-bounds read and crash) via a crafted file.  NOTE: the vendor says "This is a Q64 issue and we do not support Q64."</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('bd38c0bb171d5f07cf24412c2ca8e74402180816')">
                                    <div class="issue-number">273</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="bd38c0bb171d5f07cf24412c2ca8e74402180816">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The WritePICONImage function in coders/xpm.c in ImageMagick 7.0.6-4 allows remote attackers to cause a denial of service (memory leak) via a crafted file that is mishandled in an OpenPixelCache call.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('92e9772cd68e3973573de8ff2ed197ff81635766')">
                                    <div class="issue-number">274</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="92e9772cd68e3973573de8ff2ed197ff81635766">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The WritePICONImage function in coders/xpm.c in ImageMagick 7.0.6-4 allows remote attackers to cause a denial of service (memory leak) via a crafted file that is mishandled in an AcquireSemaphoreInfo call.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('0d5c433f465a1e2463e64e4ca4f96ebffb3c366a')">
                                    <div class="issue-number">275</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="0d5c433f465a1e2463e64e4ca4f96ebffb3c366a">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The ReadPCXImage function in coders/pcx.c in ImageMagick 7.0.4.9 allows remote attackers to cause a denial of service (attempted large memory allocation and application crash) via a crafted file. NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-8862 and CVE-2016-8866.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('6231ccbc961daf7a7710375b0217a910fea7f6fe')">
                                    <div class="issue-number">276</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="6231ccbc961daf7a7710375b0217a910fea7f6fe">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In ImageMagick 7.0.8-11 Q16, a tiny input file 0x50 0x36 0x36 0x36 0x36 0x4c 0x36 0x38 0x36 0x36 0x36 0x36 0x36 0x36 0x1f 0x35 0x50 0x00 can result in a hang of several minutes during which CPU and memory resources are consumed until ultimately an attempted large memory allocation fails. Remote attackers could leverage this vulnerability to cause a denial of service via a crafted file.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('670703034b96ca01a3b7f3dd74831ff8db96569a')">
                                    <div class="issue-number">277</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="670703034b96ca01a3b7f3dd74831ff8db96569a">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A flaw was found in ImageMagick in versions before 7.0.11, where a division by zero in sRGBTransformImage() in the MagickCore/colorspace.c may trigger undefined behavior via a crafted image file that is submitted by an attacker processed by an application using ImageMagick. The highest threat from this vulnerability is to system availability.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('9ffee34b050b3e26ea14e0b3f22fa59633f9811a')">
                                    <div class="issue-number">278</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="9ffee34b050b3e26ea14e0b3f22fa59633f9811a">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A vulnerability was found in ImageMagick. This security flaw cause a remote code execution vulnerability in OpenBlob with --enable-pipes configured.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('d001f591f2458c2d396097e8b98d149e73f08e71')">
                                    <div class="issue-number">279</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="d001f591f2458c2d396097e8b98d149e73f08e71">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A design flaw in image processing software that modifies JPEG images might not modify the original EXIF thumbnail, which could lead to an information leak of potentially sensitive visual information that had been removed from the main JPEG image.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('e8b0d87f2073f84b709a63ff55c9cc1081247c17')">
                                    <div class="issue-number">280</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="e8b0d87f2073f84b709a63ff55c9cc1081247c17">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Multiple unspecified vulnerabilities in GraphicsMagick before 1.2.4 allow remote attackers to cause a denial of service (crash, infinite loop, or memory consumption) via (a) unspecified vectors in the (1) AVI, (2) AVS, (3) DCM, (4) EPT, (5) FITS, (6) MTV, (7) PALM, (8) RLA, and (9) TGA decoder readers; and (b) the GetImageCharacteristics function in magick/image.c, as reachable from a crafted (10) PNG, (11) JPEG, (12) BMP, or (13) TIFF file.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('0e0fb011e7103d7516b2469f860a3bafdb2f5a7b')">
                                    <div class="issue-number">281</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="0e0fb011e7103d7516b2469f860a3bafdb2f5a7b">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The IsPixelMonochrome function in MagickCore/pixel-accessor.h in ImageMagick 7.0.3.0 allows remote attackers to cause a denial of service (out-of-bounds read and crash) via a crafted file.  NOTE: the vendor says "This is a Q64 issue and we do not support Q64."</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('621266949ec464a4163d3600ebfcda977b5aae33')">
                                    <div class="issue-number">282</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="621266949ec464a4163d3600ebfcda977b5aae33">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The WritePICONImage function in coders/xpm.c in ImageMagick 7.0.6-4 allows remote attackers to cause a denial of service (memory leak) via a crafted file that is mishandled in an OpenPixelCache call.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('efbf41b3473f17d4f7c595e4baf1492960e2093b')">
                                    <div class="issue-number">283</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="efbf41b3473f17d4f7c595e4baf1492960e2093b">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The WritePICONImage function in coders/xpm.c in ImageMagick 7.0.6-4 allows remote attackers to cause a denial of service (memory leak) via a crafted file that is mishandled in an AcquireSemaphoreInfo call.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('adfd61b3ee393bc68f8dd9398d8d78212aacfe73')">
                                    <div class="issue-number">284</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="adfd61b3ee393bc68f8dd9398d8d78212aacfe73">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The ReadPCXImage function in coders/pcx.c in ImageMagick 7.0.4.9 allows remote attackers to cause a denial of service (attempted large memory allocation and application crash) via a crafted file. NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-8862 and CVE-2016-8866.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('e2f161c9c028a3d66d9d541cbe472bdee54db943')">
                                    <div class="issue-number">285</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="e2f161c9c028a3d66d9d541cbe472bdee54db943">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In ImageMagick 7.0.8-11 Q16, a tiny input file 0x50 0x36 0x36 0x36 0x36 0x4c 0x36 0x38 0x36 0x36 0x36 0x36 0x36 0x36 0x1f 0x35 0x50 0x00 can result in a hang of several minutes during which CPU and memory resources are consumed until ultimately an attempted large memory allocation fails. Remote attackers could leverage this vulnerability to cause a denial of service via a crafted file.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('df005ea666e9e5825c9de10b878315d4335ab1de')">
                                    <div class="issue-number">286</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="df005ea666e9e5825c9de10b878315d4335ab1de">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A flaw was found in ImageMagick in versions before 7.0.11, where a division by zero in sRGBTransformImage() in the MagickCore/colorspace.c may trigger undefined behavior via a crafted image file that is submitted by an attacker processed by an application using ImageMagick. The highest threat from this vulnerability is to system availability.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('5f27ebcf4fe472a8f69d92b4e868ff6fb3640353')">
                                    <div class="issue-number">287</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="5f27ebcf4fe472a8f69d92b4e868ff6fb3640353">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A vulnerability was found in ImageMagick. This security flaw cause a remote code execution vulnerability in OpenBlob with --enable-pipes configured.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('2c023a5788a97bf98b0686e360de9fba622d3864')">
                                    <div class="issue-number">288</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="2c023a5788a97bf98b0686e360de9fba622d3864">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A design flaw in image processing software that modifies JPEG images might not modify the original EXIF thumbnail, which could lead to an information leak of potentially sensitive visual information that had been removed from the main JPEG image.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('519a4afeabdffa915d5ee06d29a4730af554bf38')">
                                    <div class="issue-number">289</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="519a4afeabdffa915d5ee06d29a4730af554bf38">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Multiple unspecified vulnerabilities in GraphicsMagick before 1.2.4 allow remote attackers to cause a denial of service (crash, infinite loop, or memory consumption) via (a) unspecified vectors in the (1) AVI, (2) AVS, (3) DCM, (4) EPT, (5) FITS, (6) MTV, (7) PALM, (8) RLA, and (9) TGA decoder readers; and (b) the GetImageCharacteristics function in magick/image.c, as reachable from a crafted (10) PNG, (11) JPEG, (12) BMP, or (13) TIFF file.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('6c4446b71aaf2876774050b75fc35fb304c7af09')">
                                    <div class="issue-number">290</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="6c4446b71aaf2876774050b75fc35fb304c7af09">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The IsPixelMonochrome function in MagickCore/pixel-accessor.h in ImageMagick 7.0.3.0 allows remote attackers to cause a denial of service (out-of-bounds read and crash) via a crafted file.  NOTE: the vendor says "This is a Q64 issue and we do not support Q64."</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('cd4894cf3b98219c8b0b8f233fa748cdad8d2f6b')">
                                    <div class="issue-number">291</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="cd4894cf3b98219c8b0b8f233fa748cdad8d2f6b">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The WritePICONImage function in coders/xpm.c in ImageMagick 7.0.6-4 allows remote attackers to cause a denial of service (memory leak) via a crafted file that is mishandled in an OpenPixelCache call.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('5d8eaf0dd123371d36be68fa44ce9ca96cd4d675')">
                                    <div class="issue-number">292</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="5d8eaf0dd123371d36be68fa44ce9ca96cd4d675">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The WritePICONImage function in coders/xpm.c in ImageMagick 7.0.6-4 allows remote attackers to cause a denial of service (memory leak) via a crafted file that is mishandled in an AcquireSemaphoreInfo call.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('29af3d6e2979f01fa4475c69019df1baf33c64d5')">
                                    <div class="issue-number">293</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="29af3d6e2979f01fa4475c69019df1baf33c64d5">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The ReadPCXImage function in coders/pcx.c in ImageMagick 7.0.4.9 allows remote attackers to cause a denial of service (attempted large memory allocation and application crash) via a crafted file. NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-8862 and CVE-2016-8866.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('03feb37ba174eaab6cdb2b6acdc9181988890f97')">
                                    <div class="issue-number">294</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="03feb37ba174eaab6cdb2b6acdc9181988890f97">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In ImageMagick 7.0.8-11 Q16, a tiny input file 0x50 0x36 0x36 0x36 0x36 0x4c 0x36 0x38 0x36 0x36 0x36 0x36 0x36 0x36 0x1f 0x35 0x50 0x00 can result in a hang of several minutes during which CPU and memory resources are consumed until ultimately an attempted large memory allocation fails. Remote attackers could leverage this vulnerability to cause a denial of service via a crafted file.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('c7a892eaf0d221f1f0c09f4277cac254cbc31e19')">
                                    <div class="issue-number">295</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="c7a892eaf0d221f1f0c09f4277cac254cbc31e19">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A flaw was found in ImageMagick in versions before 7.0.11, where a division by zero in sRGBTransformImage() in the MagickCore/colorspace.c may trigger undefined behavior via a crafted image file that is submitted by an attacker processed by an application using ImageMagick. The highest threat from this vulnerability is to system availability.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('a5ffb51769c5a15a1524848cd1c6186698e7df20')">
                                    <div class="issue-number">296</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="a5ffb51769c5a15a1524848cd1c6186698e7df20">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A vulnerability was found in ImageMagick. This security flaw cause a remote code execution vulnerability in OpenBlob with --enable-pipes configured.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('7e18a8d974d7f77e0fd7bd530cd37990e8baf8b4')">
                                    <div class="issue-number">297</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="7e18a8d974d7f77e0fd7bd530cd37990e8baf8b4">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A design flaw in image processing software that modifies JPEG images might not modify the original EXIF thumbnail, which could lead to an information leak of potentially sensitive visual information that had been removed from the main JPEG image.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('39d29d1d86ce7ca7fa236712577b08f15ac11f9b')">
                                    <div class="issue-number">298</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="39d29d1d86ce7ca7fa236712577b08f15ac11f9b">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Multiple unspecified vulnerabilities in GraphicsMagick before 1.2.4 allow remote attackers to cause a denial of service (crash, infinite loop, or memory consumption) via (a) unspecified vectors in the (1) AVI, (2) AVS, (3) DCM, (4) EPT, (5) FITS, (6) MTV, (7) PALM, (8) RLA, and (9) TGA decoder readers; and (b) the GetImageCharacteristics function in magick/image.c, as reachable from a crafted (10) PNG, (11) JPEG, (12) BMP, or (13) TIFF file.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('7e21776c0ed937cce992ae1f57650fd8fd773984')">
                                    <div class="issue-number">299</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="7e21776c0ed937cce992ae1f57650fd8fd773984">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The IsPixelMonochrome function in MagickCore/pixel-accessor.h in ImageMagick 7.0.3.0 allows remote attackers to cause a denial of service (out-of-bounds read and crash) via a crafted file.  NOTE: the vendor says "This is a Q64 issue and we do not support Q64."</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('52d61b280486d52bfa7efd23f8414e57b5691cda')">
                                    <div class="issue-number">300</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="52d61b280486d52bfa7efd23f8414e57b5691cda">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The WritePICONImage function in coders/xpm.c in ImageMagick 7.0.6-4 allows remote attackers to cause a denial of service (memory leak) via a crafted file that is mishandled in an OpenPixelCache call.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('9da9dad3d8feabe5bf177b4f37e27924ff9c31de')">
                                    <div class="issue-number">301</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="9da9dad3d8feabe5bf177b4f37e27924ff9c31de">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The WritePICONImage function in coders/xpm.c in ImageMagick 7.0.6-4 allows remote attackers to cause a denial of service (memory leak) via a crafted file that is mishandled in an AcquireSemaphoreInfo call.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('bbe01b93568c23f0760ca112e5bec2f6d2de026a')">
                                    <div class="issue-number">302</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="bbe01b93568c23f0760ca112e5bec2f6d2de026a">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The ReadPCXImage function in coders/pcx.c in ImageMagick 7.0.4.9 allows remote attackers to cause a denial of service (attempted large memory allocation and application crash) via a crafted file. NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-8862 and CVE-2016-8866.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('765b11df45893fd91599d3c5eda6b0668c71c4df')">
                                    <div class="issue-number">303</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="765b11df45893fd91599d3c5eda6b0668c71c4df">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In ImageMagick 7.0.8-11 Q16, a tiny input file 0x50 0x36 0x36 0x36 0x36 0x4c 0x36 0x38 0x36 0x36 0x36 0x36 0x36 0x36 0x1f 0x35 0x50 0x00 can result in a hang of several minutes during which CPU and memory resources are consumed until ultimately an attempted large memory allocation fails. Remote attackers could leverage this vulnerability to cause a denial of service via a crafted file.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('eb59ecc9f31954dd16d46a1c79af4cbdc784a8aa')">
                                    <div class="issue-number">304</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="eb59ecc9f31954dd16d46a1c79af4cbdc784a8aa">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A flaw was found in ImageMagick in versions before 7.0.11, where a division by zero in sRGBTransformImage() in the MagickCore/colorspace.c may trigger undefined behavior via a crafted image file that is submitted by an attacker processed by an application using ImageMagick. The highest threat from this vulnerability is to system availability.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('86e957cc8fac3b8abbf6011132f993ca28002b50')">
                                    <div class="issue-number">305</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="86e957cc8fac3b8abbf6011132f993ca28002b50">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A vulnerability was found in ImageMagick. This security flaw cause a remote code execution vulnerability in OpenBlob with --enable-pipes configured.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('afece92a6f639208860b23cfc1dba59af8ae3c2a')">
                                    <div class="issue-number">306</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="afece92a6f639208860b23cfc1dba59af8ae3c2a">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A design flaw in image processing software that modifies JPEG images might not modify the original EXIF thumbnail, which could lead to an information leak of potentially sensitive visual information that had been removed from the main JPEG image.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('9d51dee6b61bd5439312dc05f4fe7e6ffe761135')">
                                    <div class="issue-number">307</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="9d51dee6b61bd5439312dc05f4fe7e6ffe761135">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Multiple unspecified vulnerabilities in GraphicsMagick before 1.2.4 allow remote attackers to cause a denial of service (crash, infinite loop, or memory consumption) via (a) unspecified vectors in the (1) AVI, (2) AVS, (3) DCM, (4) EPT, (5) FITS, (6) MTV, (7) PALM, (8) RLA, and (9) TGA decoder readers; and (b) the GetImageCharacteristics function in magick/image.c, as reachable from a crafted (10) PNG, (11) JPEG, (12) BMP, or (13) TIFF file.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('9af5e641b504c696e7daf2e249408e2dd322d925')">
                                    <div class="issue-number">308</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="9af5e641b504c696e7daf2e249408e2dd322d925">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The IsPixelMonochrome function in MagickCore/pixel-accessor.h in ImageMagick 7.0.3.0 allows remote attackers to cause a denial of service (out-of-bounds read and crash) via a crafted file.  NOTE: the vendor says "This is a Q64 issue and we do not support Q64."</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('621ea8f9d4d06b58e56c7584885d66ad1e92090e')">
                                    <div class="issue-number">309</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="621ea8f9d4d06b58e56c7584885d66ad1e92090e">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The WritePICONImage function in coders/xpm.c in ImageMagick 7.0.6-4 allows remote attackers to cause a denial of service (memory leak) via a crafted file that is mishandled in an OpenPixelCache call.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('08d1ba70dee58b7cb09d6a3a8e6105bf59d3dd36')">
                                    <div class="issue-number">310</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="08d1ba70dee58b7cb09d6a3a8e6105bf59d3dd36">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The WritePICONImage function in coders/xpm.c in ImageMagick 7.0.6-4 allows remote attackers to cause a denial of service (memory leak) via a crafted file that is mishandled in an AcquireSemaphoreInfo call.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('ec2c4f2d64c4b83232588380ecce12c60525e902')">
                                    <div class="issue-number">311</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="ec2c4f2d64c4b83232588380ecce12c60525e902">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The ReadPCXImage function in coders/pcx.c in ImageMagick 7.0.4.9 allows remote attackers to cause a denial of service (attempted large memory allocation and application crash) via a crafted file. NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-8862 and CVE-2016-8866.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('79cc861e18b4734685d98a6595f209976aa437ec')">
                                    <div class="issue-number">312</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="79cc861e18b4734685d98a6595f209976aa437ec">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In ImageMagick 7.0.8-11 Q16, a tiny input file 0x50 0x36 0x36 0x36 0x36 0x4c 0x36 0x38 0x36 0x36 0x36 0x36 0x36 0x36 0x1f 0x35 0x50 0x00 can result in a hang of several minutes during which CPU and memory resources are consumed until ultimately an attempted large memory allocation fails. Remote attackers could leverage this vulnerability to cause a denial of service via a crafted file.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('f95894ce7f883cffd85b59adebc2f35013b6cd13')">
                                    <div class="issue-number">313</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="f95894ce7f883cffd85b59adebc2f35013b6cd13">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A flaw was found in ImageMagick in versions before 7.0.11, where a division by zero in sRGBTransformImage() in the MagickCore/colorspace.c may trigger undefined behavior via a crafted image file that is submitted by an attacker processed by an application using ImageMagick. The highest threat from this vulnerability is to system availability.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('93b05b8d56543e4aadc469133302ff45e97793b7')">
                                    <div class="issue-number">314</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="93b05b8d56543e4aadc469133302ff45e97793b7">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A vulnerability was found in ImageMagick. This security flaw cause a remote code execution vulnerability in OpenBlob with --enable-pipes configured.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('e5a2158eb2f920e777c826a422988845031f050f')">
                                    <div class="issue-number">315</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="e5a2158eb2f920e777c826a422988845031f050f">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A design flaw in image processing software that modifies JPEG images might not modify the original EXIF thumbnail, which could lead to an information leak of potentially sensitive visual information that had been removed from the main JPEG image.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('e31ec08313b2fe646a0bb0c976523eed4e242450')">
                                    <div class="issue-number">316</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="e31ec08313b2fe646a0bb0c976523eed4e242450">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Multiple unspecified vulnerabilities in GraphicsMagick before 1.2.4 allow remote attackers to cause a denial of service (crash, infinite loop, or memory consumption) via (a) unspecified vectors in the (1) AVI, (2) AVS, (3) DCM, (4) EPT, (5) FITS, (6) MTV, (7) PALM, (8) RLA, and (9) TGA decoder readers; and (b) the GetImageCharacteristics function in magick/image.c, as reachable from a crafted (10) PNG, (11) JPEG, (12) BMP, or (13) TIFF file.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('74e8239c0cbf10acba9a5c2bcc34a2689bbefac8')">
                                    <div class="issue-number">317</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="74e8239c0cbf10acba9a5c2bcc34a2689bbefac8">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The IsPixelMonochrome function in MagickCore/pixel-accessor.h in ImageMagick 7.0.3.0 allows remote attackers to cause a denial of service (out-of-bounds read and crash) via a crafted file.  NOTE: the vendor says "This is a Q64 issue and we do not support Q64."</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('e8d18e15a0c48aab6cde9cdb7991d614213afeb6')">
                                    <div class="issue-number">318</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="e8d18e15a0c48aab6cde9cdb7991d614213afeb6">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The WritePICONImage function in coders/xpm.c in ImageMagick 7.0.6-4 allows remote attackers to cause a denial of service (memory leak) via a crafted file that is mishandled in an OpenPixelCache call.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('de9b036aca824903b2c02b47d207c420aa89b9b5')">
                                    <div class="issue-number">319</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="de9b036aca824903b2c02b47d207c420aa89b9b5">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The WritePICONImage function in coders/xpm.c in ImageMagick 7.0.6-4 allows remote attackers to cause a denial of service (memory leak) via a crafted file that is mishandled in an AcquireSemaphoreInfo call.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('0b41cf1791a9c5ce198693713f9d53b146d3231f')">
                                    <div class="issue-number">320</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="0b41cf1791a9c5ce198693713f9d53b146d3231f">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The ReadPCXImage function in coders/pcx.c in ImageMagick 7.0.4.9 allows remote attackers to cause a denial of service (attempted large memory allocation and application crash) via a crafted file. NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-8862 and CVE-2016-8866.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('9221fbd9421e16ba460e9e4e0d131a8c5bda1f2b')">
                                    <div class="issue-number">321</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="9221fbd9421e16ba460e9e4e0d131a8c5bda1f2b">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In ImageMagick 7.0.8-11 Q16, a tiny input file 0x50 0x36 0x36 0x36 0x36 0x4c 0x36 0x38 0x36 0x36 0x36 0x36 0x36 0x36 0x1f 0x35 0x50 0x00 can result in a hang of several minutes during which CPU and memory resources are consumed until ultimately an attempted large memory allocation fails. Remote attackers could leverage this vulnerability to cause a denial of service via a crafted file.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('8142fee1ad1dd0faa9ecc19f726d29a1020a1035')">
                                    <div class="issue-number">322</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="8142fee1ad1dd0faa9ecc19f726d29a1020a1035">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A flaw was found in ImageMagick in versions before 7.0.11, where a division by zero in sRGBTransformImage() in the MagickCore/colorspace.c may trigger undefined behavior via a crafted image file that is submitted by an attacker processed by an application using ImageMagick. The highest threat from this vulnerability is to system availability.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('a7e04c18004bbe618b9ca2162f8be396abb543ec')">
                                    <div class="issue-number">323</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="a7e04c18004bbe618b9ca2162f8be396abb543ec">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A vulnerability was found in ImageMagick. This security flaw cause a remote code execution vulnerability in OpenBlob with --enable-pipes configured.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('2cbcc9dbcd8248552754e655b3e337b5acde4269')">
                                    <div class="issue-number">324</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="2cbcc9dbcd8248552754e655b3e337b5acde4269">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A design flaw in image processing software that modifies JPEG images might not modify the original EXIF thumbnail, which could lead to an information leak of potentially sensitive visual information that had been removed from the main JPEG image.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('c59f334dfb9288c5733606fe3a66f0bc68e95460')">
                                    <div class="issue-number">325</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="c59f334dfb9288c5733606fe3a66f0bc68e95460">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Multiple unspecified vulnerabilities in GraphicsMagick before 1.2.4 allow remote attackers to cause a denial of service (crash, infinite loop, or memory consumption) via (a) unspecified vectors in the (1) AVI, (2) AVS, (3) DCM, (4) EPT, (5) FITS, (6) MTV, (7) PALM, (8) RLA, and (9) TGA decoder readers; and (b) the GetImageCharacteristics function in magick/image.c, as reachable from a crafted (10) PNG, (11) JPEG, (12) BMP, or (13) TIFF file.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('edd527f7cf6a15b1354d83a639776b34de174e00')">
                                    <div class="issue-number">326</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="edd527f7cf6a15b1354d83a639776b34de174e00">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The IsPixelMonochrome function in MagickCore/pixel-accessor.h in ImageMagick 7.0.3.0 allows remote attackers to cause a denial of service (out-of-bounds read and crash) via a crafted file.  NOTE: the vendor says "This is a Q64 issue and we do not support Q64."</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('bb7f88d86bdc60a267ab85531f6bbe3da95ae00c')">
                                    <div class="issue-number">327</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="bb7f88d86bdc60a267ab85531f6bbe3da95ae00c">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The WritePICONImage function in coders/xpm.c in ImageMagick 7.0.6-4 allows remote attackers to cause a denial of service (memory leak) via a crafted file that is mishandled in an OpenPixelCache call.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('5072932d8f74801f3e616826d557ee61fddefe03')">
                                    <div class="issue-number">328</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="5072932d8f74801f3e616826d557ee61fddefe03">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The WritePICONImage function in coders/xpm.c in ImageMagick 7.0.6-4 allows remote attackers to cause a denial of service (memory leak) via a crafted file that is mishandled in an AcquireSemaphoreInfo call.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('92f0c39a8d8307575de55354298096b69d9ef9e5')">
                                    <div class="issue-number">329</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="92f0c39a8d8307575de55354298096b69d9ef9e5">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The ReadPCXImage function in coders/pcx.c in ImageMagick 7.0.4.9 allows remote attackers to cause a denial of service (attempted large memory allocation and application crash) via a crafted file. NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-8862 and CVE-2016-8866.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('633e4cfbaf23474234d1bd8c4249bcdd53bb75f2')">
                                    <div class="issue-number">330</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="633e4cfbaf23474234d1bd8c4249bcdd53bb75f2">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In ImageMagick 7.0.8-11 Q16, a tiny input file 0x50 0x36 0x36 0x36 0x36 0x4c 0x36 0x38 0x36 0x36 0x36 0x36 0x36 0x36 0x1f 0x35 0x50 0x00 can result in a hang of several minutes during which CPU and memory resources are consumed until ultimately an attempted large memory allocation fails. Remote attackers could leverage this vulnerability to cause a denial of service via a crafted file.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('3e2449332ab9ba3b893b3227c4222c53dbaceb68')">
                                    <div class="issue-number">331</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="3e2449332ab9ba3b893b3227c4222c53dbaceb68">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A flaw was found in ImageMagick in versions before 7.0.11, where a division by zero in sRGBTransformImage() in the MagickCore/colorspace.c may trigger undefined behavior via a crafted image file that is submitted by an attacker processed by an application using ImageMagick. The highest threat from this vulnerability is to system availability.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('84edbc88d0d838a4667879386a06e7df3127546a')">
                                    <div class="issue-number">332</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="84edbc88d0d838a4667879386a06e7df3127546a">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A vulnerability was found in ImageMagick. This security flaw cause a remote code execution vulnerability in OpenBlob with --enable-pipes configured.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('e137a376328ebbe117d0643d3e49dce896483068')">
                                    <div class="issue-number">333</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="e137a376328ebbe117d0643d3e49dce896483068">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A design flaw in image processing software that modifies JPEG images might not modify the original EXIF thumbnail, which could lead to an information leak of potentially sensitive visual information that had been removed from the main JPEG image.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('1f7f9e58968c517efd3012d3550fc61d31d48886')">
                                    <div class="issue-number">334</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="1f7f9e58968c517efd3012d3550fc61d31d48886">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Multiple unspecified vulnerabilities in GraphicsMagick before 1.2.4 allow remote attackers to cause a denial of service (crash, infinite loop, or memory consumption) via (a) unspecified vectors in the (1) AVI, (2) AVS, (3) DCM, (4) EPT, (5) FITS, (6) MTV, (7) PALM, (8) RLA, and (9) TGA decoder readers; and (b) the GetImageCharacteristics function in magick/image.c, as reachable from a crafted (10) PNG, (11) JPEG, (12) BMP, or (13) TIFF file.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('d018ebcc4c46d043ff85649cd696da2de65f4760')">
                                    <div class="issue-number">335</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="d018ebcc4c46d043ff85649cd696da2de65f4760">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The IsPixelMonochrome function in MagickCore/pixel-accessor.h in ImageMagick 7.0.3.0 allows remote attackers to cause a denial of service (out-of-bounds read and crash) via a crafted file.  NOTE: the vendor says "This is a Q64 issue and we do not support Q64."</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('31e5e0f689030eb90c4570ff629f5b336820913c')">
                                    <div class="issue-number">336</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="31e5e0f689030eb90c4570ff629f5b336820913c">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The WritePICONImage function in coders/xpm.c in ImageMagick 7.0.6-4 allows remote attackers to cause a denial of service (memory leak) via a crafted file that is mishandled in an OpenPixelCache call.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('8a6719e0c68d74f3fc82c91957442878953a292d')">
                                    <div class="issue-number">337</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="8a6719e0c68d74f3fc82c91957442878953a292d">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The WritePICONImage function in coders/xpm.c in ImageMagick 7.0.6-4 allows remote attackers to cause a denial of service (memory leak) via a crafted file that is mishandled in an AcquireSemaphoreInfo call.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('ad7c927546911ef9abe01251de334d411aafb7eb')">
                                    <div class="issue-number">338</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="ad7c927546911ef9abe01251de334d411aafb7eb">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The ReadPCXImage function in coders/pcx.c in ImageMagick 7.0.4.9 allows remote attackers to cause a denial of service (attempted large memory allocation and application crash) via a crafted file. NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-8862 and CVE-2016-8866.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('00858a9c2207af9d6fb97f2ad2c6000d15a22661')">
                                    <div class="issue-number">339</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="00858a9c2207af9d6fb97f2ad2c6000d15a22661">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In ImageMagick 7.0.8-11 Q16, a tiny input file 0x50 0x36 0x36 0x36 0x36 0x4c 0x36 0x38 0x36 0x36 0x36 0x36 0x36 0x36 0x1f 0x35 0x50 0x00 can result in a hang of several minutes during which CPU and memory resources are consumed until ultimately an attempted large memory allocation fails. Remote attackers could leverage this vulnerability to cause a denial of service via a crafted file.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('7ced162415a783c9c3d0e2019c77dbd0e2d0392c')">
                                    <div class="issue-number">340</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="7ced162415a783c9c3d0e2019c77dbd0e2d0392c">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A flaw was found in ImageMagick in versions before 7.0.11, where a division by zero in sRGBTransformImage() in the MagickCore/colorspace.c may trigger undefined behavior via a crafted image file that is submitted by an attacker processed by an application using ImageMagick. The highest threat from this vulnerability is to system availability.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('295ee560fc93a2ed508fb89b35112449b0da755f')">
                                    <div class="issue-number">341</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="295ee560fc93a2ed508fb89b35112449b0da755f">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A vulnerability was found in ImageMagick. This security flaw cause a remote code execution vulnerability in OpenBlob with --enable-pipes configured.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('c824e57ce74c0606963cfcc7207573545df0776c')">
                                    <div class="issue-number">342</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="c824e57ce74c0606963cfcc7207573545df0776c">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an "INPUTRC" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('09b176fc492cf2b46faba947344dd2229d8dd909')">
                                    <div class="issue-number">343</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="09b176fc492cf2b46faba947344dd2229d8dd909">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an "INPUTRC" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('e2847dbfe05da1a3b4794c017595c31d09ca17c8')">
                                    <div class="issue-number">344</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="e2847dbfe05da1a3b4794c017595c31d09ca17c8">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Header::readfrom in IlmImf/ImfHeader.cpp in OpenEXR 2.2.0 allows remote attackers to cause a denial of service (excessive memory allocation) via a crafted file that is accessed with the ImfOpenInputFile function in IlmImf/ImfCRgbaFile.cpp. NOTE: The maintainer and multiple third parties believe that this vulnerability isn't valid</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('02be185901acda944c282cec5f5656c226f9d293')">
                                    <div class="issue-number">345</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="02be185901acda944c282cec5f5656c226f9d293">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Header::readfrom in IlmImf/ImfHeader.cpp in OpenEXR 2.2.0 allows remote attackers to cause a denial of service (excessive memory allocation) via a crafted file that is accessed with the ImfOpenInputFile function in IlmImf/ImfCRgbaFile.cpp. NOTE: The maintainer and multiple third parties believe that this vulnerability isn't valid</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('7684a3db345f723b8d5a0d397f14d2368ebae3bd')">
                                    <div class="issue-number">346</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="7684a3db345f723b8d5a0d397f14d2368ebae3bd">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> NULL pointer dereference vulnerabilities in the imagetopnm function in convert.c, sycc444_to_rgb function in color.c, color_esycc_to_rgb function in color.c, and sycc422_to_rgb function in color.c in OpenJPEG before 2.2.0 allow remote attackers to cause a denial of service (application crash) via crafted j2k files.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('bdfa814dad001f6f0e90cd7644b76447e0d1f896')">
                                    <div class="issue-number">347</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="bdfa814dad001f6f0e90cd7644b76447e0d1f896">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Division-by-zero vulnerabilities in the functions opj_pi_next_cprl, opj_pi_next_pcrl, and opj_pi_next_rpcl in pi.c in OpenJPEG before 2.2.0 allow remote attackers to cause a denial of service (application crash) via crafted j2k files.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('cbeac7fecea6337da48cc5b0d1965a827b79eb05')">
                                    <div class="issue-number">348</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="cbeac7fecea6337da48cc5b0d1965a827b79eb05">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> There is a NULL pointer dereference in function imagetobmp of convertbmp.c:980 of OpenJPEG 2.1.2. image->comps[0].data is not assigned a value after initialization(NULL). Impact is Denial of Service.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('54c57ce39669f47e372e8f0a01beaf76eaad381b')">
                                    <div class="issue-number">349</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="54c57ce39669f47e372e8f0a01beaf76eaad381b">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> There is a NULL Pointer Access in function imagetopnm of convert.c:1943(jp2) of OpenJPEG 2.1.2. image->comps[compno].data is not assigned a value after initialization(NULL). Impact is Denial of Service.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('7a479794b548dbdb5ee7d9c1cef4a5f266592082')">
                                    <div class="issue-number">350</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="7a479794b548dbdb5ee7d9c1cef4a5f266592082">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Heap Buffer Over-read in function imagetotga of convert.c(jp2):942 in OpenJPEG 2.1.2. Impact is Denial of Service. Someone must open a crafted j2k file.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('74adb9f06000cd55c7c910d806571afc600a8ba6')">
                                    <div class="issue-number">351</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="74adb9f06000cd55c7c910d806571afc600a8ba6">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> NULL Pointer Access in function imagetopnm of convert.c:2226(jp2) in OpenJPEG 2.1.2. Impact is Denial of Service. Someone must open a crafted j2k file.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('a8017eed91b57b04a58935f933cf23f063b9c3fc')">
                                    <div class="issue-number">352</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="a8017eed91b57b04a58935f933cf23f063b9c3fc">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> NULL Pointer Access in function imagetopnm of convert.c(jp2):1289 in OpenJPEG 2.1.2. Impact is Denial of Service. Someone must open a crafted j2k file.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('b8265694b5018b7471d38e45738667cb065b7399')">
                                    <div class="issue-number">353</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="b8265694b5018b7471d38e45738667cb065b7399">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An integer overflow vulnerability was found in tiftoimage function in openjpeg 2.1.2, resulting in heap buffer overflow.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('cabc39bb7ce90425121fdf5e15dc4737c4ffddc5')">
                                    <div class="issue-number">354</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="cabc39bb7ce90425121fdf5e15dc4737c4ffddc5">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An infinite loop vulnerability in tiftoimage that results in heap buffer overflow in convert_32s_C1P1 was found in openjpeg 2.1.2.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('69734708512aae81c942700ec1689e027e0dcf50')">
                                    <div class="issue-number">355</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="69734708512aae81c942700ec1689e027e0dcf50">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In OpenJPEG 2.3.0, a stack-based buffer overflow was discovered in the pgxtoimage function in jpwl/convert.c. The vulnerability causes an out-of-bounds write, which may lead to remote denial of service or possibly remote code execution.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('cf1e2d4271f5c9c077d90de5e5d6e17dbbcdc8cb')">
                                    <div class="issue-number">356</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="cf1e2d4271f5c9c077d90de5e5d6e17dbbcdc8cb">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in OpenJPEG 2.3.0. Missing checks for header_info.height and header_info.width in the function pnmtoimage in bin/jpwl/convert.c can lead to a heap-based buffer overflow.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('76b637fee0b2caa17b83512e581b1da3c124d06a')">
                                    <div class="issue-number">357</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="76b637fee0b2caa17b83512e581b1da3c124d06a">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in OpenJPEG 2.3.0. A heap-based buffer overflow was discovered in the function t2_encode_packet in lib/openmj2/t2.c. The vulnerability causes an out-of-bounds write, which may lead to remote denial of service or possibly unspecified other impact.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('e22f4898922460faab4b7bf22d3bcec0124e5864')">
                                    <div class="issue-number">358</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="e22f4898922460faab4b7bf22d3bcec0124e5864">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Out-of-bounds accesses in the functions pi_next_lrcp, pi_next_rlcp, pi_next_rpcl, pi_next_pcrl, pi_next_rpcl, and pi_next_cprl in openmj2/pi.c in OpenJPEG through 2.3.0 allow remote attackers to cause a denial of service (application crash).</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('b92ec0f7f04038ab55707d1d540c781748b0ae41')">
                                    <div class="issue-number">359</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="b92ec0f7f04038ab55707d1d540c781748b0ae41">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in OpenJPEG 2.3.0. It allows remote attackers to cause a denial of service (attempted excessive memory allocation) in opj_calloc in openjp2/opj_malloc.c, when called from opj_tcd_init_tile in openjp2/tcd.c, as demonstrated by the 64-bit opj_decompress.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('6c2616b7445ee778510c74c0d3b4479c71e7b840')">
                                    <div class="issue-number">360</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="6c2616b7445ee778510c74c0d3b4479c71e7b840">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> NULL pointer dereference vulnerabilities in the imagetopnm function in convert.c, sycc444_to_rgb function in color.c, color_esycc_to_rgb function in color.c, and sycc422_to_rgb function in color.c in OpenJPEG before 2.2.0 allow remote attackers to cause a denial of service (application crash) via crafted j2k files.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('6bc288027b46bcf1ab02f435553ec6c31f9ffd24')">
                                    <div class="issue-number">361</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="6bc288027b46bcf1ab02f435553ec6c31f9ffd24">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Division-by-zero vulnerabilities in the functions opj_pi_next_cprl, opj_pi_next_pcrl, and opj_pi_next_rpcl in pi.c in OpenJPEG before 2.2.0 allow remote attackers to cause a denial of service (application crash) via crafted j2k files.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('7f41979ddc9f299336bbbd7ad250c5d7cc398f15')">
                                    <div class="issue-number">362</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="7f41979ddc9f299336bbbd7ad250c5d7cc398f15">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> There is a NULL pointer dereference in function imagetobmp of convertbmp.c:980 of OpenJPEG 2.1.2. image->comps[0].data is not assigned a value after initialization(NULL). Impact is Denial of Service.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('33a5d6d88c45c535579e925b71cd49cea4367b85')">
                                    <div class="issue-number">363</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="33a5d6d88c45c535579e925b71cd49cea4367b85">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> There is a NULL Pointer Access in function imagetopnm of convert.c:1943(jp2) of OpenJPEG 2.1.2. image->comps[compno].data is not assigned a value after initialization(NULL). Impact is Denial of Service.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('d15c8cfc03eafcc4e0c831ee19475746548a8199')">
                                    <div class="issue-number">364</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="d15c8cfc03eafcc4e0c831ee19475746548a8199">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Heap Buffer Over-read in function imagetotga of convert.c(jp2):942 in OpenJPEG 2.1.2. Impact is Denial of Service. Someone must open a crafted j2k file.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('9ea265c14be37224d362b63c1b30df28f5c70c30')">
                                    <div class="issue-number">365</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="9ea265c14be37224d362b63c1b30df28f5c70c30">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> NULL Pointer Access in function imagetopnm of convert.c:2226(jp2) in OpenJPEG 2.1.2. Impact is Denial of Service. Someone must open a crafted j2k file.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('36ac55c8ba08b251c123abf215a56ec528bdab5a')">
                                    <div class="issue-number">366</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="36ac55c8ba08b251c123abf215a56ec528bdab5a">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> NULL Pointer Access in function imagetopnm of convert.c(jp2):1289 in OpenJPEG 2.1.2. Impact is Denial of Service. Someone must open a crafted j2k file.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('e16bb075bbbcaeeab5f9ff1d56e3374b65004692')">
                                    <div class="issue-number">367</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="e16bb075bbbcaeeab5f9ff1d56e3374b65004692">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An integer overflow vulnerability was found in tiftoimage function in openjpeg 2.1.2, resulting in heap buffer overflow.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('eba6fbdd7afacdd4abbd61fa8b446291966fd43c')">
                                    <div class="issue-number">368</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="eba6fbdd7afacdd4abbd61fa8b446291966fd43c">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An infinite loop vulnerability in tiftoimage that results in heap buffer overflow in convert_32s_C1P1 was found in openjpeg 2.1.2.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('1e5b4e43e766516e694dc455349c1aec3dc5582e')">
                                    <div class="issue-number">369</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="1e5b4e43e766516e694dc455349c1aec3dc5582e">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In OpenJPEG 2.3.0, a stack-based buffer overflow was discovered in the pgxtoimage function in jpwl/convert.c. The vulnerability causes an out-of-bounds write, which may lead to remote denial of service or possibly remote code execution.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('6fb61e9bce53004324ca2b7d19eb1d28f4df4159')">
                                    <div class="issue-number">370</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="6fb61e9bce53004324ca2b7d19eb1d28f4df4159">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in OpenJPEG 2.3.0. Missing checks for header_info.height and header_info.width in the function pnmtoimage in bin/jpwl/convert.c can lead to a heap-based buffer overflow.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('ba969155d66b51e22c34e7bce617c61c73c1c46b')">
                                    <div class="issue-number">371</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="ba969155d66b51e22c34e7bce617c61c73c1c46b">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in OpenJPEG 2.3.0. A heap-based buffer overflow was discovered in the function t2_encode_packet in lib/openmj2/t2.c. The vulnerability causes an out-of-bounds write, which may lead to remote denial of service or possibly unspecified other impact.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('3a2c17fb357e1f23141b264b22056c0152b09ddd')">
                                    <div class="issue-number">372</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="3a2c17fb357e1f23141b264b22056c0152b09ddd">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Out-of-bounds accesses in the functions pi_next_lrcp, pi_next_rlcp, pi_next_rpcl, pi_next_pcrl, pi_next_rpcl, and pi_next_cprl in openmj2/pi.c in OpenJPEG through 2.3.0 allow remote attackers to cause a denial of service (application crash).</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('34199e5ab59b5bbd9ef5335ac6a361b940a4d36a')">
                                    <div class="issue-number">373</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="34199e5ab59b5bbd9ef5335ac6a361b940a4d36a">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in OpenJPEG 2.3.0. It allows remote attackers to cause a denial of service (attempted excessive memory allocation) in opj_calloc in openjp2/opj_malloc.c, when called from opj_tcd_init_tile in openjp2/tcd.c, as demonstrated by the 64-bit opj_decompress.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('8e30417cdfc0917f18870bc4b920ac06d38fe5f3')">
                                    <div class="issue-number">374</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="8e30417cdfc0917f18870bc4b920ac06d38fe5f3">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> _is_safe in the File::Temp module for Perl does not properly handle symlinks.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('7d78e0e0a047ca87e53201d1f6f924c5b8b5b7d1')">
                                    <div class="issue-number">375</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="7d78e0e0a047ca87e53201d1f6f924c5b8b5b7d1">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> HTTP::Tiny before 0.083, a Perl core module since 5.13.9 and available standalone on CPAN, has an insecure default TLS configuration where users must opt in to verify certificates.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('1af884e12810dfcb0d0653d56c441f61c687d488')">
                                    <div class="issue-number">376</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="1af884e12810dfcb0d0653d56c441f61c687d488">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> stress-test master commit e4c878 was discovered to contain a FPE vulnerability via the component combine_inner at /pixman-combine-float.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('2a6b0e96f8ee499eb74a45d256ec1b8abd11fb11')">
                                    <div class="issue-number">377</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="2a6b0e96f8ee499eb74a45d256ec1b8abd11fb11">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> stress-test master commit e4c878 was discovered to contain a FPE vulnerability via the component combine_inner at /pixman-combine-float.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('b03b7fc39a07176b34eafd99afe13cc80514749d')">
                                    <div class="issue-number">378</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="b03b7fc39a07176b34eafd99afe13cc80514749d">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A heap overflow flaw was found in libpngs' pngimage.c program. This flaw allows an attacker with local network access to pass a specially crafted PNG file to the pngimage utility, causing an application to crash, leading to a denial of service.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('2c5a38df0eef7a0709532806f63f8de493f1028d')">
                                    <div class="issue-number">379</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="2c5a38df0eef7a0709532806f63f8de493f1028d">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A heap overflow flaw was found in libpngs' pngimage.c program. This flaw allows an attacker with local network access to pass a specially crafted PNG file to the pngimage utility, causing an application to crash, leading to a denial of service.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('6f93e82723dde2f3034f84d64505a34f4de919fa')">
                                    <div class="issue-number">380</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="6f93e82723dde2f3034f84d64505a34f4de919fa">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Under some circumstances, this weakness allows a user who has access to run the “ps” utility on a machine, the ability to write almost unlimited amounts of unfiltered data into the process heap.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('64d6a0e1a937405a080c7d70587938679cc24984')">
                                    <div class="issue-number">381</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="64d6a0e1a937405a080c7d70587938679cc24984">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The urllib.parse.urlsplit() and urlparse() functions improperly validated bracketed hosts (`[]`), allowing hosts that weren't IPv6 or IPvFuture. This behavior was not conformant to RFC 3986 and potentially enabled SSRF if a URL is processed by more than one URL parser.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('f14c2ce77629cf8bc0c8a5a0bad48cfc7d95d525')">
                                    <div class="issue-number">382</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="f14c2ce77629cf8bc0c8a5a0bad48cfc7d95d525">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The urllib.parse.urlsplit() and urlparse() functions improperly validated bracketed hosts (`[]`), allowing hosts that weren't IPv6 or IPvFuture. This behavior was not conformant to RFC 3986 and potentially enabled SSRF if a URL is processed by more than one URL parser.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('dc4ff8f11b6a86c44f604ee1000f8e5894e1139a')">
                                    <div class="issue-number">383</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="dc4ff8f11b6a86c44f604ee1000f8e5894e1139a">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The urllib.parse.urlsplit() and urlparse() functions improperly validated bracketed hosts (`[]`), allowing hosts that weren't IPv6 or IPvFuture. This behavior was not conformant to RFC 3986 and potentially enabled SSRF if a URL is processed by more than one URL parser.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('c81dc83d837e272cdea78dc1373c5c4884f71879')">
                                    <div class="issue-number">384</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="c81dc83d837e272cdea78dc1373c5c4884f71879">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> libiberty/rust-demangle.c in GNU GCC 11.2 allows stack consumption in demangle_const, as demonstrated by nm-new.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('07ba109c59e17aee46797da01f92427022eb930c')">
                                    <div class="issue-number">385</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="07ba109c59e17aee46797da01f92427022eb930c">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> 

**DISPUTED**A failure in the -fstack-protector feature in GCC-based toolchains 
that target AArch64 allows an attacker to exploit an existing buffer 
overflow in dynamically-sized local variables in your application 
without this being detected. This stack-protector failure only applies 
to C99-style dynamically-sized local variables or those created using 
alloca(). The stack-protector operates as intended for statically-sized 
local variables.

The default behavior when the stack-protector 
detects an overflow is to terminate your application, resulting in 
controlled loss of availability. An attacker who can exploit a buffer 
overflow without triggering the stack-protector might be able to change 
program flow control to cause an uncontrolled loss of availability or to
 go further and affect confidentiality or integrity. NOTE: The GCC project argues that this is a missed hardening bug and not a vulnerability by itself.





</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('ba52ddfa9ae8574dde6d0d3511fec1822c755729')">
                                    <div class="issue-number">386</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="ba52ddfa9ae8574dde6d0d3511fec1822c755729">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an "INPUTRC" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('56266048709ad68b2c42046126c9f07f85a7ecaa')">
                                    <div class="issue-number">387</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="56266048709ad68b2c42046126c9f07f85a7ecaa">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A Memory Leak vulnerability exists in SQLite Project SQLite3 3.35.1 and 3.37.0 via maliciously crafted SQL Queries (made via editing the Database File), it is possible to query a record, and leak subsequent bytes of memory that extend beyond the record, which could let a malicious user obtain sensitive information. NOTE: The developer disputes this as a vulnerability stating that If you give SQLite a corrupted database file and submit a query against the database, it might read parts of the database that you did not intend or expect.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('a78718213fe366bfbb2fc1f93c6d4404fd289753')">
                                    <div class="issue-number">388</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="a78718213fe366bfbb2fc1f93c6d4404fd289753">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A Memory Leak vulnerability exists in SQLite Project SQLite3 3.35.1 and 3.37.0 via maliciously crafted SQL Queries (made via editing the Database File), it is possible to query a record, and leak subsequent bytes of memory that extend beyond the record, which could let a malicious user obtain sensitive information. NOTE: The developer disputes this as a vulnerability stating that If you give SQLite a corrupted database file and submit a query against the database, it might read parts of the database that you did not intend or expect.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('862f3dc62e40f87b543b61f4b2df7ff6aa8069a6')">
                                    <div class="issue-number">389</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="862f3dc62e40f87b543b61f4b2df7ff6aa8069a6">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> libiberty/rust-demangle.c in GNU GCC 11.2 allows stack consumption in demangle_const, as demonstrated by nm-new.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('1e93398a0f0d81d850c13d271d41e75a2c7363f4')">
                                    <div class="issue-number">390</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="1e93398a0f0d81d850c13d271d41e75a2c7363f4">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> 

**DISPUTED**A failure in the -fstack-protector feature in GCC-based toolchains 
that target AArch64 allows an attacker to exploit an existing buffer 
overflow in dynamically-sized local variables in your application 
without this being detected. This stack-protector failure only applies 
to C99-style dynamically-sized local variables or those created using 
alloca(). The stack-protector operates as intended for statically-sized 
local variables.

The default behavior when the stack-protector 
detects an overflow is to terminate your application, resulting in 
controlled loss of availability. An attacker who can exploit a buffer 
overflow without triggering the stack-protector might be able to change 
program flow control to cause an uncontrolled loss of availability or to
 go further and affect confidentiality or integrity. NOTE: The GCC project argues that this is a missed hardening bug and not a vulnerability by itself.





</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('0d302072f2396d3c19c7c8ded1b258432e1f8af7')">
                                    <div class="issue-number">391</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="0d302072f2396d3c19c7c8ded1b258432e1f8af7">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> libiberty/rust-demangle.c in GNU GCC 11.2 allows stack consumption in demangle_const, as demonstrated by nm-new.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('41184483d614ca74aea6c2f36be7c70142087ddd')">
                                    <div class="issue-number">392</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="41184483d614ca74aea6c2f36be7c70142087ddd">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> 

**DISPUTED**A failure in the -fstack-protector feature in GCC-based toolchains 
that target AArch64 allows an attacker to exploit an existing buffer 
overflow in dynamically-sized local variables in your application 
without this being detected. This stack-protector failure only applies 
to C99-style dynamically-sized local variables or those created using 
alloca(). The stack-protector operates as intended for statically-sized 
local variables.

The default behavior when the stack-protector 
detects an overflow is to terminate your application, resulting in 
controlled loss of availability. An attacker who can exploit a buffer 
overflow without triggering the stack-protector might be able to change 
program flow control to cause an uncontrolled loss of availability or to
 go further and affect confidentiality or integrity. NOTE: The GCC project argues that this is a missed hardening bug and not a vulnerability by itself.





</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('eba465aad53e393ccd4a36af5b0e0ba11737c8f4')">
                                    <div class="issue-number">393</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="eba465aad53e393ccd4a36af5b0e0ba11737c8f4">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> systemd, when updating file permissions, allows local users to change the permissions and SELinux security contexts for arbitrary files via a symlink attack on unspecified files.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('e538021525cd94d88c82b9d1d2eef92937604508')">
                                    <div class="issue-number">394</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="e538021525cd94d88c82b9d1d2eef92937604508">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in systemd 253. An attacker can modify a sealed log file such that, in some views, not all existing and sealed log messages are displayed. NOTE: the vendor reportedly sent "a reply denying that any of the finding was a security vulnerability."</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('01d707841cb3104e43ec50a79d84e5cd14a407cd')">
                                    <div class="issue-number">395</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="01d707841cb3104e43ec50a79d84e5cd14a407cd">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in systemd 253. An attacker can truncate a sealed log file and then resume log sealing such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent "a reply denying that any of the finding was a security vulnerability."</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('131c40fc7888f7c22865baa2a627deee32811fd0')">
                                    <div class="issue-number">396</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="131c40fc7888f7c22865baa2a627deee32811fd0">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in systemd 253. An attacker can modify the contents of past events in a sealed log file and then adjust the file such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent "a reply denying that any of the finding was a security vulnerability."</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('45cc59eb6b2de86dc08843e29f8aac040c784de0')">
                                    <div class="issue-number">397</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="45cc59eb6b2de86dc08843e29f8aac040c784de0">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In Tcl 8.6.11, a format string vulnerability in nmakehlp.c might allow code execution via a crafted file. NOTE: multiple third parties dispute the significance of this finding</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('a83ca29c42072c428b47c728f605afd5cab679eb')">
                                    <div class="issue-number">398</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="a83ca29c42072c428b47c728f605afd5cab679eb">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> LibTIFF 4.0.8 has multiple memory leak vulnerabilities, which allow attackers to cause a denial of service (memory consumption), as demonstrated by tif_open.c, tif_lzw.c, and tif_aux.c. NOTE: Third parties were unable to reproduce the issue</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('36a8508ab2a0cbc4df50021e0baa76936f988628')">
                                    <div class="issue-number">399</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="36a8508ab2a0cbc4df50021e0baa76936f988628">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In LibTIFF 4.0.8, there is a heap-based use-after-free in the t2p_writeproc function in tiff2pdf.c. NOTE: there is a third-party report of inability to reproduce this issue</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('947c35c687174522e2a4f9779b4c886ef425ae0c')">
                                    <div class="issue-number">400</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="947c35c687174522e2a4f9779b4c886ef425ae0c">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> LibTIFF version 4.0.7 is vulnerable to a heap-based buffer over-read in tif_lzw.c resulting in DoS or code execution via a crafted bmp image to tools/bmp2tiff.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('215b6f6086679c1837facda029527e02ae0c6289')">
                                    <div class="issue-number">401</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="215b6f6086679c1837facda029527e02ae0c6289">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In LibTIFF 4.0.7, the program processes BMP images without verifying that biWidth and biHeight in the bitmap-information header match the actual input, leading to a heap-based buffer over-read in bmp2tiff.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('0877fd8d683260eb94dde35d7ff34e500a95a912')">
                                    <div class="issue-number">402</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="0877fd8d683260eb94dde35d7ff34e500a95a912">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> ijg-libjpeg before 9d, as used in tiff2pdf (from LibTIFF) and other products, does not check for a NULL pointer at a certain place in jpeg_fdct_16x16 in jfdctint.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('20ee396d7481e3f2420e7ee4a171b36320c67a20')">
                                    <div class="issue-number">403</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="20ee396d7481e3f2420e7ee4a171b36320c67a20">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A vulnerability classified as problematic was found in LibTIFF 4.3.0. Affected by this vulnerability is the TIFF File Handler of tiff2ps. Opening a malicious file leads to a denial of service. The attack can be launched remotely but requires user interaction. The exploit has been disclosed to the public and may be used.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('9bc79f5060efc3f7cbdb6b0ecfb5c6e163975903')">
                                    <div class="issue-number">404</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="9bc79f5060efc3f7cbdb6b0ecfb5c6e163975903">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A flaw was found in tiffcrop, a program distributed by the libtiff package. A specially crafted tiff file can lead to an out-of-bounds read in the extractImageSection function in tools/tiffcrop.c, resulting in a denial of service and limited information disclosure. This issue affects libtiff versions 4.x.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('0371e35611a29b03a6fbb038e53f9e655db5650c')">
                                    <div class="issue-number">405</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="0371e35611a29b03a6fbb038e53f9e655db5650c">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A heap-buffer-overflow vulnerability was found in LibTIFF, in extractImageSection() at tools/tiffcrop.c:7916 and tools/tiffcrop.c:7801. This flaw allows attackers to cause a denial of service via a crafted tiff file.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('61c206eb17b92984d65561508aa47c0fbaeb4362')">
                                    <div class="issue-number">406</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="61c206eb17b92984d65561508aa47c0fbaeb4362">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was found in the tiffcp utility distributed by the libtiff package where a crafted TIFF file on processing may cause a heap-based buffer overflow leads to an application crash.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('9201709aad2382354c812811add1d7c647a62df4')">
                                    <div class="issue-number">407</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="9201709aad2382354c812811add1d7c647a62df4">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> LibTIFF 4.0.8 has multiple memory leak vulnerabilities, which allow attackers to cause a denial of service (memory consumption), as demonstrated by tif_open.c, tif_lzw.c, and tif_aux.c. NOTE: Third parties were unable to reproduce the issue</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('50f8db687e8e2d535ebeced954b828db08b13ae8')">
                                    <div class="issue-number">408</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="50f8db687e8e2d535ebeced954b828db08b13ae8">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In LibTIFF 4.0.8, there is a heap-based use-after-free in the t2p_writeproc function in tiff2pdf.c. NOTE: there is a third-party report of inability to reproduce this issue</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('44646da1f3b6acf54ce3d492bc5112f4dfee9aa0')">
                                    <div class="issue-number">409</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="44646da1f3b6acf54ce3d492bc5112f4dfee9aa0">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> LibTIFF version 4.0.7 is vulnerable to a heap-based buffer over-read in tif_lzw.c resulting in DoS or code execution via a crafted bmp image to tools/bmp2tiff.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('bf4f3a833a10a4b9a463f3f1d29cc0cd07bf2e23')">
                                    <div class="issue-number">410</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="bf4f3a833a10a4b9a463f3f1d29cc0cd07bf2e23">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In LibTIFF 4.0.7, the program processes BMP images without verifying that biWidth and biHeight in the bitmap-information header match the actual input, leading to a heap-based buffer over-read in bmp2tiff.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('d4583f3fb52c7d3030879fa4269b5e4691d3b688')">
                                    <div class="issue-number">411</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="d4583f3fb52c7d3030879fa4269b5e4691d3b688">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> ijg-libjpeg before 9d, as used in tiff2pdf (from LibTIFF) and other products, does not check for a NULL pointer at a certain place in jpeg_fdct_16x16 in jfdctint.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('cf0a9198b04b8bb78dea947b3483e4a44456e74c')">
                                    <div class="issue-number">412</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="cf0a9198b04b8bb78dea947b3483e4a44456e74c">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A vulnerability classified as problematic was found in LibTIFF 4.3.0. Affected by this vulnerability is the TIFF File Handler of tiff2ps. Opening a malicious file leads to a denial of service. The attack can be launched remotely but requires user interaction. The exploit has been disclosed to the public and may be used.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('79f77f6298fdae5b84f8458c932e34688294a6e0')">
                                    <div class="issue-number">413</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="79f77f6298fdae5b84f8458c932e34688294a6e0">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A flaw was found in tiffcrop, a program distributed by the libtiff package. A specially crafted tiff file can lead to an out-of-bounds read in the extractImageSection function in tools/tiffcrop.c, resulting in a denial of service and limited information disclosure. This issue affects libtiff versions 4.x.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('cf93495df980ba5280631a697dce67c5958d7f92')">
                                    <div class="issue-number">414</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="cf93495df980ba5280631a697dce67c5958d7f92">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A heap-buffer-overflow vulnerability was found in LibTIFF, in extractImageSection() at tools/tiffcrop.c:7916 and tools/tiffcrop.c:7801. This flaw allows attackers to cause a denial of service via a crafted tiff file.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('8bab79d6caa0f4cd08a3a2044a610e50807207d3')">
                                    <div class="issue-number">415</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="8bab79d6caa0f4cd08a3a2044a610e50807207d3">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was found in the tiffcp utility distributed by the libtiff package where a crafted TIFF file on processing may cause a heap-based buffer overflow leads to an application crash.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('d32903d8553a7ec8487ad9c440e5af4c0e37a9c4')">
                                    <div class="issue-number">416</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="d32903d8553a7ec8487ad9c440e5af4c0e37a9c4">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> LibTIFF 4.0.8 has multiple memory leak vulnerabilities, which allow attackers to cause a denial of service (memory consumption), as demonstrated by tif_open.c, tif_lzw.c, and tif_aux.c. NOTE: Third parties were unable to reproduce the issue</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('9b273e31f0c46155fc1c554f61aff11fce3b06f2')">
                                    <div class="issue-number">417</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="9b273e31f0c46155fc1c554f61aff11fce3b06f2">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In LibTIFF 4.0.8, there is a heap-based use-after-free in the t2p_writeproc function in tiff2pdf.c. NOTE: there is a third-party report of inability to reproduce this issue</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('61113da5bfa355bb630fe0eb042914a8e49b82a1')">
                                    <div class="issue-number">418</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="61113da5bfa355bb630fe0eb042914a8e49b82a1">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> LibTIFF version 4.0.7 is vulnerable to a heap-based buffer over-read in tif_lzw.c resulting in DoS or code execution via a crafted bmp image to tools/bmp2tiff.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('dfaa40465f4b6be05b2ba312f27499fe89bee501')">
                                    <div class="issue-number">419</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="dfaa40465f4b6be05b2ba312f27499fe89bee501">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In LibTIFF 4.0.7, the program processes BMP images without verifying that biWidth and biHeight in the bitmap-information header match the actual input, leading to a heap-based buffer over-read in bmp2tiff.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('f6a4e3e55983c411decd7709fbd9a3611f4fb7a8')">
                                    <div class="issue-number">420</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="f6a4e3e55983c411decd7709fbd9a3611f4fb7a8">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> ijg-libjpeg before 9d, as used in tiff2pdf (from LibTIFF) and other products, does not check for a NULL pointer at a certain place in jpeg_fdct_16x16 in jfdctint.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('38d19af2367de38904b0dfcd2d21f25ffffd6980')">
                                    <div class="issue-number">421</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="38d19af2367de38904b0dfcd2d21f25ffffd6980">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A vulnerability classified as problematic was found in LibTIFF 4.3.0. Affected by this vulnerability is the TIFF File Handler of tiff2ps. Opening a malicious file leads to a denial of service. The attack can be launched remotely but requires user interaction. The exploit has been disclosed to the public and may be used.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('198eec60f588b75af8ee20139d4e96047f5022e4')">
                                    <div class="issue-number">422</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="198eec60f588b75af8ee20139d4e96047f5022e4">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A flaw was found in tiffcrop, a program distributed by the libtiff package. A specially crafted tiff file can lead to an out-of-bounds read in the extractImageSection function in tools/tiffcrop.c, resulting in a denial of service and limited information disclosure. This issue affects libtiff versions 4.x.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('75a3a6dd842b40bef34a5c26e99510640d8e26b7')">
                                    <div class="issue-number">423</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="75a3a6dd842b40bef34a5c26e99510640d8e26b7">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A heap-buffer-overflow vulnerability was found in LibTIFF, in extractImageSection() at tools/tiffcrop.c:7916 and tools/tiffcrop.c:7801. This flaw allows attackers to cause a denial of service via a crafted tiff file.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('a6a14f232605bd7b1cd7548d1a4bab13c3efc109')">
                                    <div class="issue-number">424</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="a6a14f232605bd7b1cd7548d1a4bab13c3efc109">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was found in the tiffcp utility distributed by the libtiff package where a crafted TIFF file on processing may cause a heap-based buffer overflow leads to an application crash.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('d74090e6b3896006c3fc97797c95d6b71db39862')">
                                    <div class="issue-number">425</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="d74090e6b3896006c3fc97797c95d6b71db39862">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> libiberty/rust-demangle.c in GNU GCC 11.2 allows stack consumption in demangle_const, as demonstrated by nm-new.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('3f7c4823f7bbdec68e2a17ccee13c63846d0b330')">
                                    <div class="issue-number">426</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="3f7c4823f7bbdec68e2a17ccee13c63846d0b330">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> 

**DISPUTED**A failure in the -fstack-protector feature in GCC-based toolchains 
that target AArch64 allows an attacker to exploit an existing buffer 
overflow in dynamically-sized local variables in your application 
without this being detected. This stack-protector failure only applies 
to C99-style dynamically-sized local variables or those created using 
alloca(). The stack-protector operates as intended for statically-sized 
local variables.

The default behavior when the stack-protector 
detects an overflow is to terminate your application, resulting in 
controlled loss of availability. An attacker who can exploit a buffer 
overflow without triggering the stack-protector might be able to change 
program flow control to cause an uncontrolled loss of availability or to
 go further and affect confidentiality or integrity. NOTE: The GCC project argues that this is a missed hardening bug and not a vulnerability by itself.





</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('187a081d849f392b52cf9b5a1b48af1fa9aa0400')">
                                    <div class="issue-number">427</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="187a081d849f392b52cf9b5a1b48af1fa9aa0400">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> libiberty/rust-demangle.c in GNU GCC 11.2 allows stack consumption in demangle_const, as demonstrated by nm-new.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('2a7bbfa7b5ddca1883d3b99225ba624e9f51db5f')">
                                    <div class="issue-number">428</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="2a7bbfa7b5ddca1883d3b99225ba624e9f51db5f">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> 

**DISPUTED**A failure in the -fstack-protector feature in GCC-based toolchains 
that target AArch64 allows an attacker to exploit an existing buffer 
overflow in dynamically-sized local variables in your application 
without this being detected. This stack-protector failure only applies 
to C99-style dynamically-sized local variables or those created using 
alloca(). The stack-protector operates as intended for statically-sized 
local variables.

The default behavior when the stack-protector 
detects an overflow is to terminate your application, resulting in 
controlled loss of availability. An attacker who can exploit a buffer 
overflow without triggering the stack-protector might be able to change 
program flow control to cause an uncontrolled loss of availability or to
 go further and affect confidentiality or integrity. NOTE: The GCC project argues that this is a missed hardening bug and not a vulnerability by itself.





</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('27a5759645c27fb0b09b792dd4aa652cfe1c0305')">
                                    <div class="issue-number">429</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="27a5759645c27fb0b09b792dd4aa652cfe1c0305">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> systemd, when updating file permissions, allows local users to change the permissions and SELinux security contexts for arbitrary files via a symlink attack on unspecified files.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('e5036ecf5d1963d7ef0ecc68852bc779318a959b')">
                                    <div class="issue-number">430</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="e5036ecf5d1963d7ef0ecc68852bc779318a959b">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in systemd 253. An attacker can modify a sealed log file such that, in some views, not all existing and sealed log messages are displayed. NOTE: the vendor reportedly sent "a reply denying that any of the finding was a security vulnerability."</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('00a6ad8f1f749a3ef8cf8521115d2c7e1c0677c7')">
                                    <div class="issue-number">431</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="00a6ad8f1f749a3ef8cf8521115d2c7e1c0677c7">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in systemd 253. An attacker can truncate a sealed log file and then resume log sealing such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent "a reply denying that any of the finding was a security vulnerability."</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('df935b6d72717eb211ebb06e28f2a212d86389cd')">
                                    <div class="issue-number">432</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="df935b6d72717eb211ebb06e28f2a212d86389cd">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in systemd 253. An attacker can modify the contents of past events in a sealed log file and then adjust the file such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent "a reply denying that any of the finding was a security vulnerability."</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('7e1d3f7ac47d78a57f35f7891b57a3c57e009ff0')">
                                    <div class="issue-number">433</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="7e1d3f7ac47d78a57f35f7891b57a3c57e009ff0">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an "INPUTRC" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('9f82121e98b2118e4e9de71d21698bb50a7a07ce')">
                                    <div class="issue-number">434</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="9f82121e98b2118e4e9de71d21698bb50a7a07ce">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Array index error in gd_gif_in.c in the GD Graphics Library (libgd) before 2.0.35 allows user-assisted remote attackers to cause a denial of service (crash and heap corruption) via large color index values in crafted image data, which results in a segmentation fault.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('261c4b4ecb80a3951e818e824b57a0b8b41717b3')">
                                    <div class="issue-number">435</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="261c4b4ecb80a3951e818e824b57a0b8b41717b3">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The (a) imagearc and (b) imagefilledarc functions in GD Graphics Library (libgd) before 2.0.35 allow attackers to cause a denial of service (CPU consumption) via a large (1) start or (2) end angle degree value.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('eb60dff0121782514ae662661e2c52ab21df7ca9')">
                                    <div class="issue-number">436</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="eb60dff0121782514ae662661e2c52ab21df7ca9">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Multiple integer overflows in libgd in PHP before 5.2.4 allow remote attackers to cause a denial of service (application crash) and possibly execute arbitrary code via a large (1) srcW or (2) srcH value to the (a) gdImageCopyResized function, or a large (3) sy (height) or (4) sx (width) value to the (b) gdImageCreate or the (c) gdImageCreateTrueColor function.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('1f7a70ebc6496e1d132a097585e85622192a6a4f')">
                                    <div class="issue-number">437</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="1f7a70ebc6496e1d132a097585e85622192a6a4f">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The _gdGetColors function in gd_gd.c in PHP 5.2.11 and 5.3.x before 5.3.1, and the GD Graphics Library 2.x, does not properly verify a certain colorsTotal structure member, which might allow remote attackers to conduct buffer overflow or buffer over-read attacks via a crafted GD file, a different vulnerability than CVE-2009-3293. NOTE: some of these details are obtained from third party information.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('4b882b9149f1f7bc2d32301f7d15e14b99a488de')">
                                    <div class="issue-number">438</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="4b882b9149f1f7bc2d32301f7d15e14b99a488de">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> TEMP-0601525-BEBB65</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('bc005a5c6cc2db2b1956abeb4295c33a12b95c7e')">
                                    <div class="issue-number">439</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="bc005a5c6cc2db2b1956abeb4295c33a12b95c7e">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Array index error in gd_gif_in.c in the GD Graphics Library (libgd) before 2.0.35 allows user-assisted remote attackers to cause a denial of service (crash and heap corruption) via large color index values in crafted image data, which results in a segmentation fault.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('5145a7c9b9fa48ae00ba677287ec9a583801857d')">
                                    <div class="issue-number">440</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="5145a7c9b9fa48ae00ba677287ec9a583801857d">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The (a) imagearc and (b) imagefilledarc functions in GD Graphics Library (libgd) before 2.0.35 allow attackers to cause a denial of service (CPU consumption) via a large (1) start or (2) end angle degree value.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('85bed2ef87239ec011ed71667f255f7bf3d60d5e')">
                                    <div class="issue-number">441</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="85bed2ef87239ec011ed71667f255f7bf3d60d5e">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Multiple integer overflows in libgd in PHP before 5.2.4 allow remote attackers to cause a denial of service (application crash) and possibly execute arbitrary code via a large (1) srcW or (2) srcH value to the (a) gdImageCopyResized function, or a large (3) sy (height) or (4) sx (width) value to the (b) gdImageCreate or the (c) gdImageCreateTrueColor function.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('b95647bec0fabbfc196ce2913427366aa6c59b68')">
                                    <div class="issue-number">442</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="b95647bec0fabbfc196ce2913427366aa6c59b68">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The _gdGetColors function in gd_gd.c in PHP 5.2.11 and 5.3.x before 5.3.1, and the GD Graphics Library 2.x, does not properly verify a certain colorsTotal structure member, which might allow remote attackers to conduct buffer overflow or buffer over-read attacks via a crafted GD file, a different vulnerability than CVE-2009-3293. NOTE: some of these details are obtained from third party information.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('2d3fbfa7fa324245b7ec3f85bad1b9401c6a4ef6')">
                                    <div class="issue-number">443</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="2d3fbfa7fa324245b7ec3f85bad1b9401c6a4ef6">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> TEMP-0601525-BEBB65</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('b1b03776c11f63e2666786974833aa98feb9bda1')">
                                    <div class="issue-number">444</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="b1b03776c11f63e2666786974833aa98feb9bda1">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Array index error in gd_gif_in.c in the GD Graphics Library (libgd) before 2.0.35 allows user-assisted remote attackers to cause a denial of service (crash and heap corruption) via large color index values in crafted image data, which results in a segmentation fault.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('b00fd8b43a031674392c5f9f2424d8c7c6494ebc')">
                                    <div class="issue-number">445</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="b00fd8b43a031674392c5f9f2424d8c7c6494ebc">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The (a) imagearc and (b) imagefilledarc functions in GD Graphics Library (libgd) before 2.0.35 allow attackers to cause a denial of service (CPU consumption) via a large (1) start or (2) end angle degree value.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('46f41ab178024df0c9c8a4a8291d0f1e94997e24')">
                                    <div class="issue-number">446</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="46f41ab178024df0c9c8a4a8291d0f1e94997e24">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Multiple integer overflows in libgd in PHP before 5.2.4 allow remote attackers to cause a denial of service (application crash) and possibly execute arbitrary code via a large (1) srcW or (2) srcH value to the (a) gdImageCopyResized function, or a large (3) sy (height) or (4) sx (width) value to the (b) gdImageCreate or the (c) gdImageCreateTrueColor function.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('2c2eb9fd06b0cc760549ce7c6ccc845569a9416f')">
                                    <div class="issue-number">447</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="2c2eb9fd06b0cc760549ce7c6ccc845569a9416f">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The _gdGetColors function in gd_gd.c in PHP 5.2.11 and 5.3.x before 5.3.1, and the GD Graphics Library 2.x, does not properly verify a certain colorsTotal structure member, which might allow remote attackers to conduct buffer overflow or buffer over-read attacks via a crafted GD file, a different vulnerability than CVE-2009-3293. NOTE: some of these details are obtained from third party information.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('8d88b4b22a8f830c094f7521968630f4abc28bb3')">
                                    <div class="issue-number">448</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="8d88b4b22a8f830c094f7521968630f4abc28bb3">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> TEMP-0601525-BEBB65</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('0507cba42d4893d6ca531f29ab66cdf7b67b4017')">
                                    <div class="issue-number">449</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="0507cba42d4893d6ca531f29ab66cdf7b67b4017">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in xmllint (from libxml2) before 2.11.8 and 2.12.x before 2.12.7. Formatting error messages with xmllint --htmlout can result in a buffer over-read in xmlHTMLPrintFileContext in xmllint.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('2058aa094160491f11d92f8fda997560b6f6d71e')">
                                    <div class="issue-number">450</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="2058aa094160491f11d92f8fda997560b6f6d71e">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in xmllint (from libxml2) before 2.11.8 and 2.12.x before 2.12.7. Formatting error messages with xmllint --htmlout can result in a buffer over-read in xmlHTMLPrintFileContext in xmllint.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('0023d141f0110c4eb930c52fac40a15065e7959c')">
                                    <div class="issue-number">451</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="0023d141f0110c4eb930c52fac40a15065e7959c">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In libxslt 1.1.29 and earlier, the EXSLT math.random function was not initialized with a random seed during startup, which could cause usage of this function to produce predictable outputs.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('cd26bae2fb3071630cd29cc5f4a01203cba59745')">
                                    <div class="issue-number">452</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="cd26bae2fb3071630cd29cc5f4a01203cba59745">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In libxslt 1.1.29 and earlier, the EXSLT math.random function was not initialized with a random seed during startup, which could cause usage of this function to produce predictable outputs.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('2a9742da311e5295d12e65fb095759ec6d1d11f1')">
                                    <div class="issue-number">453</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="2a9742da311e5295d12e65fb095759ec6d1d11f1">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> TCP, when using a large Window Size, makes it easier for remote attackers to guess sequence numbers and cause a denial of service (connection loss) to persistent TCP connections by repeatedly injecting a TCP RST packet, especially in protocols that use long-lived connections, such as BGP.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('a76bb5a20df717aac633d28bbce7be3e3628ca0b')">
                                    <div class="issue-number">454</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="a76bb5a20df717aac633d28bbce7be3e3628ca0b">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Linux kernel 2.4 and 2.6 allows attackers to cause a denial of service (memory exhaustion and panic) by creating a large number of connected file descriptors or socketpairs and setting a large data transfer buffer, then preventing Linux from being able to finish the transfer by causing the process to become a zombie, or closing the file descriptor without closing an associated reference.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('4c5e47f0323b828279e30a5720875d3b584a0db0')">
                                    <div class="issue-number">455</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="4c5e47f0323b828279e30a5720875d3b584a0db0">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The process scheduler in the Linux kernel 2.6.16 gives preference to "interactive" processes that perform voluntary sleeps, which allows local users to cause a denial of service (CPU consumption), as described in "Secretly Monopolizing the CPU Without Superuser Privileges."</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('aeb05188ce4464efe7c268ce87d3d240428176b7')">
                                    <div class="issue-number">456</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="aeb05188ce4464efe7c268ce87d3d240428176b7">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Mounting /proc filesystem via chroot command silently mounts it in read-write mode. The user could bypass the chroot environment and gain write access to files, he would never have otherwise.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('105625e3a6d61405d9e7002ac0ef871d57d50a92')">
                                    <div class="issue-number">457</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="105625e3a6d61405d9e7002ac0ef871d57d50a92">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The TCP implementation in (1) Linux, (2) platforms based on BSD Unix, (3) Microsoft Windows, (4) Cisco products, and probably other operating systems allows remote attackers to cause a denial of service (connection queue exhaustion) via multiple vectors that manipulate information in the TCP state table, as demonstrated by sockstress.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('c4e02add708175d9d12ed7d739723b81841bd128')">
                                    <div class="issue-number">458</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="c4e02add708175d9d12ed7d739723b81841bd128">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The Linux kernel, when using IPv6, allows remote attackers to determine whether a host is sniffing the network by sending an ICMPv6 Echo Request to a multicast address and determining whether an Echo Reply is sent, as demonstrated by thcping.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('cb90b51caf458192d17a27ac11c8a5d9cfbd6029')">
                                    <div class="issue-number">459</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="cb90b51caf458192d17a27ac11c8a5d9cfbd6029">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Memory leak in drivers/media/video/videobuf-core.c in the videobuf subsystem in the Linux kernel 2.6.x through 4.x allows local users to cause a denial of service (memory consumption) by leveraging /dev/video access for a series of mmap calls that require new allocations, a different vulnerability than CVE-2007-6761.  NOTE: as of 2016-06-18, this affects only 11 drivers that have not been updated to use videobuf2 instead of videobuf.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('f20bf87c7b00f7e3bf88f466b527f7b74f68b201')">
                                    <div class="issue-number">460</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="f20bf87c7b00f7e3bf88f466b527f7b74f68b201">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> fs/proc/base.c in the Linux kernel through 3.1 allows local users to obtain sensitive keystroke information via access to /proc/interrupts.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('1cc24ac163a56a6ecd522787a4f0f3a437b608e9')">
                                    <div class="issue-number">461</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="1cc24ac163a56a6ecd522787a4f0f3a437b608e9">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Linux kernel through 3.1 allows local users to obtain sensitive keystroke information via access to /dev/pts/ and /dev/tty*.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('1773f191887ce33fbd23ba13887e2f99c8fab4d3')">
                                    <div class="issue-number">462</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="1773f191887ce33fbd23ba13887e2f99c8fab4d3">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel through 3.1 there is an information disclosure issue via /proc/stat.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('d5be120ceaed63558720f3399741e4eda8017182')">
                                    <div class="issue-number">463</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="d5be120ceaed63558720f3399741e4eda8017182">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> block/scsi_ioctl.c in the Linux kernel through 3.8 does not properly consider the SCSI device class during authorization of SCSI commands, which allows local users to bypass intended access restrictions via an SG_IO ioctl call that leverages overlapping opcodes.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('7b0f38131da4156e58c65bd1c6039c03488a7478')">
                                    <div class="issue-number">464</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="7b0f38131da4156e58c65bd1c6039c03488a7478">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The snd_compr_tstamp function in sound/core/compress_offload.c in the Linux kernel through 4.7, as used in Android before 2016-08-05 on Nexus 5 and 7 (2013) devices, does not properly initialize a timestamp data structure, which allows attackers to obtain sensitive information via a crafted application, aka Android internal bug 28770164 and Qualcomm internal bug CR568717.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('c3874dd5ff27120d1634652a953a41f63a8f40eb')">
                                    <div class="issue-number">465</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="c3874dd5ff27120d1634652a953a41f63a8f40eb">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The ethtool_get_wol function in net/core/ethtool.c in the Linux kernel through 4.7, as used in Android before 2016-08-05 on Nexus 5 and 7 (2013) devices, does not initialize a certain data structure, which allows local users to obtain sensitive information via a crafted application, aka Android internal bug 28803952 and Qualcomm internal bug CR570754.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('aea5b3a8f6dc296ea54839d09096eb56aa356090')">
                                    <div class="issue-number">466</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="aea5b3a8f6dc296ea54839d09096eb56aa356090">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Kernel Samepage Merging (KSM) in the Linux kernel 2.6.32 through 4.x does not prevent use of a write-timing side channel, which allows guest OS users to defeat the ASLR protection mechanism on other guest OS instances via a Cross-VM ASL INtrospection (CAIN) attack.  NOTE: the vendor states "Basically if you care about this attack vector, disable deduplication." Share-until-written approaches for memory conservation among mutually untrusting tenants are inherently detectable for information disclosure, and can be classified as potentially misunderstood behaviors rather than vulnerabilities</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('9c1f37c5ee780ff5092f1843118ac2f17d8b2a4d')">
                                    <div class="issue-number">467</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="9c1f37c5ee780ff5092f1843118ac2f17d8b2a4d">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in the Linux kernel through 4.17.2. Since the page allocator does not yield CPU resources to the owner of the oom_lock mutex, a local unprivileged user can trivially lock up the system forever by wasting CPU resources from the page allocator (e.g., via concurrent page fault events) when the global OOM killer is invoked. NOTE: the software maintainer has not accepted certain proposed patches, in part because of a viewpoint that "the underlying problem is non-trivial to handle.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('234d040ac653a45789d501ffba51c756efb925fe')">
                                    <div class="issue-number">468</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="234d040ac653a45789d501ffba51c756efb925fe">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The XFS subsystem in the Linux kernel through 4.8.2 allows local users to cause a denial of service (fdatasync failure and system hang) by using the vfs syscall group in the trinity program, related to a "page lock order bug in the XFS seek hole/data implementation."</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('91c03e494014436b52493d53b6e731ce96de919b')">
                                    <div class="issue-number">469</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="91c03e494014436b52493d53b6e731ce96de919b">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An information disclosure vulnerability in the kernel trace subsystem could enable a local malicious application to access data outside of its permission levels. This issue is rated as Moderate because it first requires compromising a privileged process. Product: Android. Versions: Kernel-3.10, Kernel-3.18. Android ID: A-34277115.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('e25f4cb786cd0df4686413b167ecc4a5d604c143')">
                                    <div class="issue-number">470</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="e25f4cb786cd0df4686413b167ecc4a5d604c143">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The acpi_ds_create_operands() function in drivers/acpi/acpica/dsutils.c in the Linux kernel through 4.12.9 does not flush the operand cache and causes a kernel stack dump, which allows local users to obtain sensitive information from kernel memory and bypass the KASLR protection mechanism (in the kernel through 4.9) via a crafted ACPI table.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('873e1c9ffddd55d5fb27b1930b84f3bc3291a088')">
                                    <div class="issue-number">471</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="873e1c9ffddd55d5fb27b1930b84f3bc3291a088">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The acpi_ps_complete_final_op() function in drivers/acpi/acpica/psobject.c in the Linux kernel through 4.12.9 does not flush the node and node_ext caches and causes a kernel stack dump, which allows local users to obtain sensitive information from kernel memory and bypass the KASLR protection mechanism (in the kernel through 4.9) via a crafted ACPI table.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('f469c4e0cde2fe7cc34fe764af3625bfa3583fb0')">
                                    <div class="issue-number">472</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="f469c4e0cde2fe7cc34fe764af3625bfa3583fb0">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> procps-ng, procps is vulnerable to a process hiding through race condition. Since the kernel's proc_pid_readdir() returns PID entries in ascending numeric order, a process occupying a high PID can use inotify events to determine when the process list is being scanned, and fork/exec to obtain a lower PID, thus avoiding enumeration. An unprivileged attacker can hide a process from procps-ng's utilities by exploiting a race condition in reading /proc/PID entries. This vulnerability affects procps and procps-ng up to version 3.3.15, newer versions might be affected also.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('478e57a78e3ed056fbc7dd03dc4eee426827be43')">
                                    <div class="issue-number">473</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="478e57a78e3ed056fbc7dd03dc4eee426827be43">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel 4.15.0, a NULL pointer dereference was discovered in hfs_ext_read_extent in hfs.ko. This can occur during a mount of a crafted hfs filesystem.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('d89f10857d29900fb4b739cfe8444b7135701277')">
                                    <div class="issue-number">474</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="d89f10857d29900fb4b739cfe8444b7135701277">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The Linux kernel 4.14.67 mishandles certain interaction among XFRM Netlink messages, IPPROTO_AH packets, and IPPROTO_IP packets, which allows local users to cause a denial of service (memory consumption and system hang) by leveraging root access to execute crafted applications, as demonstrated on CentOS 7.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('7869b9734e003f598207afdc2f48889f8c18351f')">
                                    <div class="issue-number">475</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="7869b9734e003f598207afdc2f48889f8c18351f">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The Linux kernel through 5.0.7, when CONFIG_IA32_AOUT is enabled and ia32_aout is loaded, allows local users to bypass ASLR on setuid a.out programs (if any exist) because install_exec_creds() is called too late in load_aout_binary() in fs/binfmt_aout.c, and thus the ptrace_may_access() check has a race condition when reading /proc/pid/stat. NOTE: the software maintainer disputes that this is a vulnerability because ASLR for a.out format executables has never been supported</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('cee5df03facc1c7c6fd9ba323db16e5152a677e4')">
                                    <div class="issue-number">476</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="cee5df03facc1c7c6fd9ba323db16e5152a677e4">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in ip6_ra_control in net/ipv6/ipv6_sockglue.c in the Linux kernel through 5.1.5. There is an unchecked kmalloc of new_ra, which might allow an attacker to cause a denial of service (NULL pointer dereference and system crash). NOTE: This has been disputed as not an issue</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('c82b39e0b90fd91345585fa62ef7e1b4bcd4e3fd')">
                                    <div class="issue-number">477</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="c82b39e0b90fd91345585fa62ef7e1b4bcd4e3fd">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in con_insert_unipair in drivers/tty/vt/consolemap.c in the Linux kernel through 5.1.5. There is a memory leak in a certain case of an ENOMEM outcome of kmalloc. NOTE: This id is disputed as not being an issue</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('6dc39c330443f7181a070be00c8a8cc2891ecd8b')">
                                    <div class="issue-number">478</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="6dc39c330443f7181a070be00c8a8cc2891ecd8b">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> **DISPUTED** An issue was discovered in the efi subsystem in the Linux kernel through 5.1.5. phys_efi_set_virtual_address_map in arch/x86/platform/efi/efi.c and efi_call_phys_prolog in arch/x86/platform/efi/efi_64.c mishandle memory allocation failures. NOTE: This id is disputed as not being an issue because “All the code touched by the referenced commit runs only at boot, before any user processes are started. Therefore, there is no possibility for an unprivileged user to control it.”.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('62f188c24ae42862d92a8027b4aecabc3435d2ae')">
                                    <div class="issue-number">479</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="62f188c24ae42862d92a8027b4aecabc3435d2ae">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in ip_ra_control in net/ipv4/ip_sockglue.c in the Linux kernel through 5.1.5. There is an unchecked kmalloc of new_ra, which might allow an attacker to cause a denial of service (NULL pointer dereference and system crash). NOTE: this is disputed because new_ra is never used if it is NULL</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('f2a0b60a8793b3291e7aae39e0f7be949073097e')">
                                    <div class="issue-number">480</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="f2a0b60a8793b3291e7aae39e0f7be949073097e">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in drm_load_edid_firmware in drivers/gpu/drm/drm_edid_load.c in the Linux kernel through 5.1.5. There is an unchecked kstrdup of fwstr, which might allow an attacker to cause a denial of service (NULL pointer dereference and system crash). NOTE: The vendor disputes this issues as not being a vulnerability because kstrdup() returning NULL is handled sufficiently and there is no chance for a NULL pointer dereference</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('a952bc7e9485ea58277ddd6383eb2e530b3cce14')">
                                    <div class="issue-number">481</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="a952bc7e9485ea58277ddd6383eb2e530b3cce14">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in sunxi_divs_clk_setup in drivers/clk/sunxi/clk-sunxi.c in the Linux kernel through 5.1.5. There is an unchecked kstrndup of derived_name, which might allow an attacker to cause a denial of service (NULL pointer dereference and system crash). NOTE: This id is disputed as not being an issue because “The memory allocation that was not checked is part of a code that only runs at boot time, before user processes are started. Therefore, there is no possibility for an unprivileged user to control it, and no denial of service.”</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('d4dbb422877b173141a0c83904526d31080e9cde')">
                                    <div class="issue-number">482</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="d4dbb422877b173141a0c83904526d31080e9cde">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in the MPT3COMMAND case in _ctl_ioctl_main in drivers/scsi/mpt3sas/mpt3sas_ctl.c in the Linux kernel through 5.1.5. It allows local users to cause a denial of service or possibly have unspecified other impact by changing the value of ioc_number between two kernel reads of that value, aka a "double fetch" vulnerability. NOTE: a third party reports that this is unexploitable because the doubly fetched value is not used</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('472f32846e0864373b48fc536f5ec2852c535df5')">
                                    <div class="issue-number">483</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="472f32846e0864373b48fc536f5ec2852c535df5">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> drivers/gpu/drm/amd/amdkfd/kfd_interrupt.c in the Linux kernel 5.2.14 does not check the alloc_workqueue return value, leading to a NULL pointer dereference. NOTE: The security community disputes this issues as not being serious enough to be deserving a CVE id</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('d825be6f9a61cb9aae86c7e86ce56895e7f83709')">
                                    <div class="issue-number">484</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="d825be6f9a61cb9aae86c7e86ce56895e7f83709">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> drivers/gpu/drm/radeon/radeon_display.c in the Linux kernel 5.2.14 does not check the alloc_workqueue return value, leading to a NULL pointer dereference. NOTE: A third-party software maintainer states that the work queue allocation is happening during device initialization, which for a graphics card occurs during boot. It is not attacker controllable and OOM at that time is highly unlikely</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('d6dfaeb5f5344714fc43723a10b16ec7903b6d40')">
                                    <div class="issue-number">485</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="d6dfaeb5f5344714fc43723a10b16ec7903b6d40">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> drivers/net/fjes/fjes_main.c in the Linux kernel 5.2.14 does not check the alloc_workqueue return value, leading to a NULL pointer dereference.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('7776c25ad7e60ff33df371e5a1f894f3e9e2a423')">
                                    <div class="issue-number">486</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="7776c25ad7e60ff33df371e5a1f894f3e9e2a423">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> drivers/net/wireless/marvell/libertas/if_sdio.c in the Linux kernel 5.2.14 does not check the alloc_workqueue return value, leading to a NULL pointer dereference.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('58e0c10aab02bd8f37d02a3290589d87ebecd938')">
                                    <div class="issue-number">487</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="58e0c10aab02bd8f37d02a3290589d87ebecd938">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> drivers/scsi/qla2xxx/qla_os.c in the Linux kernel 5.2.14 does not check the alloc_workqueue return value, leading to a NULL pointer dereference.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('c1c2617aa339252ef787d9e22d6492a246fd5bd7')">
                                    <div class="issue-number">488</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="c1c2617aa339252ef787d9e22d6492a246fd5bd7">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> drivers/net/wireless/intel/iwlwifi/pcie/trans.c in the Linux kernel 5.2.14 does not check the alloc_workqueue return value, leading to a NULL pointer dereference.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('5125028be88d6ac5b1fa3813ab26e67f1f741019')">
                                    <div class="issue-number">489</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="5125028be88d6ac5b1fa3813ab26e67f1f741019">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A memory leak in the spi_gpio_probe() function in drivers/spi/spi-gpio.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering devm_add_action_or_reset() failures, aka CID-d3b0ffa1d75d. NOTE: third parties dispute the relevance of this because the system must have already been out of memory before the probe began</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('0cc5d0d7b257dbd5f1c4687947e853b06db7bc19')">
                                    <div class="issue-number">490</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="0cc5d0d7b257dbd5f1c4687947e853b06db7bc19">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel 5.0.21, mounting a crafted btrfs filesystem image can lead to slab-out-of-bounds write access in index_rbio_pages in fs/btrfs/raid56.c.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('43fde272621cf94774ae0425cdf68b1f5d3bcb9a')">
                                    <div class="issue-number">491</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="43fde272621cf94774ae0425cdf68b1f5d3bcb9a">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> snd_ctl_elem_add in sound/core/control.c in the Linux kernel through 5.6.3 has a count=info->owner line, which later affects a private_size*count multiplication for unspecified "interesting side effects." NOTE: kernel engineers dispute this finding, because it could be relevant only if new callers were added that were unfamiliar with the misuse of the info->owner field to represent data unrelated to the "owner" concept. The existing callers, SNDRV_CTL_IOCTL_ELEM_ADD and SNDRV_CTL_IOCTL_ELEM_REPLACE, have been designed to misuse the info->owner field in a safe way</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('e40048525eaf23bff15de2589ad866ccb695da01')">
                                    <div class="issue-number">492</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="e40048525eaf23bff15de2589ad866ccb695da01">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A flaw was found in the Linux kernels implementation of audit rules, where a syscall can unexpectedly not be correctly not be logged by the audit subsystem</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('24bcec22732bc3b8ece6829329bf1c422a4270d5')">
                                    <div class="issue-number">493</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="24bcec22732bc3b8ece6829329bf1c422a4270d5">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in the Linux kernel 4.18 through 5.10.16, as used by Xen. The backend allocation (aka be-alloc) mode of the drm_xen_front drivers was not meant to be a supported configuration, but this wasn't stated accordingly in its support status entry.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('e1f6e7c523fb6d5319e7b6bdb61ffb6fe42460f7')">
                                    <div class="issue-number">494</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="e1f6e7c523fb6d5319e7b6bdb61ffb6fe42460f7">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A flaw was found in the Linux kernels memory deduplication mechanism. Previous work has shown that memory deduplication can be attacked via a local exploitation mechanism. The same technique can be used if an attacker can upload page sized files and detect the change in access time from a networked service to determine if the page has been merged.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('368fd2bb4249a3728bf8048ef58d85f9bf59012d')">
                                    <div class="issue-number">495</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="368fd2bb4249a3728bf8048ef58d85f9bf59012d">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An out-of-bounds read vulnerability was discovered in linux kernel in the smc protocol stack, causing remote dos.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('f3233b74bd3a917135b1bfdc35ce4510c839e6fa')">
                                    <div class="issue-number">496</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="f3233b74bd3a917135b1bfdc35ce4510c839e6fa">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue found in linux-kernel that leads to a race condition in rose_connect(). The rose driver uses rose_neigh->use to represent how many objects are using the rose_neigh. When a user wants to delete a rose_route via rose_ioctl(), the rose driver calls rose_del_node() and removes neighbours only if their “count” and “use” are zero.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('9c10f497c57d722ff2589a67e0b4bb08b46cb020')">
                                    <div class="issue-number">497</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="9c10f497c57d722ff2589a67e0b4bb08b46cb020">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel through 5.16.10, certain binary files may have the exec-all attribute if they were built in approximately 2003 (e.g., with GCC 3.2.2 and Linux kernel 2.4.20). This can cause execution of bytes located in supposedly non-executable regions of a file.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('775b6ba0eace2a400e9bf902dd9ad8aff31d5f8b')">
                                    <div class="issue-number">498</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="775b6ba0eace2a400e9bf902dd9ad8aff31d5f8b">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A use-after-free flaw was found in the Linux kernel’s PLP Rose functionality in the way a user triggers a race condition by calling bind while simultaneously triggering the rose_bind() function. This flaw allows a local user to crash or potentially escalate their privileges on the system.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('24e7045111d9d640074309c94fa6c5d8f2258223')">
                                    <div class="issue-number">499</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="24e7045111d9d640074309c94fa6c5d8f2258223">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A double-free flaw was found in the Linux kernel’s NTFS3 subsystem in how a user triggers remount and umount simultaneously. This flaw allows a local user to crash or potentially escalate their privileges on the system.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('759a8711ce245c887491968613182388d16ce0e4')">
                                    <div class="issue-number">500</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="759a8711ce245c887491968613182388d16ce0e4">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> drivers/char/pcmcia/synclink_cs.c in the Linux kernel through 5.19.12 has a race condition and resultant use-after-free if a physically proximate attacker removes a PCMCIA device while calling ioctl, aka a race condition between mgslpc_ioctl and mgslpc_detach.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('971e05cd314686a33f60d7fc92591df440572970')">
                                    <div class="issue-number">501</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="971e05cd314686a33f60d7fc92591df440572970">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in the Linux kernel through 6.0.6. drivers/char/pcmcia/cm4000_cs.c has a race condition and resultant use-after-free if a physically proximate attacker removes a PCMCIA device while calling open(), aka a race condition between cmm_open() and cm4000_detach().</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('86717f07fa18d703f50697c39c5fa14f03c24b92')">
                                    <div class="issue-number">502</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="86717f07fa18d703f50697c39c5fa14f03c24b92">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in the Linux kernel through 6.0.6. drivers/char/pcmcia/cm4040_cs.c has a race condition and resultant use-after-free if a physically proximate attacker removes a PCMCIA device while calling open(), aka a race condition between cm4040_open() and reader_detach().</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('bb7baf462aca17a52007ad01c97c41836a3c1668')">
                                    <div class="issue-number">503</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="bb7baf462aca17a52007ad01c97c41836a3c1668">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in the Linux kernel through 6.0.6. drivers/char/pcmcia/scr24x_cs.c has a race condition and resultant use-after-free if a physically proximate attacker removes a PCMCIA device while calling open(), aka a race condition between scr24x_open() and scr24x_remove().</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('185b79512d3b43b1e0995e5104471beb99c120bb')">
                                    <div class="issue-number">504</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="185b79512d3b43b1e0995e5104471beb99c120bb">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in the Linux kernel through 6.0.9. drivers/media/dvb-core/dvbdev.c has a use-after-free, related to dvb_register_device dynamically allocating fops.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('3731aa082899a0bb9cf79985856e2f20504f0835')">
                                    <div class="issue-number">505</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="3731aa082899a0bb9cf79985856e2f20504f0835">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in the Linux kernel through 6.0.9. drivers/media/dvb-core/dvb_frontend.c has a race condition that can cause a use-after-free when a device is disconnected.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('ab46d5b001f83ab5110fabf1542b99d4032aeda8')">
                                    <div class="issue-number">506</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="ab46d5b001f83ab5110fabf1542b99d4032aeda8">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in the Linux kernel through 6.2.0-rc2. drivers/tty/vcc.c has a race condition and resultant use-after-free if a physically proximate attacker removes a VCC device while calling open(), aka a race condition between vcc_open() and vcc_remove().</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('044a37b8b8f7000cb8703f45c8d550532bd9d9aa')">
                                    <div class="issue-number">507</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="044a37b8b8f7000cb8703f45c8d550532bd9d9aa">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> afu_mmio_region_get_by_offset in drivers/fpga/dfl-afu-region.c in the Linux kernel through 6.1.12 has an integer overflow.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('644c6cbbd7bc4b0183d54fd92473bf7012c611a2')">
                                    <div class="issue-number">508</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="644c6cbbd7bc4b0183d54fd92473bf7012c611a2">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in drivers/media/test-drivers/vidtv/vidtv_bridge.c in the Linux kernel 6.2. There is a NULL pointer dereference in vidtv_mux_stop_thread. In vidtv_stop_streaming, after dvb->mux=NULL occurs, it executes vidtv_mux_stop_thread(dvb->mux).</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('d60bc4e1b3790bf3ea278f292be9efa3afe61c17')">
                                    <div class="issue-number">509</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="d60bc4e1b3790bf3ea278f292be9efa3afe61c17">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in drivers/mtd/ubi/cdev.c in the Linux kernel 6.2. There is a divide-by-zero error in do_div(sz,mtd->erasesize), used indirectly by ctrl_cdev_ioctl, when mtd->erasesize is 0.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('3dc76acf2bcda7949964fd5aa0531d743d72d9b8')">
                                    <div class="issue-number">510</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="3dc76acf2bcda7949964fd5aa0531d743d72d9b8">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A possible unauthorized memory access flaw was found in the Linux kernel's cpu_entry_area mapping of X86 CPU data to memory, where a user may guess the location of exception stacks or other important data. Based on the previous CVE-2023-0597, the 'Randomize per-cpu entry area' feature was implemented in /arch/x86/mm/cpu_entry_area.c, which works through the init_cea_offsets() function when KASLR is enabled. However, despite this feature, there is still a risk of per-cpu entry area leaks. This issue could allow a local user to gain access to some important data with memory in an expected location and potentially escalate their privileges on the system.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('ef4b861293fed2fb240d462e9f0c9c949127eb71')">
                                    <div class="issue-number">511</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="ef4b861293fed2fb240d462e9f0c9c949127eb71">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An improper input validation flaw was found in the eBPF subsystem in the Linux kernel. The issue occurs due to a lack of proper validation of dynamic pointers within user-supplied eBPF programs prior to executing them. This may allow an attacker with CAP_BPF privileges to escalate privileges and execute arbitrary code in the context of the kernel.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('eedbcdbd2515f78f901d94fb60ff017cf1a7ffb0')">
                                    <div class="issue-number">512</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="eedbcdbd2515f78f901d94fb60ff017cf1a7ffb0">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A use-after-free vulnerability was found in the cyttsp4_core driver in the Linux kernel. This issue occurs in the device cleanup routine due to a possible rearming of the watchdog_timer from the workqueue. This could allow a local user to crash the system, causing a denial of service.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('8e571efb649d466cab8df3213f81e3219e710166')">
                                    <div class="issue-number">513</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="8e571efb649d466cab8df3213f81e3219e710166">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

parisc: Try to fix random segmentation faults in package builds

PA-RISC systems with PA8800 and PA8900 processors have had problems
with random segmentation faults for many years.  Systems with earlier
processors are much more stable.

Systems with PA8800 and PA8900 processors have a large L2 cache which
needs per page flushing for decent performance when a large range is
flushed. The combined cache in these systems is also more sensitive to
non-equivalent aliases than the caches in earlier systems.

The majority of random segmentation faults that I have looked at
appear to be memory corruption in memory allocated using mmap and
malloc.

My first attempt at fixing the random faults didn't work. On
reviewing the cache code, I realized that there were two issues
which the existing code didn't handle correctly. Both relate
to cache move-in. Another issue is that the present bit in PTEs
is racy.

1) PA-RISC caches have a mind of their own and they can speculatively
load data and instructions for a page as long as there is a entry in
the TLB for the page which allows move-in. TLBs are local to each
CPU. Thus, the TLB entry for a page must be purged before flushing
the page. This is particularly important on SMP systems.

In some of the flush routines, the flush routine would be called
and then the TLB entry would be purged. This was because the flush
routine needed the TLB entry to do the flush.

2) My initial approach to trying the fix the random faults was to
try and use flush_cache_page_if_present for all flush operations.
This actually made things worse and led to a couple of hardware
lockups. It finally dawned on me that some lines weren't being
flushed because the pte check code was racy. This resulted in
random inequivalent mappings to physical pages.

The __flush_cache_page tmpalias flush sets up its own TLB entry
and it doesn't need the existing TLB entry. As long as we can find
the pte pointer for the vm page, we can get the pfn and physical
address of the page. We can also purge the TLB entry for the page
before doing the flush. Further, __flush_cache_page uses a special
TLB entry that inhibits cache move-in.

When switching page mappings, we need to ensure that lines are
removed from the cache.  It is not sufficient to just flush the
lines to memory as they may come back.

This made it clear that we needed to implement all the required
flush operations using tmpalias routines. This includes flushes
for user and kernel pages.

After modifying the code to use tmpalias flushes, it became clear
that the random segmentation faults were not fully resolved. The
frequency of faults was worse on systems with a 64 MB L2 (PA8900)
and systems with more CPUs (rp4440).

The warning that I added to flush_cache_page_if_present to detect
pages that couldn't be flushed triggered frequently on some systems.

Helge and I looked at the pages that couldn't be flushed and found
that the PTE was either cleared or for a swap page. Ignoring pages
that were swapped out seemed okay but pages with cleared PTEs seemed
problematic.

I looked at routines related to pte_clear and noticed ptep_clear_flush.
The default implementation just flushes the TLB entry. However, it was
obvious that on parisc we need to flush the cache page as well. If
we don't flush the cache page, stale lines will be left in the cache
and cause random corruption. Once a PTE is cleared, there is no way
to find the physical address associated with the PTE and flush the
associated page at a later time.

I implemented an updated change with a parisc specific version of
ptep_clear_flush. It fixed the random data corruption on Helge's rp4440
and rp3440, as well as on my c8000.

At this point, I realized that I could restore the code where we only
flush in flush_cache_page_if_present if the page has been accessed.
However, for this, we also need to flush the cache when the accessed
bit is cleared in
---truncated---</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('2fc67feb70e358e22678eb8f68937f4368eea43e')">
                                    <div class="issue-number">514</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="2fc67feb70e358e22678eb8f68937f4368eea43e">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

s390/pkey: Wipe copies of protected- and secure-keys

Although the clear-key of neither protected- nor secure-keys is
accessible, this key material should only be visible to the calling
process. So wipe all copies of protected- or secure-keys from stack,
even in case of an error.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('1cb6627ff7abbe8adba243925b3fd12bb637ac48')">
                                    <div class="issue-number">515</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="1cb6627ff7abbe8adba243925b3fd12bb637ac48">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

usb: typec: tipd: Free IRQ only if it was requested before

In polling mode, if no IRQ was requested there is no need to free it.
Call devm_free_irq() only if client->irq is set. This fixes the warning
caused by the tps6598x module removal:

WARNING: CPU: 2 PID: 333 at kernel/irq/devres.c:144 devm_free_irq+0x80/0x8c
...
...
Call trace:
  devm_free_irq+0x80/0x8c
  tps6598x_remove+0x28/0x88 [tps6598x]
  i2c_device_remove+0x2c/0x9c
  device_remove+0x4c/0x80
  device_release_driver_internal+0x1cc/0x228
  driver_detach+0x50/0x98
  bus_remove_driver+0x6c/0xbc
  driver_unregister+0x30/0x60
  i2c_del_driver+0x54/0x64
  tps6598x_i2c_driver_exit+0x18/0xc3c [tps6598x]
  __arm64_sys_delete_module+0x184/0x264
  invoke_syscall+0x48/0x110
  el0_svc_common.constprop.0+0xc8/0xe8
  do_el0_svc+0x20/0x2c
  el0_svc+0x28/0x98
  el0t_64_sync_handler+0x13c/0x158
  el0t_64_sync+0x190/0x194</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('f7a01fc6b81de399b95d8043cceb3d31b31e2af4')">
                                    <div class="issue-number">516</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="f7a01fc6b81de399b95d8043cceb3d31b31e2af4">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

udf: refactor inode_bmap() to handle error

Refactor inode_bmap() to handle error since udf_next_aext() can return
error now. On situations like ftruncate, udf_extend_file() can now
detect errors and bail out early without resorting to checking for
particular offsets and assuming internal behavior of these functions.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('e9a634b5b63c0be7343b91180ecc4ae116d83029')">
                                    <div class="issue-number">517</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="e9a634b5b63c0be7343b91180ecc4ae116d83029">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In the Linux kernel, the following vulnerability has been resolved:

mm: krealloc: Fix MTE false alarm in __do_krealloc

This patch addresses an issue introduced by commit 1a83a716ec233 ("mm:
krealloc: consider spare memory for __GFP_ZERO") which causes MTE
(Memory Tagging Extension) to falsely report a slab-out-of-bounds error.

The problem occurs when zeroing out spare memory in __do_krealloc. The
original code only considered software-based KASAN and did not account
for MTE. It does not reset the KASAN tag before calling memset, leading
to a mismatch between the pointer tag and the memory tag, resulting
in a false positive.

Example of the error:
==================================================================
swapper/0: BUG: KASAN: slab-out-of-bounds in __memset+0x84/0x188
swapper/0: Write at addr f4ffff8005f0fdf0 by task swapper/0/1
swapper/0: Pointer tag: [f4], memory tag: [fe]
swapper/0:
swapper/0: CPU: 4 UID: 0 PID: 1 Comm: swapper/0 Not tainted 6.12.
swapper/0: Hardware name: MT6991(ENG) (DT)
swapper/0: Call trace:
swapper/0:  dump_backtrace+0xfc/0x17c
swapper/0:  show_stack+0x18/0x28
swapper/0:  dump_stack_lvl+0x40/0xa0
swapper/0:  print_report+0x1b8/0x71c
swapper/0:  kasan_report+0xec/0x14c
swapper/0:  __do_kernel_fault+0x60/0x29c
swapper/0:  do_bad_area+0x30/0xdc
swapper/0:  do_tag_check_fault+0x20/0x34
swapper/0:  do_mem_abort+0x58/0x104
swapper/0:  el1_abort+0x3c/0x5c
swapper/0:  el1h_64_sync_handler+0x80/0xcc
swapper/0:  el1h_64_sync+0x68/0x6c
swapper/0:  __memset+0x84/0x188
swapper/0:  btf_populate_kfunc_set+0x280/0x3d8
swapper/0:  __register_btf_kfunc_id_set+0x43c/0x468
swapper/0:  register_btf_kfunc_id_set+0x48/0x60
swapper/0:  register_nf_nat_bpf+0x1c/0x40
swapper/0:  nf_nat_init+0xc0/0x128
swapper/0:  do_one_initcall+0x184/0x464
swapper/0:  do_initcall_level+0xdc/0x1b0
swapper/0:  do_initcalls+0x70/0xc0
swapper/0:  do_basic_setup+0x1c/0x28
swapper/0:  kernel_init_freeable+0x144/0x1b8
swapper/0:  kernel_init+0x20/0x1a8
swapper/0:  ret_from_fork+0x10/0x20
==================================================================</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('b62c8a2d3e138b97363150bc506443183af16782')">
                                    <div class="issue-number">518</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="b62c8a2d3e138b97363150bc506443183af16782">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> TEMP-0000000-F7A20F</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('cadd0be6b20416dab85c920ab0a2181a7c2c3e5c')">
                                    <div class="issue-number">519</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="cadd0be6b20416dab85c920ab0a2181a7c2c3e5c">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> initscripts in rPath Linux 1 sets insecure permissions for the /var/log/btmp file, which allows local users to obtain sensitive information regarding authentication attempts.  NOTE: because sshd detects the insecure permissions and does not log certain events, this also prevents sshd from logging failed authentication attempts by remote attackers.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('9bf938a545b02871a74387bb4b860244f66fe2e6')">
                                    <div class="issue-number">520</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="9bf938a545b02871a74387bb4b860244f66fe2e6">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In Shadow 4.13, it is possible to inject control characters into fields provided to the SUID program chfn (change finger). Although it is not possible to exploit this directly (e.g., adding a new user fails because \n is in the block list), it is possible to misrepresent the /etc/passwd file when viewed. Use of \r manipulations and Unicode characters to work around blocking of the : character make it possible to give the impression that a new user has been added. In other words, an adversary may be able to convince a system administrator to take the system offline (an indirect, social-engineered denial of service) by demonstrating that "cat /etc/passwd" shows a rogue user account.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('87eebd8302537fc67413c9b8362679a172d76d9b')">
                                    <div class="issue-number">521</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="87eebd8302537fc67413c9b8362679a172d76d9b">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> TEMP-0628843-DBAD28</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('4a17e9b86a9761e81d9d6bd8440a88805fd73a72')">
                                    <div class="issue-number">522</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="4a17e9b86a9761e81d9d6bd8440a88805fd73a72">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The (1) maketemp and (2) mkstemp builtin functions in GNU m4 before 1.4.11 do not quote their output when a file is created, which might allow context-dependent attackers to trigger a macro expansion, leading to unspecified use of an incorrect filename.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('6b30a8cc73ccbf3aaea01c264458dcebda1fc362')">
                                    <div class="issue-number">523</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="6b30a8cc73ccbf3aaea01c264458dcebda1fc362">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Unspecified vulnerability in GNU m4 before 1.4.11 might allow context-dependent attackers to execute arbitrary code, related to improper handling of filenames specified with the -F option.  NOTE: it is not clear when this issue crosses privilege boundaries.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('e0033969c5a89166bbfac778eea363b98feac35c')">
                                    <div class="issue-number">524</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="e0033969c5a89166bbfac778eea363b98feac35c">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an "INPUTRC" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('033293fedcbf2b96e3a4740a252166f00c30dc56')">
                                    <div class="issue-number">525</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="033293fedcbf2b96e3a4740a252166f00c30dc56">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> OpenSSH 4.6 and earlier, when ChallengeResponseAuthentication is enabled, allows remote attackers to determine the existence of user accounts by attempting to authenticate via S/KEY, which displays a different response if the user account exists, a similar issue to CVE-2001-1483.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('7dd4f3290553c611b817393368a7ee525e14ed53')">
                                    <div class="issue-number">526</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="7dd4f3290553c611b817393368a7ee525e14ed53">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> OpenSSH, when using OPIE (One-Time Passwords in Everything) for PAM, allows remote attackers to determine the existence of certain user accounts, which displays a different response if the user account exists and is configured to use one-time passwords (OTP), a similar issue to CVE-2007-2243.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('5273a929738e81395a6d687c5abed6e761a02812')">
                                    <div class="issue-number">527</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="5273a929738e81395a6d687c5abed6e761a02812">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> sshd in OpenSSH 4 on Debian GNU/Linux, and the 20070303 OpenSSH snapshot, allows remote authenticated users to obtain access to arbitrary SELinux roles by appending a :/ (colon slash) sequence, followed by the role name, to the username.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('ad5277d3b1844e1e0eae383af2b7a735afa84c31')">
                                    <div class="issue-number">528</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="ad5277d3b1844e1e0eae383af2b7a735afa84c31">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> OpenSSH through 8.7 allows remote attackers, who have a suspicion that a certain combination of username and public key is known to an SSH server, to test whether this suspicion is correct. This occurs because a challenge is sent only when that combination could be valid for a login session. NOTE: the vendor does not recognize user enumeration as a vulnerability for this product</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('a240af5eafce84c7683a20c07dce0ebc986106e1')">
                                    <div class="issue-number">529</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="a240af5eafce84c7683a20c07dce0ebc986106e1">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Remotely observable behaviour in auth-gss2.c in OpenSSH through 7.8 could be used by remote attackers to detect existence of users on a target system when GSS2 is in use. NOTE: the discoverer states 'We understand that the OpenSSH developers do not want to treat such a username enumeration (or "oracle") as a vulnerability.'</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('edd26e933bfc1cbe713d84464712526da7348c0b')">
                                    <div class="issue-number">530</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="edd26e933bfc1cbe713d84464712526da7348c0b">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In OpenSSH 7.9, due to accepting and displaying arbitrary stderr output from the server, a malicious server (or Man-in-The-Middle attacker) can manipulate the client output, for example to use ANSI control codes to hide additional files being transferred.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('ed6d541818cd247663d60d4d892c0e01a70e2fd4')">
                                    <div class="issue-number">531</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="ed6d541818cd247663d60d4d892c0e01a70e2fd4">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The client side in OpenSSH 5.7 through 8.4 has an Observable Discrepancy leading to an information leak in the algorithm negotiation. This allows man-in-the-middle attackers to target initial connection attempts (where no host key for the server has been cached by the client). NOTE: some reports state that 8.5 and 8.6 are also affected.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('9e69e19d718b04a205dfeb5486338efc837619da')">
                                    <div class="issue-number">532</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="9e69e19d718b04a205dfeb5486338efc837619da">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> scp in OpenSSH through 8.3p1 allows command injection in the scp.c toremote function, as demonstrated by backtick characters in the destination argument. NOTE: the vendor reportedly has stated that they intentionally omit validation of "anomalous argument transfers" because that could "stand a great chance of breaking existing workflows."</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('d0ca42e9f6f9cbb674acdada5420a9e404505dc4')">
                                    <div class="issue-number">533</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="d0ca42e9f6f9cbb674acdada5420a9e404505dc4">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> OpenSSH through 9.6, when common types of DRAM are used, might allow row hammer attacks (for authentication bypass) because the integer value of authenticated in mm_answer_authpassword does not resist flips of a single bit. NOTE: this is applicable to a certain threat model of attacker-victim co-location in which the attacker has user privileges.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('94e828d9eae90557a6a0c3faa01d43a58d9d127e')">
                                    <div class="issue-number">534</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="94e828d9eae90557a6a0c3faa01d43a58d9d127e">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> initscripts in rPath Linux 1 sets insecure permissions for the /var/log/btmp file, which allows local users to obtain sensitive information regarding authentication attempts.  NOTE: because sshd detects the insecure permissions and does not log certain events, this also prevents sshd from logging failed authentication attempts by remote attackers.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('8df3be8913e5be180a12af479d0dcc022826901d')">
                                    <div class="issue-number">535</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="8df3be8913e5be180a12af479d0dcc022826901d">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In Shadow 4.13, it is possible to inject control characters into fields provided to the SUID program chfn (change finger). Although it is not possible to exploit this directly (e.g., adding a new user fails because \n is in the block list), it is possible to misrepresent the /etc/passwd file when viewed. Use of \r manipulations and Unicode characters to work around blocking of the : character make it possible to give the impression that a new user has been added. In other words, an adversary may be able to convince a system administrator to take the system offline (an indirect, social-engineered denial of service) by demonstrating that "cat /etc/passwd" shows a rogue user account.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('3690c10899df2d7b250fd60aa903158c45c52f66')">
                                    <div class="issue-number">536</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="3690c10899df2d7b250fd60aa903158c45c52f66">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> TEMP-0628843-DBAD28</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('1a04dc323158dcdb889f9beb2843cef01f7d96d2')">
                                    <div class="issue-number">537</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="1a04dc323158dcdb889f9beb2843cef01f7d96d2">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Directory traversal vulnerability in util.c in GNU patch 2.6.1 and earlier allows user-assisted remote attackers to create or overwrite arbitrary files via a filename that is specified with a .. (dot dot) or full pathname, a related issue to CVE-2010-1679.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('8bf69595a4ca5173c973d6b56b96b2d5e988c1c9')">
                                    <div class="issue-number">538</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="8bf69595a4ca5173c973d6b56b96b2d5e988c1c9">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An issue was discovered in GNU patch through 2.7.6. There is a segmentation fault, associated with a NULL pointer dereference, leading to a denial of service in the intuit_diff_type function in pch.c, aka a "mangled rename" issue.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('b7f3dde8ec2fae618c976bb135b58b12caa7c783')">
                                    <div class="issue-number">539</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="b7f3dde8ec2fae618c976bb135b58b12caa7c783">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A double free exists in the another_hunk function in pch.c in GNU patch through 2.7.6.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('33fbd6c2b86b77cc6e858463be60a809a7384c86')">
                                    <div class="issue-number">540</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="33fbd6c2b86b77cc6e858463be60a809a7384c86">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> An Invalid Pointer vulnerability exists in GNU patch 2.7 via the another_hunk function, which causes a Denial of Service.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('d6d07217efbe008b3a6bdc1bee22a828b4b05b53')">
                                    <div class="issue-number">541</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="d6d07217efbe008b3a6bdc1bee22a828b4b05b53">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> _is_safe in the File::Temp module for Perl does not properly handle symlinks.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('6a692d9f96f824f4505804bf76849e6f97748081')">
                                    <div class="issue-number">542</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="6a692d9f96f824f4505804bf76849e6f97748081">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> HTTP::Tiny before 0.083, a Perl core module since 5.13.9 and available standalone on CPAN, has an insecure default TLS configuration where users must opt in to verify certificates.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('4290d4ad7e20dc61bd49ffc4be4e765c995b849b')">
                                    <div class="issue-number">543</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="4290d4ad7e20dc61bd49ffc4be4e765c995b849b">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> _is_safe in the File::Temp module for Perl does not properly handle symlinks.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('7983e86edeb435f89abb9e4d9dd84c39bdfcc0b0')">
                                    <div class="issue-number">544</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="7983e86edeb435f89abb9e4d9dd84c39bdfcc0b0">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> HTTP::Tiny before 0.083, a Perl core module since 5.13.9 and available standalone on CPAN, has an insecure default TLS configuration where users must opt in to verify certificates.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('5de8f181f7bafec4444a557e457c8e22a73d005e')">
                                    <div class="issue-number">545</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="5de8f181f7bafec4444a557e457c8e22a73d005e">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> _is_safe in the File::Temp module for Perl does not properly handle symlinks.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('f89ed63e6dfca77fb0a7265819dd7b9952b816e5')">
                                    <div class="issue-number">546</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="f89ed63e6dfca77fb0a7265819dd7b9952b816e5">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> HTTP::Tiny before 0.083, a Perl core module since 5.13.9 and available standalone on CPAN, has an insecure default TLS configuration where users must opt in to verify certificates.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('9d56a44a86ae232a2858f24d9401cdab3c0cd408')">
                                    <div class="issue-number">547</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="9d56a44a86ae232a2858f24d9401cdab3c0cd408">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Under some circumstances, this weakness allows a user who has access to run the “ps” utility on a machine, the ability to write almost unlimited amounts of unfiltered data into the process heap.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('bf11c24074d25941d1c797e4cccbf11ff8e739ba')">
                                    <div class="issue-number">548</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="bf11c24074d25941d1c797e4cccbf11ff8e739ba">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The urllib.parse.urlsplit() and urlparse() functions improperly validated bracketed hosts (`[]`), allowing hosts that weren't IPv6 or IPvFuture. This behavior was not conformant to RFC 3986 and potentially enabled SSRF if a URL is processed by more than one URL parser.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('d30b088d43890429093a7604f8bea9b172e0beca')">
                                    <div class="issue-number">549</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="d30b088d43890429093a7604f8bea9b172e0beca">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> The urllib.parse.urlsplit() and urlparse() functions improperly validated bracketed hosts (`[]`), allowing hosts that weren't IPv6 or IPvFuture. This behavior was not conformant to RFC 3986 and potentially enabled SSRF if a URL is processed by more than one URL parser.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('7ef93f14730258f7b2cc8456783d2ab3efc2b8ff')">
                                    <div class="issue-number">550</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="7ef93f14730258f7b2cc8456783d2ab3efc2b8ff">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> TEMP-0517018-A83CE6</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('3eefbe05b5405b5c947ddbca447c9100b3e29dbf')">
                                    <div class="issue-number">551</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="3eefbe05b5405b5c947ddbca447c9100b3e29dbf">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> Tar 1.15.1 does not properly warn the user when extracting setuid or setgid files, which may allow local users or remote attackers to gain privileges.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('05a10dee0e2f42924e3df7490cd5eb94dc5e43eb')">
                                    <div class="issue-number">552</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="05a10dee0e2f42924e3df7490cd5eb94dc5e43eb">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> TEMP-0290435-0B57B5</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('1e869d2964542fe47f46e491803c0001f40dd404')">
                                    <div class="issue-number">553</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="1e869d2964542fe47f46e491803c0001f40dd404">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In Tcl 8.6.11, a format string vulnerability in nmakehlp.c might allow code execution via a crafted file. NOTE: multiple third parties dispute the significance of this finding</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('f46b94f570778a5eb030a52a85491f761e1b3a63')">
                                    <div class="issue-number">554</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="f46b94f570778a5eb030a52a85491f761e1b3a63">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> In Tcl 8.6.11, a format string vulnerability in nmakehlp.c might allow code execution via a crafted file. NOTE: multiple third parties dispute the significance of this finding</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('6f145c3b0d4e51a5800b51c909ca12cf9a7984b4')">
                                    <div class="issue-number">555</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="6f145c3b0d4e51a5800b51c909ca12cf9a7984b4">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A flaw was found in unzip. The vulnerability occurs due to improper handling of Unicode strings, which can lead to a null pointer dereference. This flaw allows an attacker to input a specially crafted zip file, leading to a crash or code execution.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('7e6b0df8c8b7f897d0a8699b5455634771f70d49')">
                                    <div class="issue-number">556</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="7e6b0df8c8b7f897d0a8699b5455634771f70d49">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an "INPUTRC" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('4e2c8072574e9d1ce266a47b19687be9e01a5ca2')">
                                    <div class="issue-number">557</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="4e2c8072574e9d1ce266a47b19687be9e01a5ca2">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an "INPUTRC" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.</p>
                                </div>
                            </li>
                        
                            <li>
                                <div class="issue-summary severity-low"
                                     onclick="toggleDetail('934dbc305bdbc713d45706361531e08c4fb58a86')">
                                    <div class="issue-number">558</div>
                                    <div class="issue-details">
                                        <strong>漏洞名称：</strong> 
                                        <br>
                                        <strong>依赖项：</strong> 
                                    </div>
                                </div>
                                <div class="issue-detail" id="934dbc305bdbc713d45706361531e08c4fb58a86">
                                    <h4> - 详细信息</h4>
                                    <p><strong>Severity:</strong> Low</p>
                                    <p><strong>Dependency:</strong> </p>
                                    <p><strong>Description:</strong> A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an "INPUTRC" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.</p>
                                </div>
                            </li>
                        
                    </ul>
                
            
        </body>
        </html>
    